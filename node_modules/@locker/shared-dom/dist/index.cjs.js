/*!
 * Copyright (C) 2019 salesforce.com, inc.
 */
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var shared$LWS = require('@locker/shared');

const {
  prototype: AttrProto$LWS
} = Attr;
const AttrProtoNameGetter$LWS = shared$LWS.ObjectLookupOwnGetter(AttrProto$LWS, 'name');
const AttrProtoNamespaceURIGetter$LWS = shared$LWS.ObjectLookupOwnGetter(AttrProto$LWS, 'namespaceURI');
const AttrProtoOwnerElementGetter$LWS = shared$LWS.ObjectLookupOwnGetter(AttrProto$LWS, 'ownerElement');
const {
  get: AttrProtoValueGetter$LWS,
  set: AttrProtoValueSetter$LWS
} = shared$LWS.ReflectGetOwnPropertyDescriptor(AttrProto$LWS, 'value');
const rootDocument$LWS = document;
const {
  prototype: DocumentProto$LWS
} = Document; // Used by '@locker/near-membrane/dom'.

const {
  close: DocumentProtoClose$LWS,
  open: DocumentProtoOpen$LWS
} = DocumentProto$LWS;
const {
  createComment: DocumentProtoCreateComment$LWS,
  createElement: DocumentProtoCreateElement$LWS,
  createElementNS: DocumentProtoCreateElementNS$LWS,
  getElementById: DocumentProtoGetElementById$LWS
} = DocumentProto$LWS;
const DocumentProtoBodyGetter$LWS = shared$LWS.ObjectLookupOwnGetter(DocumentProto$LWS, 'body');
const {
  get: DocumentProtoCookieGetter$LWS,
  set: DocumentProtoCookieSetter$LWS
} = shared$LWS.ReflectGetOwnPropertyDescriptor(DocumentProto$LWS, 'cookie');
const DocumentProtoDefaultViewGetter$LWS = shared$LWS.ObjectLookupOwnGetter(DocumentProto$LWS, 'defaultView');
const DocumentProtoDocumentElementGetter$LWS = shared$LWS.ObjectLookupOwnGetter(DocumentProto$LWS, 'documentElement');
const DocumentProtoHeadGetter$LWS = shared$LWS.ObjectLookupOwnGetter(DocumentProto$LWS, 'head');
const DocumentProtoImplementationGetter$LWS = shared$LWS.ObjectLookupOwnGetter(DocumentProto$LWS, 'implementation');
const {
  prototype: ElementProto$LWS
} = Element; // Used by '@locker/near-membrane-dom'.

const {
  remove: ElementProtoRemove$LWS
} = ElementProto$LWS;
const {
  closest: ElementProtoClosest$LWS,
  getAttribute: ElementProtoGetAttribute$LWS,
  getAttributeNode: ElementProtoGetAttributeNode$LWS,
  getAttributeNodeNS: ElementProtoGetAttributeNodeNS$LWS,
  hasAttribute: ElementProtoHasAttribute$LWS,
  querySelector: ElementProtoQuerySelector$LWS,
  removeAttributeNode: ElementProtoRemoveAttributeNode$LWS,
  removeAttributeNS: ElementProtoRemoveAttributeNS$LWS,
  setAttribute: ElementProtoSetAttribute$LWS,
  setAttributeNS: ElementProtoSetAttributeNS$LWS
} = ElementProto$LWS;
const {
  get: ElementProtoInnerHTMLGetter$LWS,
  set: ElementProtoInnerHTMLSetter$LWS
} = shared$LWS.ReflectGetOwnPropertyDescriptor(ElementProto$LWS, 'innerHTML');
const {
  get: ElementProtoOuterHTMLGetter$LWS
} = shared$LWS.ReflectGetOwnPropertyDescriptor(ElementProto$LWS, 'outerHTML');
const ElementProtoNamespaceURIGetter$LWS = shared$LWS.ObjectLookupOwnGetter(ElementProto$LWS, 'namespaceURI');
const HTMLTemplateElementProtoContentGetter$LWS = shared$LWS.ObjectLookupOwnGetter(HTMLTemplateElement.prototype, 'content');
const {
  prototype: NodeProto$LWS
} = Node;
const {
  appendChild: NodeProtoAppendChild$LWS,
  cloneNode: NodeProtoCloneNode$LWS,
  isEqualNode: NodeProtoIsEqualNode$LWS
} = NodeProto$LWS;
const NodeProtoChildNodesGetter$LWS = shared$LWS.ObjectLookupOwnGetter(NodeProto$LWS, 'childNodes');
const NodeProtoFirstChildGetter$LWS = shared$LWS.ObjectLookupOwnGetter(NodeProto$LWS, 'firstChild');
const NodeProtoIsConnectedGetter$LWS = shared$LWS.ObjectLookupOwnGetter(NodeProto$LWS, 'isConnected'); // Used by '@locker/near-membrane-dom'.

const NodeProtoLastChildGetter$LWS = shared$LWS.ObjectLookupOwnGetter(NodeProto$LWS, 'lastChild');
const NodeProtoNodeNameGetter$LWS = shared$LWS.ObjectLookupOwnGetter(NodeProto$LWS, 'nodeName');
const NodeProtoOwnerDocumentGetter$LWS = shared$LWS.ObjectLookupOwnGetter(NodeProto$LWS, 'ownerDocument');
const rootWindow$LWS = window; // These properties are part of the WindowOrGlobalScope mixin and not on
// Window.prototype.
// https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope

const {
  setTimeout: WindowSetTimeout$LWS
} = rootWindow$LWS;
const {
  clearInterval: WindowClearInterval$LWS,
  decodeURIComponent: WindowDecodeURIComponent$LWS,
  encodeURIComponent: WindowEncodeURIComponent$LWS,
  setInterval: WindowSetInterval$LWS,
  top: topWindow$LWS
} = rootWindow$LWS;

const WindowQueueMicrotask$LWS = (() => {
  const {
    queueMicrotask: queueMicrotask$LWS
  } = rootWindow$LWS; // istanbul ignore else

  if (typeof queueMicrotask$LWS === 'function') {
    return queueMicrotask$LWS;
  } // Edge 15 does not support `queueMicrotask()`.
  // https://caniuse.com/mdn-api_queuemicrotask
  // https://developer.mozilla.org/en-US/docs/Web/API/queueMicrotask#when_queuemicrotask_isnt_available
  // istanbul ignore next: coverage is not measured in Edge 15, which means this whole fallback is considered "uncovered" when the tests are run in Chrome.
  // eslint-disable-next-line @typescript-eslint/no-shadow, no-shadow


  return function queueMicrotask$LWS(callback$LWS) {
    let promise$LWS = shared$LWS.PromiseResolve();
    promise$LWS = shared$LWS.ReflectApply(shared$LWS.PromiseProtoThen, promise$LWS, [callback$LWS]);
    shared$LWS.ReflectApply(shared$LWS.PromiseProtoCatch, promise$LWS, [error => WindowSetTimeout$LWS(() => {
      throw error;
    }, 0)]);
  };
})();

const WindowDocumentGetter$LWS = shared$LWS.ObjectLookupOwnGetter(rootWindow$LWS, 'document');
const WindowFrameElementGetter$LWS = shared$LWS.ObjectLookupOwnGetter(rootWindow$LWS, 'frameElement');
const WindowLengthGetter$LWS = shared$LWS.ObjectLookupOwnGetter(rootWindow$LWS, 'length');
const WindowLocationGetter$LWS = shared$LWS.ObjectLookupOwnGetter(rootWindow$LWS, 'location');

function isWindow$LWS(value$LWS) {
  if (typeof value$LWS === 'object' && value$LWS !== null && shared$LWS.ObjectHasOwn(value$LWS, 'window') && value$LWS.window === value$LWS) {
    // Slower check that must certainly detect a window object.
    try {
      // window.self getter only works for a window object, otherwise it
      // throws, additionally, this works fine for a detached window as
      // well, which is important since it will guarantee that this check
      // works also for iframes that are disconnected, and could be connected
      // later on, that should not bypass this check. This check is is also
      // equivalent to window.frames, and here is the very simple spec for
      // this getter:
      // https://html.spec.whatwg.org/multipage/window-object.html#dom-self
      shared$LWS.ReflectApply(WindowLocationGetter$LWS, value$LWS, []);
      return true; // eslint-disable-next-line no-empty
    } catch (_unused$LWS) {}
  }

  return false;
}
/* eslint no-underscore-dangle: ['error',{allowAfterThis:true}] */


class Validator$LWS {
  constructor(globalObject$LWS, document$LWS) {
    this.isAllowedSharedElementChild = element$LWS => element$LWS instanceof this._constructors.HTMLLinkElement || element$LWS instanceof this._constructors.HTMLScriptElement;

    this.isEqualDomString = (leftString$LWS, rightString$LWS) => {
      shared$LWS.ReflectApply(ElementProtoInnerHTMLSetter$LWS, this._templates.left, [leftString$LWS]);
      shared$LWS.ReflectApply(ElementProtoInnerHTMLSetter$LWS, this._templates.right, [rightString$LWS]);
      return deepIsEqualNode$LWS(this._templates.left, this._templates.right);
    };

    this.isSharedElement = element$LWS => element$LWS === shared$LWS.ReflectApply(DocumentProtoHeadGetter$LWS, this._document, []) || element$LWS === shared$LWS.ReflectApply(DocumentProtoBodyGetter$LWS, this._document, []) || element$LWS === shared$LWS.ReflectApply(DocumentProtoDocumentElementGetter$LWS, this._document, []);

    const {
      HTMLLinkElement: HTMLLinkElement$LWS,
      HTMLScriptElement: HTMLScriptElement$LWS
    } = globalObject$LWS;
    this._constructors = {
      HTMLLinkElement: HTMLLinkElement$LWS,
      HTMLScriptElement: HTMLScriptElement$LWS
    };
    this._document = document$LWS;
    this._templates = {
      left: shared$LWS.ReflectApply(DocumentProtoCreateElement$LWS, this._document, ['template']),
      right: shared$LWS.ReflectApply(DocumentProtoCreateElement$LWS, this._document, ['template'])
    };
  }

}

function deepIsEqualNode$LWS(leftRoot$LWS, rightRoot$LWS) {
  const leftRootNode$LWS = leftRoot$LWS instanceof HTMLTemplateElement ? shared$LWS.ReflectApply(HTMLTemplateElementProtoContentGetter$LWS, leftRoot$LWS, []) : leftRoot$LWS;
  const rightRootNode$LWS = rightRoot$LWS instanceof HTMLTemplateElement ? shared$LWS.ReflectApply(HTMLTemplateElementProtoContentGetter$LWS, rightRoot$LWS, []) : rightRoot$LWS;

  if (shared$LWS.ReflectApply(NodeProtoIsEqualNode$LWS, leftRootNode$LWS, [rightRootNode$LWS])) {
    const leftChildNodes$LWS = shared$LWS.ReflectApply(NodeProtoChildNodesGetter$LWS, leftRootNode$LWS, []);
    const childCount$LWS = leftChildNodes$LWS.length;

    if (childCount$LWS > 0) {
      const rightChildNodes$LWS = shared$LWS.ReflectApply(NodeProtoChildNodesGetter$LWS, rightRootNode$LWS, []);

      for (let i$LWS = 0; i$LWS < childCount$LWS; i$LWS += 1) {
        if (deepIsEqualNode$LWS(leftChildNodes$LWS[i$LWS], rightChildNodes$LWS[i$LWS]) === false) {
          return false;
        }
      }
    }

    return true;
  }

  return false;
}

const rootValidator$LWS = new Validator$LWS(rootWindow$LWS, rootDocument$LWS);
const documentToValidatorMap$LWS = shared$LWS.toSafeWeakMap(new shared$LWS.WeakMapCtor([[rootDocument$LWS, rootValidator$LWS]]));

function getValidator$LWS(globalObject$LWS, document$LWS = globalObject$LWS == null ? void 0 : globalObject$LWS.document) {
  // Fast path validator lookup for top level window.
  if (globalObject$LWS === undefined || globalObject$LWS === rootWindow$LWS) {
    return rootValidator$LWS;
  } // Use the `document` as the key because a window object maintains its identity
  // continuity when its location changes and while the non-configurable document
  // property does not.


  let validator$LWS = documentToValidatorMap$LWS.get(document$LWS);

  if (validator$LWS === undefined) {
    validator$LWS = new Validator$LWS(globalObject$LWS, document$LWS);
    documentToValidatorMap$LWS.set(document$LWS, validator$LWS);
  }

  return validator$LWS;
}

const BlobCtor$LWS = Blob;
const {
  prototype: BlobProto$LWS
} = BlobCtor$LWS;
const {
  slice: BlobProtoSlice$LWS
} = BlobProto$LWS;
const BlobProtoSizeGetter$LWS = shared$LWS.ObjectLookupOwnGetter(BlobProto$LWS, 'size');
const BlobProtoTypeGetter$LWS = shared$LWS.ObjectLookupOwnGetter(BlobProto$LWS, 'type');
const {
  // We don't cherry-pick the 'userAgent' property from `navigator` here
  // to avoid triggering its getter.
  navigator: navigator$LWS,
  navigator: {
    userAgentData: userAgentData$LWS
  }
} = rootWindow$LWS; // The user-agent client hints API is experimental and subject to change.
// https://caniuse.com/mdn-api_navigator_useragentdata
// istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator

const brands$LWS = userAgentData$LWS == null ? void 0 : userAgentData$LWS.brands; // Note: Chromium identifies itself as Chrome in its user-agent string.
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent

const chromiumUserAgentRegExp$LWS = / (?:Headless)?Chrome\/\d+/;
const headlessChromiumUserAgentRegExp$LWS = / HeadlessChrome\/\d+/;
const webKitUserAgentRegExp$LWS = /WebKit/i;
let userAgent$LWS;

function getUserAgent$LWS() {
  if (userAgent$LWS === undefined) {
    userAgent$LWS = navigator$LWS.userAgent;
  }

  return userAgent$LWS;
}

const IS_CHROMIUM_BROWSER$LWS = // While experimental, `navigator.userAgentData.brands` may be defined as an
// empty array in headless Chromium based browsers.
shared$LWS.ArrayIsArray(brands$LWS) && brands$LWS.length ? // Use user-agent client hints API if available to avoid deprecation
// warnings.
// https://developer.mozilla.org/en-US/docs/Web/API/User-Agent_Client_Hints_API
// istanbul ignore next: this code is not reachable in the coverage run.
shared$LWS.ReflectApply(shared$LWS.ArrayProtoFind, brands$LWS, [// prettier-ignore
item$LWS => (item$LWS == null ? void 0 : item$LWS.brand) === 'Chromium']) !== undefined : // Fallback to a standard user-agent string sniff.
shared$LWS.ReflectApply(shared$LWS.RegExpProtoTest, chromiumUserAgentRegExp$LWS, [getUserAgent$LWS()]);
const IS_HEADLESS_CHROMIUM_BROWSER$LWS = shared$LWS.ArrayIsArray(brands$LWS) && !brands$LWS.length || shared$LWS.ReflectApply(shared$LWS.RegExpProtoTest, headlessChromiumUserAgentRegExp$LWS, [getUserAgent$LWS()]);
const IS_WEBKIT_BROWSER$LWS = !IS_CHROMIUM_BROWSER$LWS && ( // istanbul ignore next: this code is not reachable in the coverage run.
shared$LWS.ArrayIsArray(brands$LWS) && brands$LWS.length ? shared$LWS.ReflectApply(shared$LWS.ArrayProtoFind, brands$LWS, [// istanbul ignore next
item$LWS => {
  const brand$LWS = item$LWS == null ? void 0 : item$LWS.brand;
  return typeof brand$LWS === 'string' && shared$LWS.ReflectApply(shared$LWS.RegExpProtoTest, webKitUserAgentRegExp$LWS, [brand$LWS]);
}]) !== undefined : shared$LWS.ReflectApply(shared$LWS.RegExpProtoTest, webKitUserAgentRegExp$LWS, [getUserAgent$LWS()]));
const {
  getElementById: DocumentFragmentProtoGetElementById$LWS
} = DocumentFragment.prototype; // The DOMException constructor was exposed in Edge 12 but wasn't invocable
// until Edge 79. As long as this is used for instanceof checks it should be fine.
// https://developer.mozilla.org/en-US/docs/Web/API/DOMException#browser_compatibility

const DOMExceptionCtor$LWS = DOMException;
const {
  DATA_CLONE_ERR: DATA_CLONE_ERROR_CODE$LWS
} = DOMExceptionCtor$LWS;
const {
  prototype: DOMExceptionProto$LWS
} = DOMExceptionCtor$LWS;
const DOMExceptionProtoCodeGetter$LWS = shared$LWS.ObjectLookupOwnGetter(DOMExceptionProto$LWS, 'code');
const {
  createDocument: DOMImplementationProtoCreateDocument$LWS
} = DOMImplementation.prototype;
const DOMTokenListProtoValueGetter$LWS = shared$LWS.ObjectLookupOwnGetter(DOMTokenList.prototype, 'value');
const EventCtor$LWS = Event;
const EventProtoCurrentTargetGetter$LWS = shared$LWS.ObjectLookupOwnGetter(EventCtor$LWS.prototype, 'currentTarget');
const {
  addEventListener: EventTargetProtoAddEventListener$LWS,
  removeEventListener: EventTargetProtoRemoveEventListener$LWS
} = EventTarget.prototype;
const HTMLAnchorElementProtoHostnameGetter$LWS = shared$LWS.ObjectLookupOwnGetter(HTMLAnchorElement.prototype, 'hostname');
const {
  get: HTMLAnchorElementProtoHrefGetter$LWS,
  set: HTMLAnchorElementProtoHrefSetter$LWS
} = shared$LWS.ReflectGetOwnPropertyDescriptor(HTMLAnchorElement.prototype, 'href');
const HTMLAnchorElementProtoPathnameGetter$LWS = shared$LWS.ObjectLookupOwnGetter(HTMLAnchorElement.prototype, 'pathname');
const HTMLAnchorElementProtoProtocolGetter$LWS = shared$LWS.ObjectLookupOwnGetter(HTMLAnchorElement.prototype, 'protocol');
const {
  prototype: HTMLElementProto$LWS
} = HTMLElement;
const HTMLElementProtoDatasetGetter$LWS = shared$LWS.ObjectLookupOwnGetter(HTMLElementProto$LWS, 'dataset'); // Used by '@locker/near-membrane-dom'.

const HTMLElementProtoStyleGetter$LWS = shared$LWS.ObjectLookupOwnGetter(HTMLElementProto$LWS, 'style');
const {
  prototype: HTMLIFrameElementProto$LWS
} = HTMLIFrameElement; // Used by '@locker/near-membrane-dom'.

const HTMLIFrameElementProtoContentWindowGetter$LWS = shared$LWS.ObjectLookupOwnGetter(HTMLIFrameElementProto$LWS, 'contentWindow');
const HTMLIFrameElementProtoSrcSetter$LWS = shared$LWS.ObjectLookupOwnSetter(HTMLIFrameElementProto$LWS, 'src');
const {
  get: HTMLScriptElementProtoSrcGetter$LWS,
  set: HTMLScriptElementProtoSrcSetter$LWS
} = shared$LWS.ReflectGetOwnPropertyDescriptor(HTMLScriptElement.prototype, 'src');
const NAMESPACE_DEFAULT$LWS = 'default';
const NAMESPACE_SVG$LWS = 'http://www.w3.org/2000/svg';
const NAMESPACE_XHTML$LWS = 'http://www.w3.org/1999/xhtml';
const NAMESPACE_XLINK$LWS = 'http://www.w3.org/1999/xlink';
const {
  createContextualFragment: RangeProtoCreateContextualFragment$LWS
} = Range.prototype;
const RequestProtoURLGetter$LWS = shared$LWS.ObjectLookupOwnGetter(Request.prototype, 'url');
const documentPattern$LWS = 'document';
const windowPattern$LWS = 'document\\.defaultView|frames|globalThis|self|window';
const webpackGlobalPattern$LWS = `${windowPattern$LWS}|global`;
const webpackGlobalDocumentPattern$LWS = `${documentPattern$LWS}|global.document`;
const locationReferencesRegExp$LWS = createPropertyReferenceRegExp$LWS(`${documentPattern$LWS}|${windowPattern$LWS}`, 'location');
const locationReferencesWithWebpackRegExp$LWS = createPropertyReferenceRegExp$LWS(`${webpackGlobalDocumentPattern$LWS}|${webpackGlobalPattern$LWS}`, 'location');
const sandboxEvalContextNameRegExp$LWS = new shared$LWS.RegExpCtor(`(?:^|\\W)${shared$LWS.escapeRegExp(shared$LWS.SANDBOX_EVAL_CONTEXT_NAME)}(?:\\W|$)`);
const webpackRequireNameRegExp$LWS = new shared$LWS.RegExpCtor(`\\b${shared$LWS.escapeRegExp(shared$LWS.WEBPACK_REQUIRE_NAME)}\\b`);
const windowTopReferencesRegExp$LWS = createPropertyReferenceRegExp$LWS(windowPattern$LWS, 'top');
const windowTopReferencesWithWebpackRegExp$LWS = createPropertyReferenceRegExp$LWS(webpackGlobalPattern$LWS, 'top');

function createPropertyReferenceRegExp$LWS(objectPattern$LWS, key$LWS) {
  // An assignment operator is defined by
  // https://tc39.es/ecma262/#prod-AssignmentOperator
  // as one of the following:
  //     *= /= %= += -= <<= >>= >>>= &= ^= |= **=
  return new shared$LWS.RegExpCtor(`\\b(?:${objectPattern$LWS})\\.${key$LWS}(\\s*(?:[?*/%&^|+-]|>>>?|<<)*=(?=[^=]))?`, 'g');
}

function compileSourceText$LWS(sourceText$LWS) {
  const transforms$LWS = {
    location: false,
    windowTop: false
  }; // To avoid conflicts with anyone else using `SANDBOX_EVAL_CONTEXT_NAME`,
  // we sniff the source text to see if it is present, and in that case we
  // don't proceed with the string replacement.

  if (shared$LWS.ReflectApply(shared$LWS.RegExpProtoTest, sandboxEvalContextNameRegExp$LWS, [sourceText$LWS])) {
    return {
      code: sourceText$LWS,
      transforms: transforms$LWS
    };
  }

  let locationRegExp$LWS;
  let topRegExp$LWS;

  if (shared$LWS.ReflectApply(shared$LWS.RegExpProtoTest, webpackRequireNameRegExp$LWS, [sourceText$LWS])) {
    locationRegExp$LWS = locationReferencesWithWebpackRegExp$LWS;
    topRegExp$LWS = windowTopReferencesWithWebpackRegExp$LWS;
  } else {
    locationRegExp$LWS = locationReferencesRegExp$LWS;
    topRegExp$LWS = windowTopReferencesRegExp$LWS;
  } // Input `sourceText` is non-compiled, so `window.location` returns `null`
  // inside the detached iframe sandbox. Our compiler solves this problem by
  // transforming the red `location` reference into a blue `location` reference.
  // The solution below emulates what our compiler does, but using a simple
  // string replacement.


  sourceText$LWS = shared$LWS.ReflectApply(shared$LWS.StringProtoReplace, sourceText$LWS, [locationRegExp$LWS, (_match$LWS, assignmentOperator$LWS) => {
    transforms$LWS.location = true;
    return assignmentOperator$LWS ? `${shared$LWS.UNCOMPILED_LOCATION_NAME}.href${assignmentOperator$LWS}` : shared$LWS.UNCOMPILED_LOCATION_NAME;
  }]); // In non-compiled source text `window.top` is null when evaluated in a
  // sandbox. We perform a naive transformation to replace references of
  // `window.top` to use our internal sandbox helpers.

  sourceText$LWS = shared$LWS.ReflectApply(shared$LWS.StringProtoReplace, sourceText$LWS, [topRegExp$LWS, () => {
    transforms$LWS.windowTop = true;
    return shared$LWS.UNCOMPILED_TOP_NAME;
  }]);
  return {
    code: sourceText$LWS,
    transforms: transforms$LWS
  };
}

function generateContextAssignmentCodeFromContextNames$LWS(names$LWS) {
  return names$LWS.length ? `const {${shared$LWS.ReflectApply(shared$LWS.ArrayProtoJoin, names$LWS, [','])}}=${shared$LWS.SANDBOX_EVAL_CONTEXT_NAME}` : '';
}

function getContextNamesFromCompilationTransforms$LWS(transforms$LWS) {
  const names$LWS = [];

  if (transforms$LWS.location) {
    names$LWS[names$LWS.length] = shared$LWS.UNCOMPILED_LOCATION_NAME;
  }

  if (transforms$LWS.windowTop) {
    names$LWS[names$LWS.length] = shared$LWS.UNCOMPILED_TOP_NAME;
  }

  return names$LWS;
}

function transformSourceText$LWS(sourceText$LWS) {
  const {
    code: code$LWS,
    transforms: transforms$LWS
  } = compileSourceText$LWS(sourceText$LWS);
  const contextNames$LWS = getContextNamesFromCompilationTransforms$LWS(transforms$LWS);

  if (!contextNames$LWS.length) {
    return code$LWS;
  }

  const prefix$LWS = `${generateContextAssignmentCodeFromContextNames$LWS(contextNames$LWS)};`;
  const pragmaIndex$LWS = shared$LWS.indexOfPragma(code$LWS, 'use strict');

  if (pragmaIndex$LWS === -1) {
    return prefix$LWS + code$LWS;
  } // The "use strict" pragma, including quotes, is 12 characters long.


  let afterPragmaIndex$LWS = pragmaIndex$LWS + 12; // istanbul ignore else

  if (afterPragmaIndex$LWS < code$LWS.length && code$LWS[afterPragmaIndex$LWS] === ';') {
    // Move index after the semicolon.
    afterPragmaIndex$LWS += 1;
  }

  return shared$LWS.ReflectApply(shared$LWS.StringProtoSlice, code$LWS, [0, afterPragmaIndex$LWS]) + prefix$LWS + shared$LWS.ReflectApply(shared$LWS.StringProtoSlice, code$LWS, [afterPragmaIndex$LWS]);
}

const {
  createObjectURL: URLCreateObjectURL$LWS,
  revokeObjectURL: URLRevokeObjectURL$LWS
} = URL;
const BLOB_SCRIPT_OPTIONS$LWS = {
  __proto__: null,
  type: 'text/javascript'
};
const SCRIPT_EVALUATOR_PROPERTY_NAME$LWS = '$evaluator$';
const SCRIPT_PAYLOAD_TOKEN$LWS = '$payload$';
const SCRIPT_HOOK_SRC_SOURCE_TEXT$LWS = `document.currentScript.${SCRIPT_EVALUATOR_PROPERTY_NAME$LWS}("${SCRIPT_PAYLOAD_TOKEN$LWS}")`;
const SCRIPT_HOOK_TEXT_CONTENT_SOURCE_TEXT$LWS = `document.currentScript.${SCRIPT_EVALUATOR_PROPERTY_NAME$LWS}()`;
const seenNodesThatSetTextContent$LWS = shared$LWS.toSafeWeakSet(new shared$LWS.WeakSetCtor());

function defineEvaluatorProperty$LWS(script$LWS, callback$LWS) {
  if (!shared$LWS.ReflectDefineProperty(script$LWS, SCRIPT_EVALUATOR_PROPERTY_NAME$LWS, {
    __proto__: null,
    configurable: true,
    // Create a bound function to obscure the getter source as "[native code]".
    get: shared$LWS.ReflectApply(shared$LWS.FunctionProtoBind, () => {
      deleteScriptEvaluatorProperty$LWS(script$LWS);
      const ownerDoc$LWS = shared$LWS.ReflectApply(NodeProtoOwnerDocumentGetter$LWS, script$LWS, []);
      const defaultView$LWS = shared$LWS.ReflectApply(DocumentProtoDefaultViewGetter$LWS, ownerDoc$LWS, []); // We don't need to use something like `WindowLocationGetter()`
      // because the 'location' and 'top' property are non-configurable.

      const context$LWS = {
        [shared$LWS.UNCOMPILED_LOCATION_NAME]: defaultView$LWS.location,
        [shared$LWS.UNCOMPILED_TOP_NAME]: defaultView$LWS.top
      };
      return (...args$LWS) => {
        callback$LWS(context$LWS, defaultView$LWS, ownerDoc$LWS, args$LWS);
      };
    }, [])
  })) {
    // istanbul ignore next: require a test to get the evaluator in a bad state. Like code that tried to access it in between. This is mostly a "the universe is not as expected error"
    throw new shared$LWS.LockerSecurityError(`Cannot evaluate ${shared$LWS.ReflectApply(NodeProtoNodeNameGetter$LWS, script$LWS, [])}`);
  }
}

function defineSrcEvaluatorProperty$LWS(script$LWS, sandboxEvaluator$LWS) {
  defineEvaluatorProperty$LWS(script$LWS, (context$LWS, defaultView$LWS, ownerDoc$LWS, {
    0: encodedPayload$LWS
  }) => {
    sandboxEvaluator$LWS(transformSourceText$LWS(WindowDecodeURIComponent$LWS(shared$LWS.toString(encodedPayload$LWS))), context$LWS, defaultView$LWS, ownerDoc$LWS);
  });
  return true;
}

function defineTextContentEvaluatorProperty$LWS(script$LWS, textContent$LWS, sandboxEvaluator$LWS) {
  // The textContent of a script element is only evaluated on the first set.
  // Subsequent sets change the textContent value but are not evaluated.
  if (seenNodesThatSetTextContent$LWS.has(script$LWS)) {
    return false;
  }

  seenNodesThatSetTextContent$LWS.add(script$LWS); // prettier-ignore

  defineEvaluatorProperty$LWS(script$LWS, (context$LWS, defaultView$LWS, ownerDoc$LWS) => {
    sandboxEvaluator$LWS(transformSourceText$LWS(textContent$LWS), context$LWS, defaultView$LWS, ownerDoc$LWS);
  });
  return true;
}

function deleteScriptEvaluatorProperty$LWS(script$LWS) {
  shared$LWS.ReflectDeleteProperty(script$LWS, SCRIPT_EVALUATOR_PROPERTY_NAME$LWS);
}

function getSrcEvaluatorHookSourceText$LWS(sourceText$LWS) {
  // Creates a blob URL to invoke the evaluator hook with encoded source text.
  return URLCreateObjectURL$LWS(new BlobCtor$LWS([shared$LWS.ReflectApply(shared$LWS.StringProtoReplace, SCRIPT_HOOK_SRC_SOURCE_TEXT$LWS, [SCRIPT_PAYLOAD_TOKEN$LWS, WindowEncodeURIComponent$LWS(sourceText$LWS)])], BLOB_SCRIPT_OPTIONS$LWS));
}

const getTextContentEvaluatorHookSourceText$LWS = () => SCRIPT_HOOK_TEXT_CONTENT_SOURCE_TEXT$LWS;

const {
  key: StorageProtoKey$LWS,
  getItem: StorageProtoGetItem$LWS,
  removeItem: StorageProtoRemoveItem$LWS,
  setItem: StorageProtoSetItem$LWS
} = Storage.prototype;
const SVGElementProtoDatasetGetter$LWS = shared$LWS.ObjectLookupOwnGetter(SVGElement.prototype, 'dataset'); // This has to be done 1-by-1 because putting a full file ignore in this file
// will result in dist/index.mjs.js containing the directive and subsequently being
// ignored.
// istanbul ignore next

const XhrCtor$LWS = XMLHttpRequest;
const {
  prototype: XhrProto$LWS
} = XhrCtor$LWS;
const {
  abort: XhrProtoAbort$LWS,
  open: XhrProtoOpen$LWS,
  send: XhrProtoSend$LWS
} = XhrProto$LWS;
const XhrProtoResponseTextGetter$LWS = shared$LWS.ObjectLookupOwnGetter(XhrProto$LWS, 'responseText');
const XhrProtoStatusGetter$LWS = shared$LWS.ObjectLookupOwnGetter(XhrProto$LWS, 'status');
const XhrProtoWithCredentialsSetter$LWS = shared$LWS.ObjectLookupOwnSetter(XhrProto$LWS, 'withCredentials');
exports.AttrProtoNameGetter = AttrProtoNameGetter$LWS;
exports.AttrProtoNamespaceURIGetter = AttrProtoNamespaceURIGetter$LWS;
exports.AttrProtoOwnerElementGetter = AttrProtoOwnerElementGetter$LWS;
exports.AttrProtoValueGetter = AttrProtoValueGetter$LWS;
exports.AttrProtoValueSetter = AttrProtoValueSetter$LWS;
exports.BlobCtor = BlobCtor$LWS;
exports.BlobProtoSizeGetter = BlobProtoSizeGetter$LWS;
exports.BlobProtoSlice = BlobProtoSlice$LWS;
exports.BlobProtoTypeGetter = BlobProtoTypeGetter$LWS;
exports.DATA_CLONE_ERROR_CODE = DATA_CLONE_ERROR_CODE$LWS;
exports.DOMExceptionCtor = DOMExceptionCtor$LWS;
exports.DOMExceptionProtoCodeGetter = DOMExceptionProtoCodeGetter$LWS;
exports.DOMImplementationProtoCreateDocument = DOMImplementationProtoCreateDocument$LWS;
exports.DOMTokenListProtoValueGetter = DOMTokenListProtoValueGetter$LWS;
exports.DocumentFragmentProtoGetElementById = DocumentFragmentProtoGetElementById$LWS;
exports.DocumentProtoBodyGetter = DocumentProtoBodyGetter$LWS;
exports.DocumentProtoClose = DocumentProtoClose$LWS;
exports.DocumentProtoCookieGetter = DocumentProtoCookieGetter$LWS;
exports.DocumentProtoCookieSetter = DocumentProtoCookieSetter$LWS;
exports.DocumentProtoCreateComment = DocumentProtoCreateComment$LWS;
exports.DocumentProtoCreateElement = DocumentProtoCreateElement$LWS;
exports.DocumentProtoCreateElementNS = DocumentProtoCreateElementNS$LWS;
exports.DocumentProtoDefaultViewGetter = DocumentProtoDefaultViewGetter$LWS;
exports.DocumentProtoDocumentElementGetter = DocumentProtoDocumentElementGetter$LWS;
exports.DocumentProtoGetElementById = DocumentProtoGetElementById$LWS;
exports.DocumentProtoHeadGetter = DocumentProtoHeadGetter$LWS;
exports.DocumentProtoImplementationGetter = DocumentProtoImplementationGetter$LWS;
exports.DocumentProtoOpen = DocumentProtoOpen$LWS;
exports.ElementProtoClosest = ElementProtoClosest$LWS;
exports.ElementProtoGetAttribute = ElementProtoGetAttribute$LWS;
exports.ElementProtoGetAttributeNode = ElementProtoGetAttributeNode$LWS;
exports.ElementProtoGetAttributeNodeNS = ElementProtoGetAttributeNodeNS$LWS;
exports.ElementProtoHasAttribute = ElementProtoHasAttribute$LWS;
exports.ElementProtoInnerHTMLGetter = ElementProtoInnerHTMLGetter$LWS;
exports.ElementProtoInnerHTMLSetter = ElementProtoInnerHTMLSetter$LWS;
exports.ElementProtoNamespaceURIGetter = ElementProtoNamespaceURIGetter$LWS;
exports.ElementProtoOuterHTMLGetter = ElementProtoOuterHTMLGetter$LWS;
exports.ElementProtoQuerySelector = ElementProtoQuerySelector$LWS;
exports.ElementProtoRemove = ElementProtoRemove$LWS;
exports.ElementProtoRemoveAttributeNS = ElementProtoRemoveAttributeNS$LWS;
exports.ElementProtoRemoveAttributeNode = ElementProtoRemoveAttributeNode$LWS;
exports.ElementProtoSetAttribute = ElementProtoSetAttribute$LWS;
exports.ElementProtoSetAttributeNS = ElementProtoSetAttributeNS$LWS;
exports.EventCtor = EventCtor$LWS;
exports.EventProtoCurrentTargetGetter = EventProtoCurrentTargetGetter$LWS;
exports.EventTargetProtoAddEventListener = EventTargetProtoAddEventListener$LWS;
exports.EventTargetProtoRemoveEventListener = EventTargetProtoRemoveEventListener$LWS;
exports.HTMLAnchorElementProtoHostnameGetter = HTMLAnchorElementProtoHostnameGetter$LWS;
exports.HTMLAnchorElementProtoHrefGetter = HTMLAnchorElementProtoHrefGetter$LWS;
exports.HTMLAnchorElementProtoHrefSetter = HTMLAnchorElementProtoHrefSetter$LWS;
exports.HTMLAnchorElementProtoPathnameGetter = HTMLAnchorElementProtoPathnameGetter$LWS;
exports.HTMLAnchorElementProtoProtocolGetter = HTMLAnchorElementProtoProtocolGetter$LWS;
exports.HTMLElementProtoDatasetGetter = HTMLElementProtoDatasetGetter$LWS;
exports.HTMLElementProtoStyleGetter = HTMLElementProtoStyleGetter$LWS;
exports.HTMLIFrameElementProtoContentWindowGetter = HTMLIFrameElementProtoContentWindowGetter$LWS;
exports.HTMLIFrameElementProtoSrcSetter = HTMLIFrameElementProtoSrcSetter$LWS;
exports.HTMLScriptElementProtoSrcGetter = HTMLScriptElementProtoSrcGetter$LWS;
exports.HTMLScriptElementProtoSrcSetter = HTMLScriptElementProtoSrcSetter$LWS;
exports.HTMLTemplateElementProtoContentGetter = HTMLTemplateElementProtoContentGetter$LWS;
exports.IS_CHROMIUM_BROWSER = IS_CHROMIUM_BROWSER$LWS;
exports.IS_HEADLESS_CHROMIUM_BROWSER = IS_HEADLESS_CHROMIUM_BROWSER$LWS;
exports.IS_WEBKIT_BROWSER = IS_WEBKIT_BROWSER$LWS;
exports.NAMESPACE_DEFAULT = NAMESPACE_DEFAULT$LWS;
exports.NAMESPACE_SVG = NAMESPACE_SVG$LWS;
exports.NAMESPACE_XHTML = NAMESPACE_XHTML$LWS;
exports.NAMESPACE_XLINK = NAMESPACE_XLINK$LWS;
exports.NodeProtoAppendChild = NodeProtoAppendChild$LWS;
exports.NodeProtoChildNodesGetter = NodeProtoChildNodesGetter$LWS;
exports.NodeProtoCloneNode = NodeProtoCloneNode$LWS;
exports.NodeProtoFirstChildGetter = NodeProtoFirstChildGetter$LWS;
exports.NodeProtoIsConnectedGetter = NodeProtoIsConnectedGetter$LWS;
exports.NodeProtoIsEqualNode = NodeProtoIsEqualNode$LWS;
exports.NodeProtoLastChildGetter = NodeProtoLastChildGetter$LWS;
exports.NodeProtoNodeNameGetter = NodeProtoNodeNameGetter$LWS;
exports.NodeProtoOwnerDocumentGetter = NodeProtoOwnerDocumentGetter$LWS;
exports.RangeProtoCreateContextualFragment = RangeProtoCreateContextualFragment$LWS;
exports.RequestProtoURLGetter = RequestProtoURLGetter$LWS;
exports.SCRIPT_EVALUATOR_PROPERTY_NAME = SCRIPT_EVALUATOR_PROPERTY_NAME$LWS;
exports.SVGElementProtoDatasetGetter = SVGElementProtoDatasetGetter$LWS;
exports.StorageProtoGetItem = StorageProtoGetItem$LWS;
exports.StorageProtoKey = StorageProtoKey$LWS;
exports.StorageProtoRemoveItem = StorageProtoRemoveItem$LWS;
exports.StorageProtoSetItem = StorageProtoSetItem$LWS;
exports.URLCreateObjectURL = URLCreateObjectURL$LWS;
exports.URLRevokeObjectURL = URLRevokeObjectURL$LWS;
exports.WindowClearInterval = WindowClearInterval$LWS;
exports.WindowDecodeURIComponent = WindowDecodeURIComponent$LWS;
exports.WindowDocumentGetter = WindowDocumentGetter$LWS;
exports.WindowEncodeURIComponent = WindowEncodeURIComponent$LWS;
exports.WindowFrameElementGetter = WindowFrameElementGetter$LWS;
exports.WindowLengthGetter = WindowLengthGetter$LWS;
exports.WindowLocationGetter = WindowLocationGetter$LWS;
exports.WindowQueueMicrotask = WindowQueueMicrotask$LWS;
exports.WindowSetInterval = WindowSetInterval$LWS;
exports.XhrCtor = XhrCtor$LWS;
exports.XhrProtoAbort = XhrProtoAbort$LWS;
exports.XhrProtoOpen = XhrProtoOpen$LWS;
exports.XhrProtoResponseTextGetter = XhrProtoResponseTextGetter$LWS;
exports.XhrProtoSend = XhrProtoSend$LWS;
exports.XhrProtoStatusGetter = XhrProtoStatusGetter$LWS;
exports.XhrProtoWithCredentialsSetter = XhrProtoWithCredentialsSetter$LWS;
exports.compileSourceText = compileSourceText$LWS;
exports.defineSrcEvaluatorProperty = defineSrcEvaluatorProperty$LWS;
exports.defineTextContentEvaluatorProperty = defineTextContentEvaluatorProperty$LWS;
exports.deleteScriptEvaluatorProperty = deleteScriptEvaluatorProperty$LWS;
exports.generateContextAssignmentCodeFromContextNames = generateContextAssignmentCodeFromContextNames$LWS;
exports.getContextNamesFromCompilationTransforms = getContextNamesFromCompilationTransforms$LWS;
exports.getSrcEvaluatorHookSourceText = getSrcEvaluatorHookSourceText$LWS;
exports.getTextContentEvaluatorHookSourceText = getTextContentEvaluatorHookSourceText$LWS;
exports.getValidator = getValidator$LWS;
exports.isWindow = isWindow$LWS;
exports.rootDocument = rootDocument$LWS;
exports.rootValidator = rootValidator$LWS;
exports.rootWindow = rootWindow$LWS;
exports.topWindow = topWindow$LWS;
exports.transformSourceText = transformSourceText$LWS;
/*! version: 0.17.25 */
