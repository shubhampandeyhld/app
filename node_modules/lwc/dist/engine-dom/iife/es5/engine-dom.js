var LWC = (function (exports) {
    'use strict';

    function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf2(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }
    function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }
    function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }
    function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
    function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
    function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf2(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf2(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
    function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
    function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
    function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
    function _getPrototypeOf2(o) { _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf2(o); }
    function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
    function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
    function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
    function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
    function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
    function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
    function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
    function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
    function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
    function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
    function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
    function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
    function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
    function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
    function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
    /* proxy-compat-disable */
    /**
     * Copyright (C) 2018 salesforce.com, inc.
     */
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function invariant(value, msg) {
      if (!value) {
        throw new Error("Invariant Violation: ".concat(msg));
      }
    }
    function isTrue$1(value, msg) {
      if (!value) {
        throw new Error("Assert Violation: ".concat(msg));
      }
    }
    function isFalse$1(value, msg) {
      if (value) {
        throw new Error("Assert Violation: ".concat(msg));
      }
    }
    function fail(msg) {
      throw new Error(msg);
    }
    var assert = /*#__PURE__*/Object.freeze({
      __proto__: null,
      fail: fail,
      invariant: invariant,
      isFalse: isFalse$1,
      isTrue: isTrue$1
    });

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var assign = Object.assign,
      create = Object.create,
      defineProperties = Object.defineProperties,
      defineProperty = Object.defineProperty,
      freeze = Object.freeze,
      getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor,
      getOwnPropertyNames$1 = Object.getOwnPropertyNames,
      getPrototypeOf$1 = Object.getPrototypeOf,
      hasOwnProperty$1 = Object.hasOwnProperty,
      isFrozen = Object.isFrozen,
      keys = Object.keys,
      seal = Object.seal,
      setPrototypeOf = Object.setPrototypeOf;
    var isArray$1 = Array.isArray;
    var _Array$prototype = Array.prototype,
      ArrayCopyWithin = _Array$prototype.copyWithin,
      ArrayFill = _Array$prototype.fill,
      ArrayFilter = _Array$prototype.filter,
      ArrayIndexOf = _Array$prototype.indexOf,
      ArrayJoin = _Array$prototype.join,
      ArrayMap = _Array$prototype.map,
      ArrayPop = _Array$prototype.pop,
      ArrayPush$1 = _Array$prototype.push,
      ArrayReverse = _Array$prototype.reverse,
      ArrayShift = _Array$prototype.shift,
      ArraySlice = _Array$prototype.slice,
      ArraySome = _Array$prototype.some,
      ArraySort = _Array$prototype.sort,
      ArraySplice = _Array$prototype.splice,
      ArrayUnshift = _Array$prototype.unshift,
      forEach = _Array$prototype.forEach;
    var StringFromCharCode = String.fromCharCode;
    var _String$prototype = String.prototype,
      StringCharCodeAt = _String$prototype.charCodeAt,
      StringReplace = _String$prototype.replace,
      StringSplit = _String$prototype.split,
      StringSlice = _String$prototype.slice,
      StringToLowerCase = _String$prototype.toLowerCase;
    function isUndefined$1(obj) {
      return obj === undefined;
    }
    function isNull(obj) {
      return obj === null;
    }
    function isTrue(obj) {
      return obj === true;
    }
    function isFalse(obj) {
      return obj === false;
    }
    function isBoolean(obj) {
      return typeof obj === 'boolean';
    }
    function isFunction$1(obj) {
      return typeof obj === 'function';
    }
    function isObject(obj) {
      return _typeof(obj) === 'object';
    }
    function isString(obj) {
      return typeof obj === 'string';
    }
    function isNumber(obj) {
      return typeof obj === 'number';
    }
    function noop() {
      /* Do nothing */
    }
    var OtS$1 = {}.toString;
    function toString$1(obj) {
      if (obj && obj.toString) {
        // Arrays might hold objects with "null" prototype So using
        // Array.prototype.toString directly will cause an error Iterate through
        // all the items and handle individually.
        if (isArray$1(obj)) {
          return ArrayJoin.call(ArrayMap.call(obj, toString$1), ',');
        }
        return obj.toString();
      } else if (_typeof(obj) === 'object') {
        return OtS$1.call(obj);
      } else {
        return obj + '';
      }
    }
    function getPropertyDescriptor(o, p) {
      do {
        var _d = getOwnPropertyDescriptor$1(o, p);
        if (!isUndefined$1(_d)) {
          return _d;
        }
        o = getPrototypeOf$1(o);
      } while (o !== null);
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * According to the following list, there are 48 aria attributes of which two (ariaDropEffect and
     * ariaGrabbed) are deprecated:
     * https://www.w3.org/TR/wai-aria-1.1/#x6-6-definitions-of-states-and-properties-all-aria-attributes
     *
     * The above list of 46 aria attributes is consistent with the following resources:
     * https://github.com/w3c/aria/pull/708/files#diff-eacf331f0ffc35d4b482f1d15a887d3bR11060
     * https://wicg.github.io/aom/spec/aria-reflection.html
     *
     * NOTE: If you update this list, please update test files that implicitly reference this list!
     * Searching the codebase for `aria-flowto` and `ariaFlowTo` should be good enough to find all usages.
     */
    var AriaPropertyNames = ['ariaActiveDescendant', 'ariaAtomic', 'ariaAutoComplete', 'ariaBusy', 'ariaChecked', 'ariaColCount', 'ariaColIndex', 'ariaColSpan', 'ariaControls', 'ariaCurrent', 'ariaDescribedBy', 'ariaDetails', 'ariaDisabled', 'ariaErrorMessage', 'ariaExpanded', 'ariaFlowTo', 'ariaHasPopup', 'ariaHidden', 'ariaInvalid', 'ariaKeyShortcuts', 'ariaLabel', 'ariaLabelledBy', 'ariaLevel', 'ariaLive', 'ariaModal', 'ariaMultiLine', 'ariaMultiSelectable', 'ariaOrientation', 'ariaOwns', 'ariaPlaceholder', 'ariaPosInSet', 'ariaPressed', 'ariaReadOnly', 'ariaRelevant', 'ariaRequired', 'ariaRoleDescription', 'ariaRowCount', 'ariaRowIndex', 'ariaRowSpan', 'ariaSelected', 'ariaSetSize', 'ariaSort', 'ariaValueMax', 'ariaValueMin', 'ariaValueNow', 'ariaValueText', 'role'];
    var _ref = /*@__PURE__*/function () {
        var AriaAttrNameToPropNameMap = create(null);
        var AriaPropNameToAttrNameMap = create(null);
        // Synthetic creation of all AOM property descriptors for Custom Elements
        forEach.call(AriaPropertyNames, function (propName) {
          var attrName = StringToLowerCase.call(StringReplace.call(propName, /^aria/, function () {
            return 'aria-';
          }));
          AriaAttrNameToPropNameMap[attrName] = propName;
          AriaPropNameToAttrNameMap[propName] = attrName;
        });
        return {
          AriaAttrNameToPropNameMap: AriaAttrNameToPropNameMap,
          AriaPropNameToAttrNameMap: AriaPropNameToAttrNameMap
        };
      }(),
      AriaAttrNameToPropNameMap = _ref.AriaAttrNameToPropNameMap,
      AriaPropNameToAttrNameMap = _ref.AriaPropNameToAttrNameMap;
    // These attributes take either an ID or a list of IDs as values.
    // This includes aria-* attributes as well as the special non-ARIA "for" attribute
    var ID_REFERENCING_ATTRIBUTES_SET = new Set(['aria-activedescendant', 'aria-controls', 'aria-describedby', 'aria-details', 'aria-errormessage', 'aria-flowto', 'aria-labelledby', 'aria-owns', 'for']);

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // See browser support for globalThis:
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis#browser_compatibility
    /* istanbul ignore next */
    // @ts-ignore
    var _globalThis = (typeof globalThis === "undefined" ? "undefined" : _typeof(globalThis)) === 'object' ? globalThis : window;

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var KEY__IS_NATIVE_SHADOW_ROOT_DEFINED = '$isNativeShadowRootDefined$';
    var KEY__SHADOW_RESOLVER = '$shadowResolver$';
    var KEY__SHADOW_STATIC = '$shadowStaticNode$';
    var KEY__SHADOW_TOKEN = '$shadowToken$';
    var KEY__SYNTHETIC_MODE = '$$lwc-synthetic-mode';
    var KEY__SCOPED_CSS = '$scoped$';
    var KEY__NATIVE_GET_ELEMENT_BY_ID = '$nativeGetElementById$';
    var KEY__NATIVE_QUERY_SELECTOR_ALL = '$nativeQuerySelectorAll$';
    var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace';
    var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
    var XLINK_NAMESPACE = 'http://www.w3.org/1999/xlink';

    /*
     * Copyright (c) 2020, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var CAMEL_REGEX = /-([a-z])/g;
    // Convoluted map generation so that @lwc/shared remains fully tree-shakable (verify-treeshakable)
    var _ref2 = /*#__PURE__*/function () {
        /**
         * Map composed of properties to attributes not following the HTML property to attribute mapping
         * convention.
         */
        var NO_STANDARD_PROPERTY_ATTRIBUTE_MAPPING = new Map([['accessKey', 'accesskey'], ['readOnly', 'readonly'], ['tabIndex', 'tabindex'], ['bgColor', 'bgcolor'], ['colSpan', 'colspan'], ['rowSpan', 'rowspan'], ['contentEditable', 'contenteditable'], ['crossOrigin', 'crossorigin'], ['dateTime', 'datetime'], ['formAction', 'formaction'], ['isMap', 'ismap'], ['maxLength', 'maxlength'], ['minLength', 'minlength'], ['noValidate', 'novalidate'], ['useMap', 'usemap'], ['htmlFor', 'for']]);
        /**
         * Inverted map with attribute name key and property name value.
         */
        var NO_STANDARD_ATTRIBUTE_PROPERTY_MAPPING = new Map();
        NO_STANDARD_PROPERTY_ATTRIBUTE_MAPPING.forEach(function (value, key) {
          return NO_STANDARD_ATTRIBUTE_PROPERTY_MAPPING.set(value, key);
        });
        return {
          NO_STANDARD_ATTRIBUTE_PROPERTY_MAPPING: NO_STANDARD_ATTRIBUTE_PROPERTY_MAPPING,
          NO_STANDARD_PROPERTY_ATTRIBUTE_MAPPING: NO_STANDARD_PROPERTY_ATTRIBUTE_MAPPING
        };
      }(),
      NO_STANDARD_ATTRIBUTE_PROPERTY_MAPPING = _ref2.NO_STANDARD_ATTRIBUTE_PROPERTY_MAPPING,
      NO_STANDARD_PROPERTY_ATTRIBUTE_MAPPING = _ref2.NO_STANDARD_PROPERTY_ATTRIBUTE_MAPPING;
    /**
     * Map associating previously transformed HTML property into HTML attribute.
     */
    var CACHED_PROPERTY_ATTRIBUTE_MAPPING = new Map();
    /**
     * Map associating previously transformed HTML attribute into HTML property.
     */
    var CACHED_ATTRIBUTE_PROPERTY_MAPPING = new Map();
    function htmlPropertyToAttribute(propName) {
      var ariaAttributeName = AriaPropNameToAttrNameMap[propName];
      if (!isUndefined$1(ariaAttributeName)) {
        return ariaAttributeName;
      }
      var specialAttributeName = NO_STANDARD_PROPERTY_ATTRIBUTE_MAPPING.get(propName);
      if (!isUndefined$1(specialAttributeName)) {
        return specialAttributeName;
      }
      var cachedAttributeName = CACHED_PROPERTY_ATTRIBUTE_MAPPING.get(propName);
      if (!isUndefined$1(cachedAttributeName)) {
        return cachedAttributeName;
      }
      var attributeName = '';
      for (var _i = 0, len = propName.length; _i < len; _i++) {
        var code = StringCharCodeAt.call(propName, _i);
        if (code >= 65 &&
        // "A"
        code <= 90 // "Z"
        ) {
          attributeName += '-' + StringFromCharCode(code + 32);
        } else {
          attributeName += StringFromCharCode(code);
        }
      }
      CACHED_PROPERTY_ATTRIBUTE_MAPPING.set(propName, attributeName);
      return attributeName;
    }
    function htmlAttributeToProperty(attrName) {
      var ariaPropertyName = AriaAttrNameToPropNameMap[attrName];
      if (!isUndefined$1(ariaPropertyName)) {
        return ariaPropertyName;
      }
      var specialPropertyName = NO_STANDARD_ATTRIBUTE_PROPERTY_MAPPING.get(attrName);
      if (!isUndefined$1(specialPropertyName)) {
        return specialPropertyName;
      }
      var cachedPropertyName = CACHED_ATTRIBUTE_PROPERTY_MAPPING.get(attrName);
      if (!isUndefined$1(cachedPropertyName)) {
        return cachedPropertyName;
      }
      var propertyName = StringReplace.call(attrName, CAMEL_REGEX, function (g) {
        return g[1].toUpperCase();
      });
      CACHED_ATTRIBUTE_PROPERTY_MAPPING.set(attrName, propertyName);
      return propertyName;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // Increment whenever the LWC template compiler changes
    var LWC_VERSION = "2.45.1";
    var LWC_VERSION_COMMENT_REGEX = /\/\*LWC compiler v([\d.]+)\*\/\s*}/;
    /** version: 2.45.1 */

    /**
     * Copyright (C) 2018 salesforce.com, inc.
     */

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var features = {
      DUMMY_TEST_FLAG: null,
      ENABLE_FORCE_NATIVE_SHADOW_MODE_FOR_TEST: null,
      ENABLE_MIXED_SHADOW_MODE: null,
      ENABLE_NATIVE_CUSTOM_ELEMENT_LIFECYCLE: null,
      ENABLE_WIRE_SYNC_EMIT: null,
      DISABLE_LIGHT_DOM_UNSCOPED_CSS: null,
      ENABLE_FROZEN_TEMPLATE: null,
      DISABLE_ARIA_REFLECTION_POLYFILL: null
    };
    // eslint-disable-next-line no-restricted-properties
    if (!_globalThis.lwcRuntimeFlags) {
      Object.defineProperty(_globalThis, 'lwcRuntimeFlags', {
        value: create(null)
      });
    }
    // eslint-disable-next-line no-restricted-properties
    var flags = _globalThis.lwcRuntimeFlags;
    /**
     * Set the value at runtime of a given feature flag. This method only be invoked once per feature
     * flag. It is meant to be used during the app initialization.
     */
    function setFeatureFlag(name, value) {
      if (!isBoolean(value)) {
        var message = "Failed to set the value \"".concat(value, "\" for the runtime feature flag \"").concat(name, "\". Runtime feature flags can only be set to a boolean value.");
        if (process.env.NODE_ENV !== 'production') {
          throw new TypeError(message);
        } else {
          // eslint-disable-next-line no-console
          console.error(message);
          return;
        }
      }
      if (isUndefined$1(features[name])) {
        var availableFlags = keys(features).map(function (name) {
          return "\"".concat(name, "\"");
        }).join(', ');
        // eslint-disable-next-line no-console
        console.warn("Failed to set the value \"".concat(value, "\" for the runtime feature flag \"").concat(name, "\" because it is undefined. Available flags: ").concat(availableFlags, "."));
        return;
      }
      // This may seem redundant, but `process.env.NODE_ENV === 'test-karma-lwc'` is replaced by Karma tests
      if (process.env.NODE_ENV === 'test-karma-lwc' || process.env.NODE_ENV !== 'production') {
        // Allow the same flag to be set more than once outside of production to enable testing
        flags[name] = value;
      } else {
        // Disallow the same flag to be set more than once in production
        var runtimeValue = flags[name];
        if (!isUndefined$1(runtimeValue)) {
          // eslint-disable-next-line no-console
          console.error("Failed to set the value \"".concat(value, "\" for the runtime feature flag \"").concat(name, "\". \"").concat(name, "\" has already been set with the value \"").concat(runtimeValue, "\"."));
          return;
        }
        defineProperty(flags, name, {
          value: value
        });
      }
    }
    /**
     * Set the value at runtime of a given feature flag. This method should only be used for testing
     * purposes. It is a no-op when invoked in production mode.
     */
    function setFeatureFlagForTest(name, value) {
      // This may seem redundant, but `process.env.NODE_ENV === 'test-karma-lwc'` is replaced by Karma tests
      if (process.env.NODE_ENV === 'test-karma-lwc' || process.env.NODE_ENV !== 'production') {
        setFeatureFlag(name, value);
      }
    }
    /** version: 2.45.1 */

    /**
     * Copyright (C) 2018 salesforce.com, inc.
     */

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function detect(propName, prototype) {
      return isUndefined$1(getOwnPropertyDescriptor$1(prototype, propName));
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function createAriaPropertyPropertyDescriptor(attrName) {
      // Note that we need to call this.{get,set,has,remove}Attribute rather than dereferencing
      // from Element.prototype, because these methods are overridden in LightningElement.
      return {
        get: function get() {
          // reflect what's in the attribute
          return this.hasAttribute(attrName) ? this.getAttribute(attrName) : null;
        },
        set: function set(newValue) {
          // reflect into the corresponding attribute
          if (isNull(newValue)) {
            this.removeAttribute(attrName);
          } else {
            this.setAttribute(attrName, newValue);
          }
        },
        configurable: true,
        enumerable: true
      };
    }
    function patch$1(propName, prototype) {
      var attrName = AriaPropNameToAttrNameMap[propName];
      var descriptor = createAriaPropertyPropertyDescriptor(attrName);
      defineProperty(prototype, propName, descriptor);
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function applyAriaReflection() {
      var prototype = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Element.prototype;
      var ElementPrototypeAriaPropertyNames = keys(AriaPropNameToAttrNameMap);
      for (var _i2 = 0, len = ElementPrototypeAriaPropertyNames.length; _i2 < len; _i2 += 1) {
        var propName = ElementPrototypeAriaPropertyNames[_i2];
        if (detect(propName, prototype)) {
          patch$1(propName, prototype);
        }
      }
    }
    /** version: 2.45.1 */

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    if (!lwcRuntimeFlags.DISABLE_ARIA_REFLECTION_POLYFILL) {
      // If DISABLE_ARIA_REFLECTION_POLYFILL is false, then we need to apply the ARIA reflection polyfill globally,
      // i.e. to the global Element.prototype
      applyAriaReflection();
    }

    /* proxy-compat-disable */

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var onReportingEnabledCallbacks = [];
    /** The currently assigned reporting dispatcher. */
    var currentDispatcher$1 = noop;
    /**
     * Whether reporting is enabled.
     *
     * Note that this may seem redundant, given you can just check if the currentDispatcher is undefined,
     * but it turns out that Terser only strips out unused code if we use this explicit boolean.
     */
    var enabled$1 = false;
    var reportingControl = {
      /**
       * Attach a new reporting control (aka dispatcher).
       *
       * @param dispatcher - reporting control
       */
      attachDispatcher: function attachDispatcher(dispatcher) {
        enabled$1 = true;
        currentDispatcher$1 = dispatcher;
        for (var _i3 = 0, _onReportingEnabledCa = onReportingEnabledCallbacks; _i3 < _onReportingEnabledCa.length; _i3++) {
          var callback = _onReportingEnabledCa[_i3];
          try {
            callback();
          } catch (err) {
            // This should never happen. But if it does, we don't want one callback to cause another to fail
            // eslint-disable-next-line no-console
            console.error('Could not invoke callback', err);
          }
        }
        onReportingEnabledCallbacks.length = 0; // clear the array
      },
      /**
       * Detach the current reporting control (aka dispatcher).
       */
      detachDispatcher: function detachDispatcher() {
        enabled$1 = false;
        currentDispatcher$1 = noop;
      }
    };
    /**
     * Call a callback when reporting is enabled, or immediately if reporting is already enabled.
     * Will only ever be called once.
     * @param callback
     */
    function onReportingEnabled(callback) {
      if (enabled$1) {
        // call immediately
        callback();
      } else {
        // call later
        onReportingEnabledCallbacks.push(callback);
      }
    }
    /**
     * Report to the current dispatcher, if there is one.
     * @param reportingEventId
     * @param payload - data to report
     */
    function report(reportingEventId, payload) {
      if (enabled$1) {
        currentDispatcher$1(reportingEventId, payload);
      }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function getComponentTag(vm) {
      return "<".concat(StringToLowerCase.call(vm.tagName), ">");
    }
    // TODO [#1695]: Unify getComponentStack and getErrorComponentStack
    function getComponentStack(vm) {
      var stack = [];
      var prefix = '';
      while (!isNull(vm.owner)) {
        ArrayPush$1.call(stack, prefix + getComponentTag(vm));
        vm = vm.owner;
        prefix += '\t';
      }
      return ArrayJoin.call(stack, '\n');
    }
    function getErrorComponentStack(vm) {
      var wcStack = [];
      var currentVm = vm;
      while (!isNull(currentVm)) {
        ArrayPush$1.call(wcStack, getComponentTag(currentVm));
        currentVm = currentVm.owner;
      }
      return wcStack.reverse().join('\n\t');
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function addErrorComponentStack(vm, error) {
      if (!isFrozen(error) && isUndefined$1(error.wcStack)) {
        var wcStack = getErrorComponentStack(vm);
        defineProperty(error, 'wcStack', {
          get: function get() {
            return wcStack;
          }
        });
      }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var alreadyLoggedMessages = new Set();
    // Only used in LWC's Karma tests
    if (process.env.NODE_ENV === 'test-karma-lwc') {
      // @ts-ignore
      window.__lwcResetAlreadyLoggedMessages = function () {
        alreadyLoggedMessages.clear();
      };
    }
    function log(method, message, vm, once) {
      var msg = "[LWC ".concat(method, "]: ").concat(message);
      if (!isUndefined$1(vm)) {
        msg = "".concat(msg, "\n").concat(getComponentStack(vm));
      }
      if (once) {
        if (alreadyLoggedMessages.has(msg)) {
          return;
        }
        alreadyLoggedMessages.add(msg);
      }
      // In Jest tests, reduce the warning and error verbosity by not printing the callstack
      if (process.env.NODE_ENV === 'test') {
        /* eslint-disable-next-line no-console */
        console[method](msg);
        return;
      }
      try {
        throw new Error(msg);
      } catch (e) {
        /* eslint-disable-next-line no-console */
        console[method](e);
      }
    }
    function logError(message, vm) {
      log('error', message, vm, false);
    }
    function logWarn(message, vm) {
      log('warn', message, vm, false);
    }
    function logWarnOnce(message, vm) {
      log('warn', message, vm, true);
    }

    /*
     * Copyright (c) 2019, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var TargetToReactiveRecordMap = new WeakMap();
    function getReactiveRecord(target) {
      var reactiveRecord = TargetToReactiveRecordMap.get(target);
      if (isUndefined$1(reactiveRecord)) {
        var newRecord = create(null);
        reactiveRecord = newRecord;
        TargetToReactiveRecordMap.set(target, newRecord);
      }
      return reactiveRecord;
    }
    var currentReactiveObserver = null;
    function valueMutated(target, key) {
      var reactiveRecord = TargetToReactiveRecordMap.get(target);
      if (!isUndefined$1(reactiveRecord)) {
        var reactiveObservers = reactiveRecord[key];
        if (!isUndefined$1(reactiveObservers)) {
          for (var _i4 = 0, len = reactiveObservers.length; _i4 < len; _i4 += 1) {
            var ro = reactiveObservers[_i4];
            ro.notify();
          }
        }
      }
    }
    function valueObserved(target, key) {
      // We should determine if an active Observing Record is present to track mutations.
      if (currentReactiveObserver === null) {
        return;
      }
      var ro = currentReactiveObserver;
      var reactiveRecord = getReactiveRecord(target);
      var reactiveObservers = reactiveRecord[key];
      if (isUndefined$1(reactiveObservers)) {
        reactiveObservers = [];
        reactiveRecord[key] = reactiveObservers;
      } else if (reactiveObservers[0] === ro) {
        return; // perf optimization considering that most subscriptions will come from the same record
      }

      if (ArrayIndexOf.call(reactiveObservers, ro) === -1) {
        ro.link(reactiveObservers);
      }
    }
    var ReactiveObserver = /*#__PURE__*/function () {
      function ReactiveObserver(callback) {
        _classCallCheck(this, ReactiveObserver);
        this.listeners = [];
        this.callback = callback;
      }
      _createClass(ReactiveObserver, [{
        key: "observe",
        value: function observe(job) {
          var inceptionReactiveRecord = currentReactiveObserver;
          currentReactiveObserver = this;
          var error;
          try {
            job();
          } catch (e) {
            error = Object(e);
          } finally {
            currentReactiveObserver = inceptionReactiveRecord;
            if (error !== undefined) {
              throw error; // eslint-disable-line no-unsafe-finally
            }
          }
        }
        /**
         * This method is responsible for disconnecting the Reactive Observer
         * from any Reactive Record that has a reference to it, to prevent future
         * notifications about previously recorded access.
         */
      }, {
        key: "reset",
        value: function reset() {
          var listeners = this.listeners;
          var len = listeners.length;
          if (len > 0) {
            for (var _i5 = 0; _i5 < len; _i5 += 1) {
              var set = listeners[_i5];
              var pos = ArrayIndexOf.call(listeners[_i5], this);
              ArraySplice.call(set, pos, 1);
            }
            listeners.length = 0;
          }
        }
        // friend methods
      }, {
        key: "notify",
        value: function notify() {
          this.callback.call(undefined, this);
        }
      }, {
        key: "link",
        value: function link(reactiveObservers) {
          ArrayPush$1.call(reactiveObservers, this);
          // we keep track of observing records where the observing record was added to so we can do some clean up later on
          ArrayPush$1.call(this.listeners, reactiveObservers);
        }
      }]);
      return ReactiveObserver;
    }();
    function componentValueMutated(vm, key) {
      // On the server side, we don't need mutation tracking. Skipping it improves performance.
      {
        valueMutated(vm.component, key);
      }
    }
    function componentValueObserved(vm, key) {
      // On the server side, we don't need mutation tracking. Skipping it improves performance.
      {
        valueObserved(vm.component, key);
      }
    }
    function createReactiveObserver(callback) {
      // On the server side, we don't need mutation tracking. Skipping it improves performance.
      return new ReactiveObserver(callback);
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var nextTickCallbackQueue = [];
    var SPACE_CHAR = 32;
    var EmptyObject = seal(create(null));
    var EmptyArray = seal([]);
    function flushCallbackQueue() {
      if (process.env.NODE_ENV !== 'production') {
        if (nextTickCallbackQueue.length === 0) {
          throw new Error("Internal Error: If callbackQueue is scheduled, it is because there must be at least one callback on this pending queue.");
        }
      }
      var callbacks = nextTickCallbackQueue;
      nextTickCallbackQueue = []; // reset to a new queue
      for (var _i6 = 0, len = callbacks.length; _i6 < len; _i6 += 1) {
        callbacks[_i6]();
      }
    }
    function addCallbackToNextTick(callback) {
      if (process.env.NODE_ENV !== 'production') {
        if (!isFunction$1(callback)) {
          throw new Error("Internal Error: addCallbackToNextTick() can only accept a function callback");
        }
      }
      if (nextTickCallbackQueue.length === 0) {
        Promise.resolve().then(flushCallbackQueue);
      }
      ArrayPush$1.call(nextTickCallbackQueue, callback);
    }
    function guid() {
      function s4() {
        return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
      }
      return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
    }
    // Borrowed from Vue template compiler.
    // https://github.com/vuejs/vue/blob/531371b818b0e31a989a06df43789728f23dc4e8/src/platforms/web/util/style.js#L5-L16
    var DECLARATION_DELIMITER = /;(?![^(]*\))/g;
    var PROPERTY_DELIMITER = /:(.+)/;
    function parseStyleText(cssText) {
      var styleMap = {};
      var declarations = cssText.split(DECLARATION_DELIMITER);
      var _iterator = _createForOfIteratorHelper(declarations),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var declaration = _step.value;
          if (declaration) {
            var _declaration$split = declaration.split(PROPERTY_DELIMITER),
              _declaration$split2 = _slicedToArray(_declaration$split, 2),
              prop = _declaration$split2[0],
              value = _declaration$split2[1];
            if (prop !== undefined && value !== undefined) {
              styleMap[prop.trim()] = value.trim();
            }
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return styleMap;
    }
    // Make a shallow copy of an object but omit the given key
    function cloneAndOmitKey(object, keyToOmit) {
      var result = {};
      var _iterator2 = _createForOfIteratorHelper(keys(object)),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var key = _step2.value;
          if (key !== keyToOmit) {
            result[key] = object[key];
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return result;
    }
    function flattenStylesheets(stylesheets) {
      var list = [];
      var _iterator3 = _createForOfIteratorHelper(stylesheets),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var stylesheet = _step3.value;
          if (!isArray$1(stylesheet)) {
            list.push(stylesheet);
          } else {
            list.push.apply(list, _toConsumableArray(flattenStylesheets(stylesheet)));
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      return list;
    }
    // Set a ref (lwc:ref) on a VM, from a template API
    function setRefVNode(vm, ref, vnode) {
      if (process.env.NODE_ENV !== 'production' && isUndefined$1(vm.refVNodes)) {
        throw new Error('refVNodes must be defined when setting a ref');
      }
      // If this method is called, then vm.refVNodes is set as the template has refs.
      // If not, then something went wrong and we threw an error above.
      var refVNodes = vm.refVNodes;
      // In cases of conflict (two elements with the same ref), prefer, the last one,
      // in depth-first traversal order.
      if (!(ref in refVNodes) || refVNodes[ref].key < vnode.key) {
        refVNodes[ref] = vnode;
      }
    }
    // Throw an error if we're running in prod mode. Ensures code is truly removed from prod mode.
    function assertNotProd() {
      /* istanbul ignore if */
      if (process.env.NODE_ENV === 'production') {
        // this method should never leak to prod
        throw new ReferenceError();
      }
    }

    /*
     * Copyright (c) 2020, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function resolveCircularModuleDependency(fn) {
      var module = fn();
      return (module === null || module === void 0 ? void 0 : module.__esModule) ? module.default : module;
    }
    function isCircularModuleDependency(obj) {
      return isFunction$1(obj) && hasOwnProperty$1.call(obj, '__circular__');
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // This is a temporary workaround to get the @lwc/engine-server to evaluate in node without having
    // to inject at runtime.
    var HTMLElementConstructor = typeof HTMLElement !== 'undefined' ? HTMLElement : function () {};
    var HTMLElementPrototype = HTMLElementConstructor.prototype;

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // These properties get added to LWCElement.prototype publicProps automatically
    var defaultDefHTMLPropertyNames = ['accessKey', 'dir', 'draggable', 'hidden', 'id', 'lang', 'spellcheck', 'tabIndex', 'title'];
    var controlledElement = null;
    var controlledAttributeName;
    function isAttributeLocked(elm, attrName) {
      return elm !== controlledElement || attrName !== controlledAttributeName;
    }
    function lockAttribute(_elm, _key) {
      controlledElement = null;
      controlledAttributeName = undefined;
    }
    function unlockAttribute(elm, key) {
      controlledElement = elm;
      controlledAttributeName = key;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * This is a descriptor map that contains
     * all standard properties that a Custom Element can support (including AOM properties), which
     * determines what kind of capabilities the Base HTML Element and
     * Base Lightning Element should support.
     */
    var HTMLElementOriginalDescriptors = create(null);
    forEach.call(keys(AriaPropNameToAttrNameMap), function (propName) {
      // Note: intentionally using our in-house getPropertyDescriptor instead of getOwnPropertyDescriptor here because
      // in IE11, some properties are on Element.prototype instead of HTMLElement, just to be sure.
      var descriptor = getPropertyDescriptor(HTMLElementPrototype, propName);
      if (!isUndefined$1(descriptor)) {
        HTMLElementOriginalDescriptors[propName] = descriptor;
      }
    });
    forEach.call(defaultDefHTMLPropertyNames, function (propName) {
      // Note: intentionally using our in-house getPropertyDescriptor instead of getOwnPropertyDescriptor here because
      // in IE11, id property is on Element.prototype instead of HTMLElement, and we suspect that more will fall into
      // this category, so, better to be sure.
      var descriptor = getPropertyDescriptor(HTMLElementPrototype, propName);
      if (!isUndefined$1(descriptor)) {
        HTMLElementOriginalDescriptors[propName] = descriptor;
      }
    });

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function generateDataDescriptor(options) {
      return assign({
        configurable: true,
        enumerable: true,
        writable: true
      }, options);
    }
    function generateAccessorDescriptor(options) {
      return assign({
        configurable: true,
        enumerable: true
      }, options);
    }
    var isDomMutationAllowed = false;
    function unlockDomMutation() {
      assertNotProd(); // this method should never leak to prod
      isDomMutationAllowed = true;
    }
    function lockDomMutation() {
      assertNotProd(); // this method should never leak to prod
      isDomMutationAllowed = false;
    }
    function logMissingPortalError(name, type) {
      return logError("The `".concat(name, "` ").concat(type, " is available only on elements that use the `lwc:dom=\"manual\"` directive."));
    }
    function patchElementWithRestrictions(elm, options) {
      assertNotProd(); // this method should never leak to prod
      var originalOuterHTMLDescriptor = getPropertyDescriptor(elm, 'outerHTML');
      var descriptors = {
        outerHTML: generateAccessorDescriptor({
          get: function get() {
            return originalOuterHTMLDescriptor.get.call(this);
          },
          set: function set(value) {
            logError("Invalid attempt to set outerHTML on Element.");
            return originalOuterHTMLDescriptor.set.call(this, value);
          }
        })
      };
      // Apply extra restriction related to DOM manipulation if the element is not a portal.
      if (!options.isLight && options.isSynthetic && !options.isPortal) {
        var appendChild = elm.appendChild,
          insertBefore = elm.insertBefore,
          removeChild = elm.removeChild,
          replaceChild = elm.replaceChild;
        var originalNodeValueDescriptor = getPropertyDescriptor(elm, 'nodeValue');
        var originalInnerHTMLDescriptor = getPropertyDescriptor(elm, 'innerHTML');
        var originalTextContentDescriptor = getPropertyDescriptor(elm, 'textContent');
        assign(descriptors, {
          appendChild: generateDataDescriptor({
            value: function value(aChild) {
              logMissingPortalError('appendChild', 'method');
              return appendChild.call(this, aChild);
            }
          }),
          insertBefore: generateDataDescriptor({
            value: function value(newNode, referenceNode) {
              if (!isDomMutationAllowed) {
                logMissingPortalError('insertBefore', 'method');
              }
              return insertBefore.call(this, newNode, referenceNode);
            }
          }),
          removeChild: generateDataDescriptor({
            value: function value(aChild) {
              if (!isDomMutationAllowed) {
                logMissingPortalError('removeChild', 'method');
              }
              return removeChild.call(this, aChild);
            }
          }),
          replaceChild: generateDataDescriptor({
            value: function value(newChild, oldChild) {
              logMissingPortalError('replaceChild', 'method');
              return replaceChild.call(this, newChild, oldChild);
            }
          }),
          nodeValue: generateAccessorDescriptor({
            get: function get() {
              return originalNodeValueDescriptor.get.call(this);
            },
            set: function set(value) {
              if (!isDomMutationAllowed) {
                logMissingPortalError('nodeValue', 'property');
              }
              originalNodeValueDescriptor.set.call(this, value);
            }
          }),
          textContent: generateAccessorDescriptor({
            get: function get() {
              return originalTextContentDescriptor.get.call(this);
            },
            set: function set(value) {
              logMissingPortalError('textContent', 'property');
              originalTextContentDescriptor.set.call(this, value);
            }
          }),
          innerHTML: generateAccessorDescriptor({
            get: function get() {
              return originalInnerHTMLDescriptor.get.call(this);
            },
            set: function set(value) {
              logMissingPortalError('innerHTML', 'property');
              return originalInnerHTMLDescriptor.set.call(this, value);
            }
          })
        });
      }
      defineProperties(elm, descriptors);
    }
    function getShadowRootRestrictionsDescriptors(sr) {
      assertNotProd(); // this method should never leak to prod
      // Disallowing properties in dev mode only to avoid people doing the wrong
      // thing when using the real shadow root, because if that's the case,
      // the component will not work when running with synthetic shadow.
      var originalAddEventListener = sr.addEventListener;
      var originalInnerHTMLDescriptor = getPropertyDescriptor(sr, 'innerHTML');
      var originalTextContentDescriptor = getPropertyDescriptor(sr, 'textContent');
      return {
        innerHTML: generateAccessorDescriptor({
          get: function get() {
            return originalInnerHTMLDescriptor.get.call(this);
          },
          set: function set(value) {
            logError("Invalid attempt to set innerHTML on ShadowRoot.");
            return originalInnerHTMLDescriptor.set.call(this, value);
          }
        }),
        textContent: generateAccessorDescriptor({
          get: function get() {
            return originalTextContentDescriptor.get.call(this);
          },
          set: function set(value) {
            logError("Invalid attempt to set textContent on ShadowRoot.");
            return originalTextContentDescriptor.set.call(this, value);
          }
        }),
        addEventListener: generateDataDescriptor({
          value: function value(type, listener, options) {
            // TODO [#1824]: Potentially relax this restriction
            if (!isUndefined$1(options)) {
              logError('The `addEventListener` method on ShadowRoot does not support any options.', getAssociatedVMIfPresent(this));
            }
            // Typescript does not like it when you treat the `arguments` object as an array
            // @ts-ignore type-mismatch
            return originalAddEventListener.apply(this, arguments);
          }
        })
      };
    }
    // Custom Elements Restrictions:
    // -----------------------------
    function getCustomElementRestrictionsDescriptors(elm) {
      assertNotProd(); // this method should never leak to prod
      var originalAddEventListener = elm.addEventListener;
      var originalInnerHTMLDescriptor = getPropertyDescriptor(elm, 'innerHTML');
      var originalOuterHTMLDescriptor = getPropertyDescriptor(elm, 'outerHTML');
      var originalTextContentDescriptor = getPropertyDescriptor(elm, 'textContent');
      return {
        innerHTML: generateAccessorDescriptor({
          get: function get() {
            return originalInnerHTMLDescriptor.get.call(this);
          },
          set: function set(value) {
            logError("Invalid attempt to set innerHTML on HTMLElement.");
            return originalInnerHTMLDescriptor.set.call(this, value);
          }
        }),
        outerHTML: generateAccessorDescriptor({
          get: function get() {
            return originalOuterHTMLDescriptor.get.call(this);
          },
          set: function set(value) {
            logError("Invalid attempt to set outerHTML on HTMLElement.");
            return originalOuterHTMLDescriptor.set.call(this, value);
          }
        }),
        textContent: generateAccessorDescriptor({
          get: function get() {
            return originalTextContentDescriptor.get.call(this);
          },
          set: function set(value) {
            logError("Invalid attempt to set textContent on HTMLElement.");
            return originalTextContentDescriptor.set.call(this, value);
          }
        }),
        addEventListener: generateDataDescriptor({
          value: function value(type, listener, options) {
            // TODO [#1824]: Potentially relax this restriction
            if (!isUndefined$1(options)) {
              logError('The `addEventListener` method in `LightningElement` does not support any options.', getAssociatedVMIfPresent(this));
            }
            // Typescript does not like it when you treat the `arguments` object as an array
            // @ts-ignore type-mismatch
            return originalAddEventListener.apply(this, arguments);
          }
        })
      };
    }
    function getLightningElementPrototypeRestrictionsDescriptors(proto) {
      assertNotProd(); // this method should never leak to prod
      var originalDispatchEvent = proto.dispatchEvent;
      return {
        dispatchEvent: generateDataDescriptor({
          value: function value(event) {
            var vm = getAssociatedVM(this);
            if (!isNull(event) && isObject(event)) {
              var type = event.type;
              if (!/^[a-z][a-z0-9_]*$/.test(type)) {
                logError("Invalid event type \"".concat(type, "\" dispatched in element ").concat(getComponentTag(vm), ".") + " Event name must start with a lowercase letter and followed only lowercase" + " letters, numbers, and underscores", vm);
              }
            }
            // Typescript does not like it when you treat the `arguments` object as an array
            // @ts-ignore type-mismatch
            return originalDispatchEvent.apply(this, arguments);
          }
        })
      };
    }
    // This routine will prevent access to certain properties on a shadow root instance to guarantee
    // that all components will work fine in IE11 and other browsers without shadow dom support.
    function patchShadowRootWithRestrictions(sr) {
      defineProperties(sr, getShadowRootRestrictionsDescriptors(sr));
    }
    function patchCustomElementWithRestrictions(elm) {
      var restrictionsDescriptors = getCustomElementRestrictionsDescriptors(elm);
      var elmProto = getPrototypeOf$1(elm);
      setPrototypeOf(elm, create(elmProto, restrictionsDescriptors));
    }
    function patchLightningElementPrototypeWithRestrictions(proto) {
      defineProperties(proto, getLightningElementPrototypeRestrictionsDescriptors(proto));
    }
    function updateComponentValue(vm, key, newValue) {
      var cmpFields = vm.cmpFields;
      if (newValue !== cmpFields[key]) {
        cmpFields[key] = newValue;
        componentValueMutated(vm, key);
      }
    }

    /**
     * Copyright (C) 2017 salesforce.com, inc.
     */
    var isArray = Array.isArray;
    var ObjectDotPrototype = Object.prototype,
      _getPrototypeOf = Object.getPrototypeOf,
      ObjectCreate = Object.create,
      ObjectDefineProperty = Object.defineProperty,
      _isExtensible = Object.isExtensible,
      _getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,
      getOwnPropertyNames = Object.getOwnPropertyNames,
      getOwnPropertySymbols = Object.getOwnPropertySymbols,
      _preventExtensions = Object.preventExtensions,
      hasOwnProperty = Object.hasOwnProperty;
    var _Array$prototype2 = Array.prototype,
      ArrayPush = _Array$prototype2.push,
      ArrayConcat = _Array$prototype2.concat;
    var OtS = {}.toString;
    function toString(obj) {
      if (obj && obj.toString) {
        return obj.toString();
      } else if (_typeof(obj) === 'object') {
        return OtS.call(obj);
      } else {
        return obj + '';
      }
    }
    function isUndefined(obj) {
      return obj === undefined;
    }
    function isFunction(obj) {
      return typeof obj === 'function';
    }
    var proxyToValueMap = new WeakMap();
    function registerProxy(proxy, value) {
      proxyToValueMap.set(proxy, value);
    }
    var unwrap$1 = function unwrap$1(replicaOrAny) {
      return proxyToValueMap.get(replicaOrAny) || replicaOrAny;
    };
    var BaseProxyHandler = /*#__PURE__*/function () {
      function BaseProxyHandler(membrane, value) {
        _classCallCheck(this, BaseProxyHandler);
        this.originalTarget = value;
        this.membrane = membrane;
      }
      // Shared utility methods
      _createClass(BaseProxyHandler, [{
        key: "wrapDescriptor",
        value: function wrapDescriptor(descriptor) {
          if (hasOwnProperty.call(descriptor, 'value')) {
            descriptor.value = this.wrapValue(descriptor.value);
          } else {
            var originalSet = descriptor.set,
              originalGet = descriptor.get;
            if (!isUndefined(originalGet)) {
              descriptor.get = this.wrapGetter(originalGet);
            }
            if (!isUndefined(originalSet)) {
              descriptor.set = this.wrapSetter(originalSet);
            }
          }
          return descriptor;
        }
      }, {
        key: "copyDescriptorIntoShadowTarget",
        value: function copyDescriptorIntoShadowTarget(shadowTarget, key) {
          var originalTarget = this.originalTarget;
          // Note: a property might get defined multiple times in the shadowTarget
          //       but it will always be compatible with the previous descriptor
          //       to preserve the object invariants, which makes these lines safe.
          var originalDescriptor = _getOwnPropertyDescriptor(originalTarget, key);
          // TODO: it should be impossible for the originalDescriptor to ever be undefined, this `if` can be removed
          /* istanbul ignore else */
          if (!isUndefined(originalDescriptor)) {
            var wrappedDesc = this.wrapDescriptor(originalDescriptor);
            ObjectDefineProperty(shadowTarget, key, wrappedDesc);
          }
        }
      }, {
        key: "lockShadowTarget",
        value: function lockShadowTarget(shadowTarget) {
          var _this = this;
          var originalTarget = this.originalTarget;
          var targetKeys = ArrayConcat.call(getOwnPropertyNames(originalTarget), getOwnPropertySymbols(originalTarget));
          targetKeys.forEach(function (key) {
            _this.copyDescriptorIntoShadowTarget(shadowTarget, key);
          });
          var tagPropertyKey = this.membrane.tagPropertyKey;
          if (!isUndefined(tagPropertyKey) && !hasOwnProperty.call(shadowTarget, tagPropertyKey)) {
            ObjectDefineProperty(shadowTarget, tagPropertyKey, ObjectCreate(null));
          }
          _preventExtensions(shadowTarget);
        }
        // Shared Traps
        // TODO: apply() is never called
        /* istanbul ignore next */
      }, {
        key: "apply",
        value: function apply(shadowTarget, thisArg, argArray) {
          /* No op */
        }
        // TODO: construct() is never called
        /* istanbul ignore next */
      }, {
        key: "construct",
        value: function construct(shadowTarget, argArray, newTarget) {
          /* No op */
        }
      }, {
        key: "get",
        value: function get(shadowTarget, key) {
          var originalTarget = this.originalTarget,
            valueObserved = this.membrane.valueObserved;
          var value = originalTarget[key];
          valueObserved(originalTarget, key);
          return this.wrapValue(value);
        }
      }, {
        key: "has",
        value: function has(shadowTarget, key) {
          var originalTarget = this.originalTarget,
            _this$membrane = this.membrane,
            tagPropertyKey = _this$membrane.tagPropertyKey,
            valueObserved = _this$membrane.valueObserved;
          valueObserved(originalTarget, key);
          // since key is never going to be undefined, and tagPropertyKey might be undefined
          // we can simply compare them as the second part of the condition.
          return key in originalTarget || key === tagPropertyKey;
        }
      }, {
        key: "ownKeys",
        value: function ownKeys(shadowTarget) {
          var originalTarget = this.originalTarget,
            tagPropertyKey = this.membrane.tagPropertyKey;
          // if the membrane tag key exists and it is not in the original target, we add it to the keys.
          var keys = isUndefined(tagPropertyKey) || hasOwnProperty.call(originalTarget, tagPropertyKey) ? [] : [tagPropertyKey];
          // small perf optimization using push instead of concat to avoid creating an extra array
          ArrayPush.apply(keys, getOwnPropertyNames(originalTarget));
          ArrayPush.apply(keys, getOwnPropertySymbols(originalTarget));
          return keys;
        }
      }, {
        key: "isExtensible",
        value: function isExtensible(shadowTarget) {
          var originalTarget = this.originalTarget;
          // optimization to avoid attempting to lock down the shadowTarget multiple times
          if (!_isExtensible(shadowTarget)) {
            return false; // was already locked down
          }

          if (!_isExtensible(originalTarget)) {
            this.lockShadowTarget(shadowTarget);
            return false;
          }
          return true;
        }
      }, {
        key: "getPrototypeOf",
        value: function getPrototypeOf(shadowTarget) {
          var originalTarget = this.originalTarget;
          return _getPrototypeOf(originalTarget);
        }
      }, {
        key: "getOwnPropertyDescriptor",
        value: function getOwnPropertyDescriptor(shadowTarget, key) {
          var originalTarget = this.originalTarget,
            _this$membrane2 = this.membrane,
            valueObserved = _this$membrane2.valueObserved,
            tagPropertyKey = _this$membrane2.tagPropertyKey;
          // keys looked up via getOwnPropertyDescriptor need to be reactive
          valueObserved(originalTarget, key);
          var desc = _getOwnPropertyDescriptor(originalTarget, key);
          if (isUndefined(desc)) {
            if (key !== tagPropertyKey) {
              return undefined;
            }
            // if the key is the membrane tag key, and is not in the original target,
            // we produce a synthetic descriptor and install it on the shadow target
            desc = {
              value: undefined,
              writable: false,
              configurable: false,
              enumerable: false
            };
            ObjectDefineProperty(shadowTarget, tagPropertyKey, desc);
            return desc;
          }
          if (desc.configurable === false) {
            // updating the descriptor to non-configurable on the shadow
            this.copyDescriptorIntoShadowTarget(shadowTarget, key);
          }
          // Note: by accessing the descriptor, the key is marked as observed
          // but access to the value, setter or getter (if available) cannot observe
          // mutations, just like regular methods, in which case we just do nothing.
          return this.wrapDescriptor(desc);
        }
      }]);
      return BaseProxyHandler;
    }();
    var getterMap$1 = new WeakMap();
    var setterMap$1 = new WeakMap();
    var reverseGetterMap = new WeakMap();
    var reverseSetterMap = new WeakMap();
    var ReactiveProxyHandler = /*#__PURE__*/function (_BaseProxyHandler) {
      _inherits(ReactiveProxyHandler, _BaseProxyHandler);
      var _super = _createSuper(ReactiveProxyHandler);
      function ReactiveProxyHandler() {
        _classCallCheck(this, ReactiveProxyHandler);
        return _super.apply(this, arguments);
      }
      _createClass(ReactiveProxyHandler, [{
        key: "wrapValue",
        value: function wrapValue(value) {
          return this.membrane.getProxy(value);
        }
      }, {
        key: "wrapGetter",
        value: function wrapGetter(originalGet) {
          var wrappedGetter = getterMap$1.get(originalGet);
          if (!isUndefined(wrappedGetter)) {
            return wrappedGetter;
          }
          var handler = this;
          var get = function get() {
            // invoking the original getter with the original target
            return handler.wrapValue(originalGet.call(unwrap$1(this)));
          };
          getterMap$1.set(originalGet, get);
          reverseGetterMap.set(get, originalGet);
          return get;
        }
      }, {
        key: "wrapSetter",
        value: function wrapSetter(originalSet) {
          var wrappedSetter = setterMap$1.get(originalSet);
          if (!isUndefined(wrappedSetter)) {
            return wrappedSetter;
          }
          var set = function set(v) {
            // invoking the original setter with the original target
            originalSet.call(unwrap$1(this), unwrap$1(v));
          };
          setterMap$1.set(originalSet, set);
          reverseSetterMap.set(set, originalSet);
          return set;
        }
      }, {
        key: "unwrapDescriptor",
        value: function unwrapDescriptor(descriptor) {
          if (hasOwnProperty.call(descriptor, 'value')) {
            // dealing with a data descriptor
            descriptor.value = unwrap$1(descriptor.value);
          } else {
            var set = descriptor.set,
              get = descriptor.get;
            if (!isUndefined(get)) {
              descriptor.get = this.unwrapGetter(get);
            }
            if (!isUndefined(set)) {
              descriptor.set = this.unwrapSetter(set);
            }
          }
          return descriptor;
        }
      }, {
        key: "unwrapGetter",
        value: function unwrapGetter(redGet) {
          var reverseGetter = reverseGetterMap.get(redGet);
          if (!isUndefined(reverseGetter)) {
            return reverseGetter;
          }
          var handler = this;
          var get = function get() {
            // invoking the red getter with the proxy of this
            return unwrap$1(redGet.call(handler.wrapValue(this)));
          };
          getterMap$1.set(get, redGet);
          reverseGetterMap.set(redGet, get);
          return get;
        }
      }, {
        key: "unwrapSetter",
        value: function unwrapSetter(redSet) {
          var reverseSetter = reverseSetterMap.get(redSet);
          if (!isUndefined(reverseSetter)) {
            return reverseSetter;
          }
          var handler = this;
          var set = function set(v) {
            // invoking the red setter with the proxy of this
            redSet.call(handler.wrapValue(this), handler.wrapValue(v));
          };
          setterMap$1.set(set, redSet);
          reverseSetterMap.set(redSet, set);
          return set;
        }
      }, {
        key: "set",
        value: function set(shadowTarget, key, value) {
          var originalTarget = this.originalTarget,
            valueMutated = this.membrane.valueMutated;
          var oldValue = originalTarget[key];
          if (oldValue !== value) {
            originalTarget[key] = value;
            valueMutated(originalTarget, key);
          } else if (key === 'length' && isArray(originalTarget)) {
            // fix for issue #236: push will add the new index, and by the time length
            // is updated, the internal length is already equal to the new length value
            // therefore, the oldValue is equal to the value. This is the forking logic
            // to support this use case.
            valueMutated(originalTarget, key);
          }
          return true;
        }
      }, {
        key: "deleteProperty",
        value: function deleteProperty(shadowTarget, key) {
          var originalTarget = this.originalTarget,
            valueMutated = this.membrane.valueMutated;
          delete originalTarget[key];
          valueMutated(originalTarget, key);
          return true;
        }
      }, {
        key: "setPrototypeOf",
        value: function setPrototypeOf(shadowTarget, prototype) {
          /* istanbul ignore else */
          if (process.env.NODE_ENV !== 'production') {
            throw new Error("Invalid setPrototypeOf invocation for reactive proxy ".concat(toString(this.originalTarget), ". Prototype of reactive objects cannot be changed."));
          }
        }
      }, {
        key: "preventExtensions",
        value: function preventExtensions(shadowTarget) {
          if (_isExtensible(shadowTarget)) {
            var originalTarget = this.originalTarget;
            _preventExtensions(originalTarget);
            // if the originalTarget is a proxy itself, it might reject
            // the preventExtension call, in which case we should not attempt to lock down
            // the shadow target.
            // TODO: It should not actually be possible to reach this `if` statement.
            // If a proxy rejects extensions, then calling preventExtensions will throw an error:
            // https://codepen.io/nolanlawson-the-selector/pen/QWMOjbY
            /* istanbul ignore if */
            if (_isExtensible(originalTarget)) {
              return false;
            }
            this.lockShadowTarget(shadowTarget);
          }
          return true;
        }
      }, {
        key: "defineProperty",
        value: function defineProperty(shadowTarget, key, descriptor) {
          var originalTarget = this.originalTarget,
            _this$membrane3 = this.membrane,
            valueMutated = _this$membrane3.valueMutated,
            tagPropertyKey = _this$membrane3.tagPropertyKey;
          if (key === tagPropertyKey && !hasOwnProperty.call(originalTarget, key)) {
            // To avoid leaking the membrane tag property into the original target, we must
            // be sure that the original target doesn't have yet.
            // NOTE: we do not return false here because Object.freeze and equivalent operations
            // will attempt to set the descriptor to the same value, and expect no to throw. This
            // is an small compromise for the sake of not having to diff the descriptors.
            return true;
          }
          ObjectDefineProperty(originalTarget, key, this.unwrapDescriptor(descriptor));
          // intentionally testing if false since it could be undefined as well
          if (descriptor.configurable === false) {
            this.copyDescriptorIntoShadowTarget(shadowTarget, key);
          }
          valueMutated(originalTarget, key);
          return true;
        }
      }]);
      return ReactiveProxyHandler;
    }(BaseProxyHandler);
    var getterMap = new WeakMap();
    var setterMap = new WeakMap();
    var ReadOnlyHandler = /*#__PURE__*/function (_BaseProxyHandler2) {
      _inherits(ReadOnlyHandler, _BaseProxyHandler2);
      var _super2 = _createSuper(ReadOnlyHandler);
      function ReadOnlyHandler() {
        _classCallCheck(this, ReadOnlyHandler);
        return _super2.apply(this, arguments);
      }
      _createClass(ReadOnlyHandler, [{
        key: "wrapValue",
        value: function wrapValue(value) {
          return this.membrane.getReadOnlyProxy(value);
        }
      }, {
        key: "wrapGetter",
        value: function wrapGetter(originalGet) {
          var wrappedGetter = getterMap.get(originalGet);
          if (!isUndefined(wrappedGetter)) {
            return wrappedGetter;
          }
          var handler = this;
          var get = function get() {
            // invoking the original getter with the original target
            return handler.wrapValue(originalGet.call(unwrap$1(this)));
          };
          getterMap.set(originalGet, get);
          return get;
        }
      }, {
        key: "wrapSetter",
        value: function wrapSetter(originalSet) {
          var wrappedSetter = setterMap.get(originalSet);
          if (!isUndefined(wrappedSetter)) {
            return wrappedSetter;
          }
          var handler = this;
          var set = function set(v) {
            /* istanbul ignore else */
            if (process.env.NODE_ENV !== 'production') {
              var originalTarget = handler.originalTarget;
              throw new Error("Invalid mutation: Cannot invoke a setter on \"".concat(originalTarget, "\". \"").concat(originalTarget, "\" is read-only."));
            }
          };
          setterMap.set(originalSet, set);
          return set;
        }
      }, {
        key: "set",
        value: function set(shadowTarget, key, value) {
          /* istanbul ignore else */
          if (process.env.NODE_ENV !== 'production') {
            var originalTarget = this.originalTarget;
            var msg = isArray(originalTarget) ? "Invalid mutation: Cannot mutate array at index ".concat(key.toString(), ". Array is read-only.") : "Invalid mutation: Cannot set \"".concat(key.toString(), "\" on \"").concat(originalTarget, "\". \"").concat(originalTarget, "\" is read-only.");
            throw new Error(msg);
          }
          /* istanbul ignore next */
          return false;
        }
      }, {
        key: "deleteProperty",
        value: function deleteProperty(shadowTarget, key) {
          /* istanbul ignore else */
          if (process.env.NODE_ENV !== 'production') {
            var originalTarget = this.originalTarget;
            throw new Error("Invalid mutation: Cannot delete \"".concat(key.toString(), "\" on \"").concat(originalTarget, "\". \"").concat(originalTarget, "\" is read-only."));
          }
          /* istanbul ignore next */
          return false;
        }
      }, {
        key: "setPrototypeOf",
        value: function setPrototypeOf(shadowTarget, prototype) {
          /* istanbul ignore else */
          if (process.env.NODE_ENV !== 'production') {
            var originalTarget = this.originalTarget;
            throw new Error("Invalid prototype mutation: Cannot set prototype on \"".concat(originalTarget, "\". \"").concat(originalTarget, "\" prototype is read-only."));
          }
        }
      }, {
        key: "preventExtensions",
        value: function preventExtensions(shadowTarget) {
          /* istanbul ignore else */
          if (process.env.NODE_ENV !== 'production') {
            var originalTarget = this.originalTarget;
            throw new Error("Invalid mutation: Cannot preventExtensions on ".concat(originalTarget, "\". \"").concat(originalTarget, " is read-only."));
          }
          /* istanbul ignore next */
          return false;
        }
      }, {
        key: "defineProperty",
        value: function defineProperty(shadowTarget, key, descriptor) {
          /* istanbul ignore else */
          if (process.env.NODE_ENV !== 'production') {
            var originalTarget = this.originalTarget;
            throw new Error("Invalid mutation: Cannot defineProperty \"".concat(key.toString(), "\" on \"").concat(originalTarget, "\". \"").concat(originalTarget, "\" is read-only."));
          }
          /* istanbul ignore next */
          return false;
        }
      }]);
      return ReadOnlyHandler;
    }(BaseProxyHandler);
    function extract(objectOrArray) {
      if (isArray(objectOrArray)) {
        return objectOrArray.map(function (item) {
          var original = unwrap$1(item);
          if (original !== item) {
            return extract(original);
          }
          return item;
        });
      }
      var obj = ObjectCreate(_getPrototypeOf(objectOrArray));
      var names = getOwnPropertyNames(objectOrArray);
      return ArrayConcat.call(names, getOwnPropertySymbols(objectOrArray)).reduce(function (seed, key) {
        var item = objectOrArray[key];
        var original = unwrap$1(item);
        if (original !== item) {
          seed[key] = extract(original);
        } else {
          seed[key] = item;
        }
        return seed;
      }, obj);
    }
    var formatter = {
      header: function header(plainOrProxy) {
        var originalTarget = unwrap$1(plainOrProxy);
        // if originalTarget is falsy or not unwrappable, exit
        if (!originalTarget || originalTarget === plainOrProxy) {
          return null;
        }
        var obj = extract(plainOrProxy);
        return ['object', {
          object: obj
        }];
      },
      hasBody: function hasBody() {
        return false;
      },
      body: function body() {
        return null;
      }
    };
    // Inspired from paulmillr/es6-shim
    // https://github.com/paulmillr/es6-shim/blob/master/es6-shim.js#L176-L185
    /* istanbul ignore next */
    function getGlobal() {
      // the only reliable means to get the global object is `Function('return this')()`
      // However, this causes CSP violations in Chrome apps.
      if (typeof globalThis !== 'undefined') {
        return globalThis;
      }
      if (typeof self !== 'undefined') {
        return self;
      }
      if (typeof window !== 'undefined') {
        return window;
      }
      if (typeof global !== 'undefined') {
        return global;
      }
      // Gracefully degrade if not able to locate the global object
      return {};
    }
    function init$1() {
      /* istanbul ignore if */
      if (process.env.NODE_ENV === 'production') {
        // this method should never leak to prod
        throw new ReferenceError();
      }
      var global = getGlobal();
      // Custom Formatter for Dev Tools. To enable this, open Chrome Dev Tools
      //  - Go to Settings,
      //  - Under console, select "Enable custom formatters"
      // For more information, https://docs.google.com/document/d/1FTascZXT9cxfetuPRT2eXPQKXui4nWFivUnS_335T3U/preview
      var devtoolsFormatters = global.devtoolsFormatters || [];
      ArrayPush.call(devtoolsFormatters, formatter);
      global.devtoolsFormatters = devtoolsFormatters;
    }

    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      init$1();
    }
    function defaultValueIsObservable(value) {
      // intentionally checking for null
      if (value === null) {
        return false;
      }
      // treat all non-object types, including undefined, as non-observable values
      if (_typeof(value) !== 'object') {
        return false;
      }
      if (isArray(value)) {
        return true;
      }
      var proto = _getPrototypeOf(value);
      return proto === ObjectDotPrototype || proto === null || _getPrototypeOf(proto) === null;
    }
    var defaultValueObserved = function defaultValueObserved(obj, key) {
      /* do nothing */
    };
    var defaultValueMutated = function defaultValueMutated(obj, key) {
      /* do nothing */
    };
    function createShadowTarget(value) {
      return isArray(value) ? [] : {};
    }
    var ObservableMembrane = /*#__PURE__*/function () {
      function ObservableMembrane() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        _classCallCheck(this, ObservableMembrane);
        this.readOnlyObjectGraph = new WeakMap();
        this.reactiveObjectGraph = new WeakMap();
        var valueMutated = options.valueMutated,
          valueObserved = options.valueObserved,
          valueIsObservable = options.valueIsObservable,
          tagPropertyKey = options.tagPropertyKey;
        this.valueMutated = isFunction(valueMutated) ? valueMutated : defaultValueMutated;
        this.valueObserved = isFunction(valueObserved) ? valueObserved : defaultValueObserved;
        this.valueIsObservable = isFunction(valueIsObservable) ? valueIsObservable : defaultValueIsObservable;
        this.tagPropertyKey = tagPropertyKey;
      }
      _createClass(ObservableMembrane, [{
        key: "getProxy",
        value: function getProxy(value) {
          var unwrappedValue = unwrap$1(value);
          if (this.valueIsObservable(unwrappedValue)) {
            // When trying to extract the writable version of a readonly we return the readonly.
            if (this.readOnlyObjectGraph.get(unwrappedValue) === value) {
              return value;
            }
            return this.getReactiveHandler(unwrappedValue);
          }
          return unwrappedValue;
        }
      }, {
        key: "getReadOnlyProxy",
        value: function getReadOnlyProxy(value) {
          value = unwrap$1(value);
          if (this.valueIsObservable(value)) {
            return this.getReadOnlyHandler(value);
          }
          return value;
        }
      }, {
        key: "unwrapProxy",
        value: function unwrapProxy(p) {
          return unwrap$1(p);
        }
      }, {
        key: "getReactiveHandler",
        value: function getReactiveHandler(value) {
          var proxy = this.reactiveObjectGraph.get(value);
          if (isUndefined(proxy)) {
            // caching the proxy after the first time it is accessed
            var handler = new ReactiveProxyHandler(this, value);
            proxy = new Proxy(createShadowTarget(value), handler);
            registerProxy(proxy, value);
            this.reactiveObjectGraph.set(value, proxy);
          }
          return proxy;
        }
      }, {
        key: "getReadOnlyHandler",
        value: function getReadOnlyHandler(value) {
          var proxy = this.readOnlyObjectGraph.get(value);
          if (isUndefined(proxy)) {
            // caching the proxy after the first time it is accessed
            var handler = new ReadOnlyHandler(this, value);
            proxy = new Proxy(createShadowTarget(value), handler);
            registerProxy(proxy, value);
            this.readOnlyObjectGraph.set(value, proxy);
          }
          return proxy;
        }
      }]);
      return ObservableMembrane;
    }();
    /** version: 2.0.0 */
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var lockerLivePropertyKey = Symbol.for('@@lockerLiveValue');
    var reactiveMembrane = new ObservableMembrane({
      valueObserved: valueObserved,
      valueMutated: valueMutated,
      tagPropertyKey: lockerLivePropertyKey
    });
    /**
     * EXPERIMENTAL: This function implements an unwrap mechanism that
     * works for observable membrane objects. This API is subject to
     * change or being removed.
     */
    function unwrap(value) {
      // On the server side, we don't need mutation tracking. Skipping it improves performance.
      return reactiveMembrane.unwrapProxy(value);
    }
    function getReadOnlyProxy(value) {
      // We must return a frozen wrapper around the value, so that child components cannot mutate properties passed to
      // them from their parents. This applies to both the client and server.
      return reactiveMembrane.getReadOnlyProxy(value);
    }
    function getReactiveProxy(value) {
      // On the server side, we don't need mutation tracking. Skipping it improves performance.
      return reactiveMembrane.getProxy(value);
    }
    // Making the component instance a live value when using Locker to support expandos.
    function markLockerLiveObject(obj) {
      // On the server side, we don't need mutation tracking. Skipping it improves performance.
      {
        obj[lockerLivePropertyKey] = undefined;
      }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * This operation is called with a descriptor of an standard html property
     * that a Custom Element can support (including AOM properties), which
     * determines what kind of capabilities the Base Lightning Element should support. When producing the new descriptors
     * for the Base Lightning Element, it also include the reactivity bit, so the standard property is reactive.
     */
    function createBridgeToElementDescriptor(propName, descriptor) {
      var _get = descriptor.get,
        _set = descriptor.set,
        enumerable = descriptor.enumerable,
        configurable = descriptor.configurable;
      if (!isFunction$1(_get)) {
        throw new TypeError("Detected invalid public property descriptor for HTMLElement.prototype.".concat(propName, " definition. Missing the standard getter."));
      }
      if (!isFunction$1(_set)) {
        throw new TypeError("Detected invalid public property descriptor for HTMLElement.prototype.".concat(propName, " definition. Missing the standard setter."));
      }
      return {
        enumerable: enumerable,
        configurable: configurable,
        get: function get() {
          var vm = getAssociatedVM(this);
          if (isBeingConstructed(vm)) {
            if (process.env.NODE_ENV !== 'production') {
              logError("The value of property `".concat(propName, "` can't be read from the constructor because the owner component hasn't set the value yet. Instead, use the constructor to set a default value for the property."), vm);
            }
            return;
          }
          componentValueObserved(vm, propName);
          return _get.call(vm.elm);
        },
        set: function set(newValue) {
          var vm = getAssociatedVM(this);
          if (process.env.NODE_ENV !== 'production') {
            var _vmBeingRendered = getVMBeingRendered();
            if (isInvokingRender) {
              logError("".concat(_vmBeingRendered, ".render() method has side effects on the state of ").concat(vm, ".").concat(propName));
            }
            if (isUpdatingTemplate) {
              logError("When updating the template of ".concat(_vmBeingRendered, ", one of the accessors used by the template has side effects on the state of ").concat(vm, ".").concat(propName));
            }
            if (isBeingConstructed(vm)) {
              logError("Failed to construct '".concat(getComponentTag(vm), "': The result must not have attributes."));
            }
            if (isObject(newValue) && !isNull(newValue)) {
              logError("Invalid value \"".concat(newValue, "\" for \"").concat(propName, "\" of ").concat(vm, ". Value cannot be an object, must be a primitive value."));
            }
          }
          updateComponentValue(vm, propName, newValue);
          return _set.call(vm.elm, newValue);
        }
      };
    }
    var refsCache = new WeakMap();
    /**
     * This class is the base class for any LWC element.
     * Some elements directly extends this class, others implement it via inheritance.
     **/
    // @ts-ignore
    var LightningElement = function LightningElement() {
      // This should be as performant as possible, while any initialization should be done lazily
      if (isNull(vmBeingConstructed)) {
        // Thrown when doing something like `new LightningElement()` or
        // `class Foo extends LightningElement {}; new Foo()`
        throw new TypeError('Illegal constructor');
      }
      var vm = vmBeingConstructed;
      var def = vm.def,
        elm = vm.elm;
      var bridge = def.bridge;
      if (process.env.NODE_ENV !== 'production') {
        var assertInstanceOfHTMLElement = vm.renderer.assertInstanceOfHTMLElement;
        assertInstanceOfHTMLElement(vm.elm, "Component creation requires a DOM element to be associated to ".concat(vm, "."));
      }
      var component = this;
      setPrototypeOf(elm, bridge.prototype);
      vm.component = this;
      // Locker hooks assignment. When the LWC engine run with Locker, Locker intercepts all the new
      // component creation and passes hooks to instrument all the component interactions with the
      // engine. We are intentionally hiding this argument from the formal API of LightningElement
      // because we don't want folks to know about it just yet.
      if (arguments.length === 1) {
        var _arguments$ = arguments[0],
          _callHook = _arguments$.callHook,
          _setHook = _arguments$.setHook,
          _getHook = _arguments$.getHook;
        vm.callHook = _callHook;
        vm.setHook = _setHook;
        vm.getHook = _getHook;
      }
      markLockerLiveObject(this);
      // Linking elm, shadow root and component with the VM.
      associateVM(component, vm);
      associateVM(elm, vm);
      if (vm.renderMode === 1 /* RenderMode.Shadow */) {
        vm.renderRoot = doAttachShadow(vm);
      } else {
        vm.renderRoot = elm;
      }
      // Adding extra guard rails in DEV mode.
      if (process.env.NODE_ENV !== 'production') {
        patchCustomElementWithRestrictions(elm);
      }
      return this;
    };
    function doAttachShadow(vm) {
      var _attachShadow;
      var elm = vm.elm,
        mode = vm.mode,
        shadowMode = vm.shadowMode,
        ctor = vm.def.ctor,
        attachShadow = vm.renderer.attachShadow;
      var shadowRoot = attachShadow(elm, (_attachShadow = {}, _defineProperty(_attachShadow, KEY__SYNTHETIC_MODE, shadowMode === 1), _defineProperty(_attachShadow, "delegatesFocus", Boolean(ctor.delegatesFocus)), _defineProperty(_attachShadow, "mode", mode), _attachShadow));
      vm.shadowRoot = shadowRoot;
      associateVM(shadowRoot, vm);
      if (process.env.NODE_ENV !== 'production') {
        patchShadowRootWithRestrictions(shadowRoot);
      }
      return shadowRoot;
    }
    function warnIfInvokedDuringConstruction(vm, methodOrPropName) {
      if (isBeingConstructed(vm)) {
        logError("this.".concat(methodOrPropName, " should not be called during the construction of the custom element for ").concat(getComponentTag(vm), " because the element is not yet in the DOM or has no children yet."));
      }
    }
    // @ts-ignore
    LightningElement.prototype = {
      constructor: LightningElement,
      dispatchEvent: function dispatchEvent(event) {
        var vm = getAssociatedVM(this);
        var elm = vm.elm,
          dispatchEvent = vm.renderer.dispatchEvent;
        return dispatchEvent(elm, event);
      },
      addEventListener: function addEventListener(type, listener, options) {
        var vm = getAssociatedVM(this);
        var elm = vm.elm,
          addEventListener = vm.renderer.addEventListener;
        if (process.env.NODE_ENV !== 'production') {
          var _vmBeingRendered2 = getVMBeingRendered();
          if (isInvokingRender) {
            logError("".concat(_vmBeingRendered2, ".render() method has side effects on the state of ").concat(vm, " by adding an event listener for \"").concat(type, "\"."));
          }
          if (isUpdatingTemplate) {
            logError("Updating the template of ".concat(_vmBeingRendered2, " has side effects on the state of ").concat(vm, " by adding an event listener for \"").concat(type, "\"."));
          }
          if (!isFunction$1(listener)) {
            logError("Invalid second argument for this.addEventListener() in ".concat(vm, " for event \"").concat(type, "\". Expected an EventListener but received ").concat(listener, "."));
          }
        }
        var wrappedListener = getWrappedComponentsListener(vm, listener);
        addEventListener(elm, type, wrappedListener, options);
      },
      removeEventListener: function removeEventListener(type, listener, options) {
        var vm = getAssociatedVM(this);
        var elm = vm.elm,
          removeEventListener = vm.renderer.removeEventListener;
        var wrappedListener = getWrappedComponentsListener(vm, listener);
        removeEventListener(elm, type, wrappedListener, options);
      },
      hasAttribute: function hasAttribute(name) {
        var vm = getAssociatedVM(this);
        var elm = vm.elm,
          getAttribute = vm.renderer.getAttribute;
        return !isNull(getAttribute(elm, name));
      },
      hasAttributeNS: function hasAttributeNS(namespace, name) {
        var vm = getAssociatedVM(this);
        var elm = vm.elm,
          getAttribute = vm.renderer.getAttribute;
        return !isNull(getAttribute(elm, name, namespace));
      },
      removeAttribute: function removeAttribute(name) {
        var vm = getAssociatedVM(this);
        var elm = vm.elm,
          removeAttribute = vm.renderer.removeAttribute;
        unlockAttribute(elm, name);
        removeAttribute(elm, name);
        lockAttribute();
      },
      removeAttributeNS: function removeAttributeNS(namespace, name) {
        var _getAssociatedVM = getAssociatedVM(this),
          elm = _getAssociatedVM.elm,
          removeAttribute = _getAssociatedVM.renderer.removeAttribute;
        unlockAttribute(elm, name);
        removeAttribute(elm, name, namespace);
        lockAttribute();
      },
      getAttribute: function getAttribute(name) {
        var vm = getAssociatedVM(this);
        var elm = vm.elm;
        var getAttribute = vm.renderer.getAttribute;
        return getAttribute(elm, name);
      },
      getAttributeNS: function getAttributeNS(namespace, name) {
        var vm = getAssociatedVM(this);
        var elm = vm.elm;
        var getAttribute = vm.renderer.getAttribute;
        return getAttribute(elm, name, namespace);
      },
      setAttribute: function setAttribute(name, value) {
        var vm = getAssociatedVM(this);
        var elm = vm.elm,
          setAttribute = vm.renderer.setAttribute;
        if (process.env.NODE_ENV !== 'production') {
          if (isBeingConstructed(vm)) {
            logError("Failed to construct '".concat(getComponentTag(vm), "': The result must not have attributes."));
          }
        }
        unlockAttribute(elm, name);
        setAttribute(elm, name, value);
        lockAttribute();
      },
      setAttributeNS: function setAttributeNS(namespace, name, value) {
        var vm = getAssociatedVM(this);
        var elm = vm.elm,
          setAttribute = vm.renderer.setAttribute;
        if (process.env.NODE_ENV !== 'production') {
          if (isBeingConstructed(vm)) {
            logError("Failed to construct '".concat(getComponentTag(vm), "': The result must not have attributes."));
          }
        }
        unlockAttribute(elm, name);
        setAttribute(elm, name, value, namespace);
        lockAttribute();
      },
      getBoundingClientRect: function getBoundingClientRect() {
        var vm = getAssociatedVM(this);
        var elm = vm.elm,
          getBoundingClientRect = vm.renderer.getBoundingClientRect;
        if (process.env.NODE_ENV !== 'production') {
          warnIfInvokedDuringConstruction(vm, 'getBoundingClientRect()');
        }
        return getBoundingClientRect(elm);
      },
      get isConnected() {
        var vm = getAssociatedVM(this);
        var elm = vm.elm,
          isConnected = vm.renderer.isConnected;
        return isConnected(elm);
      },
      get classList() {
        var vm = getAssociatedVM(this);
        var elm = vm.elm,
          getClassList = vm.renderer.getClassList;
        if (process.env.NODE_ENV !== 'production') {
          if (isBeingConstructed(vm)) {
            logError("Failed to construct ".concat(vm, ": The result must not have attributes. Adding or tampering with classname in constructor is not allowed in a web component, use connectedCallback() instead."));
          }
        }
        return getClassList(elm);
      },
      get template() {
        var vm = getAssociatedVM(this);
        if (process.env.NODE_ENV !== 'production') {
          if (vm.renderMode === 0 /* RenderMode.Light */) {
            logError('`this.template` returns null for light DOM components. Since there is no shadow, the rendered content can be accessed via `this` itself. e.g. instead of `this.template.querySelector`, use `this.querySelector`.');
          }
        }
        return vm.shadowRoot;
      },
      get refs() {
        var vm = getAssociatedVM(this);
        if (isUpdatingTemplate) {
          if (process.env.NODE_ENV !== 'production') {
            logError("this.refs should not be called while ".concat(getComponentTag(vm), " is rendering. Use this.refs only when the DOM is stable, e.g. in renderedCallback()."));
          }
          // If the template is in the process of being updated, then we don't want to go through the normal
          // process of returning the refs and caching them, because the state of the refs is unstable.
          // This can happen if e.g. a template contains `<div class={foo}></div>` and `foo` is computed
          // based on `this.refs.bar`.
          return;
        }
        if (process.env.NODE_ENV !== 'production') {
          warnIfInvokedDuringConstruction(vm, 'refs');
        }
        var refVNodes = vm.refVNodes,
          cmpTemplate = vm.cmpTemplate;
        // If the `cmpTemplate` is null, that means that the template has not been rendered yet. Most likely this occurs
        // if `this.refs` is called during the `connectedCallback` phase. The DOM elements have not been rendered yet,
        // so log a warning. Note we also check `isBeingConstructed()` to avoid a double warning (due to
        // `warnIfInvokedDuringConstruction` above).
        if (process.env.NODE_ENV !== 'production' && isNull(cmpTemplate) && !isBeingConstructed(vm)) {
          logError("this.refs is undefined for ".concat(getComponentTag(vm), ". This is either because the attached template has no \"lwc:ref\" directive, or this.refs was ") + "invoked before renderedCallback(). Use this.refs only when the referenced HTML elements have " + "been rendered to the DOM, such as within renderedCallback() or disconnectedCallback().");
        }
        // For backwards compatibility with component written before template refs
        // were introduced, we return undefined if the template has no refs defined
        // anywhere. This fixes components that may want to add an expando called `refs`
        // and are checking if it exists with `if (this.refs)`  before adding it.
        // Note we use a null refVNodes to indicate that the template has no refs defined.
        if (isNull(refVNodes)) {
          return;
        }
        // The refNodes can be cached based on the refVNodes, since the refVNodes
        // are recreated from scratch every time the template is rendered.
        // This happens with `vm.refVNodes = null` in `template.ts` in `@lwc/engine-core`.
        var refs = refsCache.get(refVNodes);
        if (isUndefined$1(refs)) {
          refs = create(null);
          var _iterator4 = _createForOfIteratorHelper(keys(refVNodes)),
            _step4;
          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var key = _step4.value;
              refs[key] = refVNodes[key].elm;
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }
          freeze(refs);
          refsCache.set(refVNodes, refs);
        }
        return refs;
      },
      // For backwards compat, we allow component authors to set `refs` as an expando
      set refs(value) {
        defineProperty(this, 'refs', {
          configurable: true,
          enumerable: true,
          writable: true,
          value: value
        });
      },
      get shadowRoot() {
        // From within the component instance, the shadowRoot is always reported as "closed".
        // Authors should rely on this.template instead.
        return null;
      },
      get children() {
        var vm = getAssociatedVM(this);
        var renderer = vm.renderer;
        if (process.env.NODE_ENV !== 'production') {
          warnIfInvokedDuringConstruction(vm, 'children');
        }
        return renderer.getChildren(vm.elm);
      },
      get childNodes() {
        var vm = getAssociatedVM(this);
        var renderer = vm.renderer;
        if (process.env.NODE_ENV !== 'production') {
          warnIfInvokedDuringConstruction(vm, 'childNodes');
        }
        return renderer.getChildNodes(vm.elm);
      },
      get firstChild() {
        var vm = getAssociatedVM(this);
        var renderer = vm.renderer;
        if (process.env.NODE_ENV !== 'production') {
          warnIfInvokedDuringConstruction(vm, 'firstChild');
        }
        return renderer.getFirstChild(vm.elm);
      },
      get firstElementChild() {
        var vm = getAssociatedVM(this);
        var renderer = vm.renderer;
        if (process.env.NODE_ENV !== 'production') {
          warnIfInvokedDuringConstruction(vm, 'firstElementChild');
        }
        return renderer.getFirstElementChild(vm.elm);
      },
      get lastChild() {
        var vm = getAssociatedVM(this);
        var renderer = vm.renderer;
        if (process.env.NODE_ENV !== 'production') {
          warnIfInvokedDuringConstruction(vm, 'lastChild');
        }
        return renderer.getLastChild(vm.elm);
      },
      get lastElementChild() {
        var vm = getAssociatedVM(this);
        var renderer = vm.renderer;
        if (process.env.NODE_ENV !== 'production') {
          warnIfInvokedDuringConstruction(vm, 'lastElementChild');
        }
        return renderer.getLastElementChild(vm.elm);
      },
      get ownerDocument() {
        var vm = getAssociatedVM(this);
        var renderer = vm.renderer;
        if (process.env.NODE_ENV !== 'production') {
          warnIfInvokedDuringConstruction(vm, 'ownerDocument');
        }
        return renderer.ownerDocument(vm.elm);
      },
      render: function render() {
        var vm = getAssociatedVM(this);
        return vm.def.template;
      },
      toString: function toString() {
        var vm = getAssociatedVM(this);
        return "[object ".concat(vm.def.name, "]");
      }
    };
    var queryAndChildGetterDescriptors = create(null);
    var queryMethods = ['getElementsByClassName', 'getElementsByTagName', 'querySelector', 'querySelectorAll'];
    // Generic passthrough for query APIs on HTMLElement to the relevant Renderer APIs
    var _loop = function _loop() {
      var queryMethod = _queryMethods[_i7];
      queryAndChildGetterDescriptors[queryMethod] = {
        value: function value(arg) {
          var vm = getAssociatedVM(this);
          var elm = vm.elm,
            renderer = vm.renderer;
          if (process.env.NODE_ENV !== 'production') {
            warnIfInvokedDuringConstruction(vm, "".concat(queryMethod, "()"));
          }
          return renderer[queryMethod](elm, arg);
        },
        configurable: true,
        enumerable: true,
        writable: true
      };
    };
    for (var _i7 = 0, _queryMethods = queryMethods; _i7 < _queryMethods.length; _i7++) {
      _loop();
    }
    defineProperties(LightningElement.prototype, queryAndChildGetterDescriptors);
    var lightningBasedDescriptors = create(null);
    for (var propName in HTMLElementOriginalDescriptors) {
      lightningBasedDescriptors[propName] = createBridgeToElementDescriptor(propName, HTMLElementOriginalDescriptors[propName]);
    }
    defineProperties(LightningElement.prototype, lightningBasedDescriptors);
    function applyAriaReflectionToLightningElement() {
      // If ARIA reflection is not applied globally to Element.prototype, or if we are running server-side,
      // apply it to LightningElement.prototype.
      // This allows `this.aria*` property accessors to work from inside a component, and to reflect `aria-*` attrs.
      applyAriaReflection(LightningElement.prototype);
    }
    if (lwcRuntimeFlags.DISABLE_ARIA_REFLECTION_POLYFILL) {
      applyAriaReflectionToLightningElement();
    }
    defineProperty(LightningElement, 'CustomElementConstructor', {
      get: function get() {
        // If required, a runtime-specific implementation must be defined.
        throw new ReferenceError('The current runtime does not support CustomElementConstructor.');
      },
      configurable: true
    });
    if (process.env.NODE_ENV !== 'production') {
      patchLightningElementPrototypeWithRestrictions(LightningElement.prototype);
    }
    function createObservedFieldPropertyDescriptor(key) {
      return {
        get: function get() {
          var vm = getAssociatedVM(this);
          componentValueObserved(vm, key);
          return vm.cmpFields[key];
        },
        set: function set(newValue) {
          var vm = getAssociatedVM(this);
          updateComponentValue(vm, key, newValue);
        },
        enumerable: true,
        configurable: true
      };
    }

    /*
     * Copyright (c) 2023, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var AdapterToTokenMap = new Map();
    function createContextProviderWithRegister(adapter, registerContextProvider) {
      var adapterContextToken = AdapterToTokenMap.get(adapter);
      if (!isUndefined$1(adapterContextToken)) {
        throw new Error("Adapter already has a context provider.");
      }
      adapterContextToken = guid();
      AdapterToTokenMap.set(adapter, adapterContextToken);
      var providers = new WeakSet();
      return function (elmOrComponent, options) {
        if (providers.has(elmOrComponent)) {
          throw new Error("Adapter was already installed on ".concat(elmOrComponent, "."));
        }
        providers.add(elmOrComponent);
        var consumerConnectedCallback = options.consumerConnectedCallback,
          consumerDisconnectedCallback = options.consumerDisconnectedCallback;
        registerContextProvider(elmOrComponent, adapterContextToken, function (subscriptionPayload) {
          var setNewContext = subscriptionPayload.setNewContext,
            setDisconnectedCallback = subscriptionPayload.setDisconnectedCallback;
          var consumer = {
            provide: function provide(newContext) {
              setNewContext(newContext);
            }
          };
          var disconnectCallback = function disconnectCallback() {
            if (!isUndefined$1(consumerDisconnectedCallback)) {
              consumerDisconnectedCallback(consumer);
            }
          };
          setDisconnectedCallback(disconnectCallback);
          consumerConnectedCallback(consumer);
        });
      };
    }
    function createContextWatcher(vm, wireDef, callbackWhenContextIsReady) {
      var adapter = wireDef.adapter;
      var adapterContextToken = AdapterToTokenMap.get(adapter);
      if (isUndefined$1(adapterContextToken)) {
        return; // no provider found, nothing to be done
      }

      var elm = vm.elm,
        _vm$context = vm.context,
        wiredConnecting = _vm$context.wiredConnecting,
        wiredDisconnecting = _vm$context.wiredDisconnecting,
        registerContextConsumer = vm.renderer.registerContextConsumer;
      // waiting for the component to be connected to formally request the context via the token
      ArrayPush$1.call(wiredConnecting, function () {
        // This will attempt to connect the current element with one of its anscestors
        // that can provide context for the given wire adapter. This relationship is
        // keyed on the secret & internal value of `adapterContextToken`, which is unique
        // to a given wire adapter.
        //
        // Depending on the runtime environment, this connection is made using either DOM
        // events (in the browser) or a custom traversal (on the server).
        registerContextConsumer(elm, adapterContextToken, {
          setNewContext: function setNewContext(newContext) {
            // eslint-disable-next-line @lwc/lwc-internal/no-invalid-todo
            // TODO: dev-mode validation of config based on the adapter.contextSchema
            callbackWhenContextIsReady(newContext);
          },
          setDisconnectedCallback: function setDisconnectedCallback(disconnectCallback) {
            // adds this callback into the disconnect bucket so it gets disconnected from parent
            // the the element hosting the wire is disconnected
            ArrayPush$1.call(wiredDisconnecting, disconnectCallback);
          }
        });
      });
    }

    /*
     * Copyright (c) 2023, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var DeprecatedWiredElementHost = '$$DeprecatedWiredElementHostKey$$';
    var DeprecatedWiredParamsMeta = '$$DeprecatedWiredParamsMetaKey$$';
    var WIRE_DEBUG_ENTRY = '@wire';
    var WireMetaMap = new Map();
    function createFieldDataCallback(vm, name) {
      return function (value) {
        updateComponentValue(vm, name, value);
      };
    }
    function createMethodDataCallback(vm, method) {
      return function (value) {
        // dispatching new value into the wired method
        runWithBoundaryProtection(vm, vm.owner, noop, function () {
          // job
          method.call(vm.component, value);
        }, noop);
      };
    }
    function createConfigWatcher(component, configCallback, callbackWhenConfigIsReady) {
      var hasPendingConfig = false;
      // creating the reactive observer for reactive params when needed
      var ro = createReactiveObserver(function () {
        if (hasPendingConfig === false) {
          hasPendingConfig = true;
          // collect new config in the micro-task
          Promise.resolve().then(function () {
            hasPendingConfig = false;
            // resetting current reactive params
            ro.reset();
            // dispatching a new config due to a change in the configuration
            computeConfigAndUpdate();
          });
        }
      });
      var computeConfigAndUpdate = function computeConfigAndUpdate() {
        var config;
        ro.observe(function () {
          return config = configCallback(component);
        });
        // eslint-disable-next-line @lwc/lwc-internal/no-invalid-todo
        // TODO: dev-mode validation of config based on the adapter.configSchema
        // @ts-ignore it is assigned in the observe() callback
        callbackWhenConfigIsReady(config);
      };
      return {
        computeConfigAndUpdate: computeConfigAndUpdate,
        ro: ro
      };
    }
    function createConnector(vm, name, wireDef) {
      var method = wireDef.method,
        adapter = wireDef.adapter,
        configCallback = wireDef.configCallback,
        dynamic = wireDef.dynamic;
      var debugInfo;
      if (process.env.NODE_ENV !== 'production') {
        var wiredPropOrMethod = isUndefined$1(method) ? name : method.name;
        debugInfo = create(null);
        debugInfo.wasDataProvisionedForConfig = false;
        vm.debugInfo[WIRE_DEBUG_ENTRY][wiredPropOrMethod] = debugInfo;
      }
      var fieldOrMethodCallback = isUndefined$1(method) ? createFieldDataCallback(vm, name) : createMethodDataCallback(vm, method);
      var dataCallback = function dataCallback(value) {
        if (process.env.NODE_ENV !== 'production') {
          debugInfo.data = value;
          // Note: most of the time, the data provided is for the current config, but there may be
          // some conditions in which it does not, ex:
          // race conditions in a poor network while the adapter does not cancel a previous request.
          debugInfo.wasDataProvisionedForConfig = true;
        }
        fieldOrMethodCallback(value);
      };
      var context;
      var connector;
      // Workaround to pass the component element associated to this wire adapter instance.
      defineProperty(dataCallback, DeprecatedWiredElementHost, {
        value: vm.elm
      });
      defineProperty(dataCallback, DeprecatedWiredParamsMeta, {
        value: dynamic
      });
      runWithBoundaryProtection(vm, vm, noop, function () {
        // job
        connector = new adapter(dataCallback);
      }, noop);
      var updateConnectorConfig = function updateConnectorConfig(config) {
        // every time the config is recomputed due to tracking,
        // this callback will be invoked with the new computed config
        runWithBoundaryProtection(vm, vm, noop, function () {
          // job
          if (process.env.NODE_ENV !== 'production') {
            debugInfo.config = config;
            debugInfo.context = context;
            debugInfo.wasDataProvisionedForConfig = false;
          }
          connector.update(config, context);
        }, noop);
      };
      // Computes the current wire config and calls the update method on the wire adapter.
      // If it has params, we will need to observe changes in the next tick.
      var _createConfigWatcher = createConfigWatcher(vm.component, configCallback, updateConnectorConfig),
        computeConfigAndUpdate = _createConfigWatcher.computeConfigAndUpdate,
        ro = _createConfigWatcher.ro;
      // if the adapter needs contextualization, we need to watch for new context and push it alongside the config
      if (!isUndefined$1(adapter.contextSchema)) {
        createContextWatcher(vm, wireDef, function (newContext) {
          // every time the context is pushed into this component,
          // this callback will be invoked with the new computed context
          if (context !== newContext) {
            context = newContext;
            // Note: when new context arrives, the config will be recomputed and pushed along side the new
            // context, this is to preserve the identity characteristics, config should not have identity
            // (ever), while context can have identity
            if (vm.state === 1 /* VMState.connected */) {
              computeConfigAndUpdate();
            }
          }
        });
      }
      return {
        // @ts-ignore the boundary protection executes sync, connector is always defined
        connector: connector,
        computeConfigAndUpdate: computeConfigAndUpdate,
        resetConfigWatcher: function resetConfigWatcher() {
          return ro.reset();
        }
      };
    }
    function storeWiredMethodMeta(descriptor, adapter, configCallback, dynamic) {
      // support for callable adapters
      if (adapter.adapter) {
        adapter = adapter.adapter;
      }
      var method = descriptor.value;
      var def = {
        adapter: adapter,
        method: method,
        configCallback: configCallback,
        dynamic: dynamic
      };
      WireMetaMap.set(descriptor, def);
    }
    function storeWiredFieldMeta(descriptor, adapter, configCallback, dynamic) {
      // support for callable adapters
      if (adapter.adapter) {
        adapter = adapter.adapter;
      }
      var def = {
        adapter: adapter,
        configCallback: configCallback,
        dynamic: dynamic
      };
      WireMetaMap.set(descriptor, def);
    }
    function installWireAdapters(vm) {
      var context = vm.context,
        wire = vm.def.wire;
      if (process.env.NODE_ENV !== 'production') {
        vm.debugInfo[WIRE_DEBUG_ENTRY] = create(null);
      }
      var wiredConnecting = context.wiredConnecting = [];
      var wiredDisconnecting = context.wiredDisconnecting = [];
      var _loop2 = function _loop2() {
        var descriptor = wire[fieldNameOrMethod];
        var wireDef = WireMetaMap.get(descriptor);
        if (process.env.NODE_ENV !== 'production') {
          assert.invariant(wireDef, "Internal Error: invalid wire definition found.");
        }
        if (!isUndefined$1(wireDef)) {
          var _createConnector = createConnector(vm, fieldNameOrMethod, wireDef),
            connector = _createConnector.connector,
            computeConfigAndUpdate = _createConnector.computeConfigAndUpdate,
            resetConfigWatcher = _createConnector.resetConfigWatcher;
          var hasDynamicParams = wireDef.dynamic.length > 0;
          ArrayPush$1.call(wiredConnecting, function () {
            connector.connect();
            if (!lwcRuntimeFlags.ENABLE_WIRE_SYNC_EMIT) {
              if (hasDynamicParams) {
                Promise.resolve().then(computeConfigAndUpdate);
                return;
              }
            }
            computeConfigAndUpdate();
          });
          ArrayPush$1.call(wiredDisconnecting, function () {
            connector.disconnect();
            resetConfigWatcher();
          });
        }
      };
      for (var fieldNameOrMethod in wire) {
        _loop2();
      }
    }
    function connectWireAdapters(vm) {
      var wiredConnecting = vm.context.wiredConnecting;
      for (var _i8 = 0, len = wiredConnecting.length; _i8 < len; _i8 += 1) {
        wiredConnecting[_i8]();
      }
    }
    function disconnectWireAdapters(vm) {
      var wiredDisconnecting = vm.context.wiredDisconnecting;
      runWithBoundaryProtection(vm, vm, noop, function () {
        // job
        for (var _i9 = 0, len = wiredDisconnecting.length; _i9 < len; _i9 += 1) {
          wiredDisconnecting[_i9]();
        }
      }, noop);
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function api$1() {
      if (process.env.NODE_ENV !== 'production') {
        assert.fail("@api decorator can only be used as a decorator function.");
      }
      throw new Error();
    }
    function createPublicPropertyDescriptor(key) {
      return {
        get: function get() {
          var vm = getAssociatedVM(this);
          if (isBeingConstructed(vm)) {
            if (process.env.NODE_ENV !== 'production') {
              logError("Can\u2019t read the value of property `".concat(toString$1(key), "` from the constructor because the owner component hasn\u2019t set the value yet. Instead, use the constructor to set a default value for the property."), vm);
            }
            return;
          }
          componentValueObserved(vm, key);
          return vm.cmpProps[key];
        },
        set: function set(newValue) {
          var vm = getAssociatedVM(this);
          if (process.env.NODE_ENV !== 'production') {
            var _vmBeingRendered3 = getVMBeingRendered();
            if (isInvokingRender) {
              logError("render() method has side effects on the state of property \"".concat(toString$1(key), "\""), isNull(_vmBeingRendered3) ? vm : _vmBeingRendered3);
            }
            if (isUpdatingTemplate) {
              logError("Updating the template has side effects on the state of property \"".concat(toString$1(key), "\""), isNull(_vmBeingRendered3) ? vm : _vmBeingRendered3);
            }
          }
          vm.cmpProps[key] = newValue;
          componentValueMutated(vm, key);
        },
        enumerable: true,
        configurable: true
      };
    }
    function createPublicAccessorDescriptor(key, descriptor) {
      var _get2 = descriptor.get,
        _set2 = descriptor.set,
        enumerable = descriptor.enumerable,
        configurable = descriptor.configurable;
      assert.invariant(isFunction$1(_get2), "Invalid public accessor ".concat(toString$1(key), " decorated with @api. The property is missing a getter."));
      return {
        get: function get() {
          if (process.env.NODE_ENV !== 'production') {
            // Assert that the this value is an actual Component with an associated VM.
            getAssociatedVM(this);
          }
          return _get2.call(this);
        },
        set: function set(newValue) {
          var vm = getAssociatedVM(this);
          if (process.env.NODE_ENV !== 'production') {
            var _vmBeingRendered4 = getVMBeingRendered();
            if (isInvokingRender) {
              logError("render() method has side effects on the state of property \"".concat(toString$1(key), "\""), isNull(_vmBeingRendered4) ? vm : _vmBeingRendered4);
            }
            if (isUpdatingTemplate) {
              logError("Updating the template has side effects on the state of property \"".concat(toString$1(key), "\""), isNull(_vmBeingRendered4) ? vm : _vmBeingRendered4);
            }
          }
          if (_set2) {
            _set2.call(this, newValue);
          } else if (process.env.NODE_ENV !== 'production') {
            logError("Invalid attempt to set a new value for property \"".concat(toString$1(key), "\" that does not has a setter decorated with @api."), vm);
          }
        },
        enumerable: enumerable,
        configurable: configurable
      };
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function track(target) {
      if (arguments.length === 1) {
        return getReactiveProxy(target);
      }
      if (process.env.NODE_ENV !== 'production') {
        assert.fail("@track decorator can only be used with one argument to return a trackable object, or as a decorator function.");
      }
      throw new Error();
    }
    function internalTrackDecorator(key) {
      return {
        get: function get() {
          var vm = getAssociatedVM(this);
          componentValueObserved(vm, key);
          return vm.cmpFields[key];
        },
        set: function set(newValue) {
          var vm = getAssociatedVM(this);
          if (process.env.NODE_ENV !== 'production') {
            var _vmBeingRendered5 = getVMBeingRendered();
            if (isInvokingRender) {
              logError("".concat(_vmBeingRendered5, ".render() method has side effects on the state of ").concat(vm, ".").concat(toString$1(key)));
            }
            if (isUpdatingTemplate) {
              logError("Updating the template of ".concat(_vmBeingRendered5, " has side effects on the state of ").concat(vm, ".").concat(toString$1(key)));
            }
          }
          var reactiveOrAnyValue = getReactiveProxy(newValue);
          updateComponentValue(vm, key, reactiveOrAnyValue);
        },
        enumerable: true,
        configurable: true
      };
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * @wire decorator to wire fields and methods to a wire adapter in
     * LWC Components. This function implements the internals of this
     * decorator.
     */
    function wire(_adapter, _config) {
      if (process.env.NODE_ENV !== 'production') {
        assert.fail('@wire(adapter, config?) may only be used as a decorator.');
      }
      throw new Error();
    }
    function internalWireFieldDecorator(key) {
      return {
        get: function get() {
          var vm = getAssociatedVM(this);
          componentValueObserved(vm, key);
          return vm.cmpFields[key];
        },
        set: function set(value) {
          var vm = getAssociatedVM(this);
          /**
           * Reactivity for wired fields is provided in wiring.
           * We intentionally add reactivity here since this is just
           * letting the author to do the wrong thing, but it will keep our
           * system to be backward compatible.
           */
          updateComponentValue(vm, key, value);
        },
        enumerable: true,
        configurable: true
      };
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function getClassDescriptorType(descriptor) {
      if (isFunction$1(descriptor.value)) {
        return "method" /* DescriptorType.Method */;
      } else if (isFunction$1(descriptor.set) || isFunction$1(descriptor.get)) {
        return "accessor" /* DescriptorType.Accessor */;
      } else {
        return "field" /* DescriptorType.Field */;
      }
    }

    function validateObservedField(Ctor, fieldName, descriptor) {
      assertNotProd(); // this method should never leak to prod
      if (!isUndefined$1(descriptor)) {
        var type = getClassDescriptorType(descriptor);
        var message = "Invalid observed ".concat(fieldName, " field. Found a duplicate ").concat(type, " with the same name.");
        // TODO [#3408]: this should throw, not log
        logError(message);
      }
    }
    function validateFieldDecoratedWithTrack(Ctor, fieldName, descriptor) {
      assertNotProd(); // this method should never leak to prod
      if (!isUndefined$1(descriptor)) {
        var type = getClassDescriptorType(descriptor);
        // TODO [#3408]: this should throw, not log
        logError("Invalid @track ".concat(fieldName, " field. Found a duplicate ").concat(type, " with the same name."));
      }
    }
    function validateFieldDecoratedWithWire(Ctor, fieldName, descriptor) {
      assertNotProd(); // this method should never leak to prod
      if (!isUndefined$1(descriptor)) {
        var type = getClassDescriptorType(descriptor);
        // TODO [#3408]: this should throw, not log
        logError("Invalid @wire ".concat(fieldName, " field. Found a duplicate ").concat(type, " with the same name."));
      }
    }
    function validateMethodDecoratedWithWire(Ctor, methodName, descriptor) {
      assertNotProd(); // this method should never leak to prod
      if (isUndefined$1(descriptor) || !isFunction$1(descriptor.value) || isFalse(descriptor.writable)) {
        // TODO [#3441]: This line of code does not seem possible to reach.
        logError("Invalid @wire ".concat(methodName, " field. The field should have a valid writable descriptor."));
      }
    }
    function validateFieldDecoratedWithApi(Ctor, fieldName, descriptor) {
      assertNotProd(); // this method should never leak to prod
      if (!isUndefined$1(descriptor)) {
        var type = getClassDescriptorType(descriptor);
        var message = "Invalid @api ".concat(fieldName, " field. Found a duplicate ").concat(type, " with the same name.");
        // TODO [#3408]: this should throw, not log
        logError(message);
      }
    }
    function validateAccessorDecoratedWithApi(Ctor, fieldName, descriptor) {
      assertNotProd(); // this method should never leak to prod
      if (isFunction$1(descriptor.set)) {
        if (!isFunction$1(descriptor.get)) {
          // TODO [#3441]: This line of code does not seem possible to reach.
          logError("Missing getter for property ".concat(fieldName, " decorated with @api in ").concat(Ctor, ". You cannot have a setter without the corresponding getter."));
        }
      } else if (!isFunction$1(descriptor.get)) {
        // TODO [#3441]: This line of code does not seem possible to reach.
        logError("Missing @api get ".concat(fieldName, " accessor."));
      }
    }
    function validateMethodDecoratedWithApi(Ctor, methodName, descriptor) {
      assertNotProd(); // this method should never leak to prod
      if (isUndefined$1(descriptor) || !isFunction$1(descriptor.value) || isFalse(descriptor.writable)) {
        // TODO [#3441]: This line of code does not seem possible to reach.
        logError("Invalid @api ".concat(methodName, " method."));
      }
    }
    /**
     * INTERNAL: This function can only be invoked by compiled code. The compiler
     * will prevent this function from being imported by user-land code.
     */
    function registerDecorators(Ctor, meta) {
      var proto = Ctor.prototype;
      var publicProps = meta.publicProps,
        publicMethods = meta.publicMethods,
        wire = meta.wire,
        track = meta.track,
        fields = meta.fields;
      var apiMethods = create(null);
      var apiFields = create(null);
      var wiredMethods = create(null);
      var wiredFields = create(null);
      var observedFields = create(null);
      var apiFieldsConfig = create(null);
      var descriptor;
      if (!isUndefined$1(publicProps)) {
        for (var fieldName in publicProps) {
          var propConfig = publicProps[fieldName];
          apiFieldsConfig[fieldName] = propConfig.config;
          descriptor = getOwnPropertyDescriptor$1(proto, fieldName);
          if (propConfig.config > 0) {
            if (isUndefined$1(descriptor)) {
              // TODO [#3441]: This line of code does not seem possible to reach.
              throw new Error();
            }
            // accessor declaration
            if (process.env.NODE_ENV !== 'production') {
              validateAccessorDecoratedWithApi(Ctor, fieldName, descriptor);
            }
            descriptor = createPublicAccessorDescriptor(fieldName, descriptor);
          } else {
            // field declaration
            if (process.env.NODE_ENV !== 'production') {
              validateFieldDecoratedWithApi(Ctor, fieldName, descriptor);
            }
            // [W-9927596] If a component has both a public property and a private setter/getter
            // with the same name, the property is defined as a public accessor. This branch is
            // only here for backward compatibility reasons.
            if (!isUndefined$1(descriptor) && !isUndefined$1(descriptor.get)) {
              descriptor = createPublicAccessorDescriptor(fieldName, descriptor);
            } else {
              descriptor = createPublicPropertyDescriptor(fieldName);
            }
          }
          apiFields[fieldName] = descriptor;
          defineProperty(proto, fieldName, descriptor);
        }
      }
      if (!isUndefined$1(publicMethods)) {
        forEach.call(publicMethods, function (methodName) {
          descriptor = getOwnPropertyDescriptor$1(proto, methodName);
          if (process.env.NODE_ENV !== 'production') {
            validateMethodDecoratedWithApi(Ctor, methodName, descriptor);
          }
          if (isUndefined$1(descriptor)) {
            throw new Error();
          }
          apiMethods[methodName] = descriptor;
        });
      }
      if (!isUndefined$1(wire)) {
        for (var fieldOrMethodName in wire) {
          var _wire$fieldOrMethodNa = wire[fieldOrMethodName],
            adapter = _wire$fieldOrMethodNa.adapter,
            method = _wire$fieldOrMethodNa.method,
            configCallback = _wire$fieldOrMethodNa.config,
            _wire$fieldOrMethodNa2 = _wire$fieldOrMethodNa.dynamic,
            dynamic = _wire$fieldOrMethodNa2 === void 0 ? [] : _wire$fieldOrMethodNa2;
          descriptor = getOwnPropertyDescriptor$1(proto, fieldOrMethodName);
          if (method === 1) {
            if (process.env.NODE_ENV !== 'production') {
              if (!adapter) {
                // TODO [#3408]: this should throw, not log
                logError("@wire on method \"".concat(fieldOrMethodName, "\": adapter id must be truthy."));
              }
              validateMethodDecoratedWithWire(Ctor, fieldOrMethodName, descriptor);
            }
            if (isUndefined$1(descriptor)) {
              throw new Error();
            }
            wiredMethods[fieldOrMethodName] = descriptor;
            storeWiredMethodMeta(descriptor, adapter, configCallback, dynamic);
          } else {
            if (process.env.NODE_ENV !== 'production') {
              if (!adapter) {
                // TODO [#3408]: this should throw, not log
                logError("@wire on field \"".concat(fieldOrMethodName, "\": adapter id must be truthy."));
              }
              validateFieldDecoratedWithWire(Ctor, fieldOrMethodName, descriptor);
            }
            descriptor = internalWireFieldDecorator(fieldOrMethodName);
            wiredFields[fieldOrMethodName] = descriptor;
            storeWiredFieldMeta(descriptor, adapter, configCallback, dynamic);
            defineProperty(proto, fieldOrMethodName, descriptor);
          }
        }
      }
      if (!isUndefined$1(track)) {
        for (var _fieldName in track) {
          descriptor = getOwnPropertyDescriptor$1(proto, _fieldName);
          if (process.env.NODE_ENV !== 'production') {
            validateFieldDecoratedWithTrack(Ctor, _fieldName, descriptor);
          }
          descriptor = internalTrackDecorator(_fieldName);
          defineProperty(proto, _fieldName, descriptor);
        }
      }
      if (!isUndefined$1(fields)) {
        for (var _i10 = 0, n = fields.length; _i10 < n; _i10++) {
          var _fieldName2 = fields[_i10];
          descriptor = getOwnPropertyDescriptor$1(proto, _fieldName2);
          if (process.env.NODE_ENV !== 'production') {
            validateObservedField(Ctor, _fieldName2, descriptor);
          }
          // [W-9927596] Only mark a field as observed whenever it isn't a duplicated public nor
          // tracked property. This is only here for backward compatibility purposes.
          var isDuplicatePublicProp = !isUndefined$1(publicProps) && _fieldName2 in publicProps;
          var isDuplicateTrackedProp = !isUndefined$1(track) && _fieldName2 in track;
          if (!isDuplicatePublicProp && !isDuplicateTrackedProp) {
            observedFields[_fieldName2] = createObservedFieldPropertyDescriptor(_fieldName2);
          }
        }
      }
      setDecoratorsMeta(Ctor, {
        apiMethods: apiMethods,
        apiFields: apiFields,
        apiFieldsConfig: apiFieldsConfig,
        wiredMethods: wiredMethods,
        wiredFields: wiredFields,
        observedFields: observedFields
      });
      return Ctor;
    }
    var signedDecoratorToMetaMap = new Map();
    function setDecoratorsMeta(Ctor, meta) {
      signedDecoratorToMetaMap.set(Ctor, meta);
    }
    var defaultMeta = {
      apiMethods: EmptyObject,
      apiFields: EmptyObject,
      apiFieldsConfig: EmptyObject,
      wiredMethods: EmptyObject,
      wiredFields: EmptyObject,
      observedFields: EmptyObject
    };
    function getDecoratorsMeta(Ctor) {
      var meta = signedDecoratorToMetaMap.get(Ctor);
      return isUndefined$1(meta) ? defaultMeta : meta;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var warned = false;
    // Only used in LWC's Karma tests
    if (process.env.NODE_ENV === 'test-karma-lwc') {
      // @ts-ignore
      window.__lwcResetWarnedOnVersionMismatch = function () {
        warned = false;
      };
    }
    function checkVersionMismatch(func, type) {
      var versionMatcher = func.toString().match(LWC_VERSION_COMMENT_REGEX);
      if (!isNull(versionMatcher) && !warned) {
        var version = versionMatcher[1];
        var _version$split = version.split('.'),
          _version$split2 = _slicedToArray(_version$split, 2),
          major = _version$split2[0],
          minor = _version$split2[1];
        var _LWC_VERSION$split = LWC_VERSION.split('.'),
          _LWC_VERSION$split2 = _slicedToArray(_LWC_VERSION$split, 2),
          expectedMajor = _LWC_VERSION$split2[0],
          expectedMinor = _LWC_VERSION$split2[1];
        if (major !== expectedMajor || minor !== expectedMinor) {
          warned = true; // only warn once to avoid flooding the console
          // stylesheets and templates do not have user-meaningful names, but components do
          var friendlyName = type === 'component' ? "".concat(type, " ").concat(func.name) : type;
          logError("LWC WARNING: current engine is v".concat(LWC_VERSION, ", but ").concat(friendlyName, " was compiled with v").concat(version, ".\nPlease update your compiled code or LWC engine so that the versions match.\nNo further warnings will appear."));
          report("CompilerRuntimeVersionMismatch" /* ReportingEventId.CompilerRuntimeVersionMismatch */, {
            compilerVersion: version,
            runtimeVersion: LWC_VERSION
          });
        }
      }
    }
    var signedTemplateSet = new Set();
    function defaultEmptyTemplate() {
      return [];
    }
    signedTemplateSet.add(defaultEmptyTemplate);
    function isTemplateRegistered(tpl) {
      return signedTemplateSet.has(tpl);
    }
    /**
     * INTERNAL: This function can only be invoked by compiled code. The compiler
     * will prevent this function from being imported by userland code.
     */
    function registerTemplate(tpl) {
      if (process.env.NODE_ENV !== 'production') {
        checkVersionMismatch(tpl, 'template');
      }
      signedTemplateSet.add(tpl);
      // chaining this method as a way to wrap existing
      // assignment of templates easily, without too much transformation
      return tpl;
    }
    /**
     * EXPERIMENTAL: This function acts like a hook for Lightning Locker Service and other similar
     * libraries to sanitize vulnerable attributes.
     */
    function sanitizeAttribute(tagName, namespaceUri, attrName, attrValue) {
      // locker-service patches this function during runtime to sanitize vulnerable attributes. When
      // ran off-core this function becomes a noop and returns the user authored value.
      return attrValue;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // A bridge descriptor is a descriptor whose job is just to get the component instance
    // from the element instance, and get the value or set a new value on the component.
    // This means that across different elements, similar names can get the exact same
    // descriptor, so we can cache them:
    var cachedGetterByKey = create(null);
    var cachedSetterByKey = create(null);
    function createGetter(key) {
      var fn = cachedGetterByKey[key];
      if (isUndefined$1(fn)) {
        fn = cachedGetterByKey[key] = function () {
          var vm = getAssociatedVM(this);
          var getHook = vm.getHook;
          return getHook(vm.component, key);
        };
      }
      return fn;
    }
    function createSetter(key) {
      var fn = cachedSetterByKey[key];
      if (isUndefined$1(fn)) {
        fn = cachedSetterByKey[key] = function (newValue) {
          var vm = getAssociatedVM(this);
          var setHook = vm.setHook;
          newValue = getReadOnlyProxy(newValue);
          setHook(vm.component, key, newValue);
        };
      }
      return fn;
    }
    function createMethodCaller(methodName) {
      return function () {
        var vm = getAssociatedVM(this);
        var callHook = vm.callHook,
          component = vm.component;
        var fn = component[methodName];
        return callHook(vm.component, fn, ArraySlice.call(arguments));
      };
    }
    function createAttributeChangedCallback(attributeToPropMap, superAttributeChangedCallback) {
      return function attributeChangedCallback(attrName, oldValue, newValue) {
        if (oldValue === newValue) {
          // Ignore same values.
          return;
        }
        var propName = attributeToPropMap[attrName];
        if (isUndefined$1(propName)) {
          if (!isUndefined$1(superAttributeChangedCallback)) {
            // delegate unknown attributes to the super.
            // Typescript does not like it when you treat the `arguments` object as an array
            // @ts-ignore type-mismatch
            superAttributeChangedCallback.apply(this, arguments);
          }
          return;
        }
        if (!isAttributeLocked(this, attrName)) {
          // Ignore changes triggered by the engine itself during:
          // * diffing when public props are attempting to reflect to the DOM
          // * component via `this.setAttribute()`, should never update the prop
          // Both cases, the setAttribute call is always wrapped by the unlocking of the
          // attribute to be changed
          return;
        }
        // Reflect attribute change to the corresponding property when changed from outside.
        this[propName] = newValue;
      };
    }
    function HTMLBridgeElementFactory(SuperClass, props, methods) {
      var HTMLBridgeElement;
      /**
       * Modern browsers will have all Native Constructors as regular Classes
       * and must be instantiated with the new keyword. In older browsers,
       * specifically IE11, those are objects with a prototype property defined,
       * since they are not supposed to be extended or instantiated with the
       * new keyword. This forking logic supports both cases, specifically because
       * wc.ts relies on the construction path of the bridges to create new
       * fully qualifying web components.
       */
      if (isFunction$1(SuperClass)) {
        HTMLBridgeElement = /*#__PURE__*/function (_SuperClass) {
          _inherits(HTMLBridgeElement, _SuperClass);
          var _super3 = _createSuper(HTMLBridgeElement);
          function HTMLBridgeElement() {
            _classCallCheck(this, HTMLBridgeElement);
            return _super3.apply(this, arguments);
          }
          return _createClass(HTMLBridgeElement);
        }(SuperClass);
      } else {
        HTMLBridgeElement = function HTMLBridgeElement() {
          // Bridge classes are not supposed to be instantiated directly in
          // browsers that do not support web components.
          throw new TypeError('Illegal constructor');
        };
        // prototype inheritance dance
        setPrototypeOf(HTMLBridgeElement, SuperClass);
        setPrototypeOf(HTMLBridgeElement.prototype, SuperClass.prototype);
        defineProperty(HTMLBridgeElement.prototype, 'constructor', {
          writable: true,
          configurable: true,
          value: HTMLBridgeElement
        });
      }
      // generating the hash table for attributes to avoid duplicate fields and facilitate validation
      // and false positives in case of inheritance.
      var attributeToPropMap = create(null);
      var superAttributeChangedCallback = SuperClass.prototype.attributeChangedCallback;
      var _SuperClass$observedA = SuperClass.observedAttributes,
        superObservedAttributes = _SuperClass$observedA === void 0 ? [] : _SuperClass$observedA;
      var descriptors = create(null);
      // expose getters and setters for each public props on the new Element Bridge
      for (var _i11 = 0, len = props.length; _i11 < len; _i11 += 1) {
        var _propName = props[_i11];
        attributeToPropMap[htmlPropertyToAttribute(_propName)] = _propName;
        descriptors[_propName] = {
          get: createGetter(_propName),
          set: createSetter(_propName),
          enumerable: true,
          configurable: true
        };
      }
      // expose public methods as props on the new Element Bridge
      for (var _i12 = 0, _len = methods.length; _i12 < _len; _i12 += 1) {
        var methodName = methods[_i12];
        descriptors[methodName] = {
          value: createMethodCaller(methodName),
          writable: true,
          configurable: true
        };
      }
      // creating a new attributeChangedCallback per bridge because they are bound to the corresponding
      // map of attributes to props. We do this after all other props and methods to avoid the possibility
      // of getting overrule by a class declaration in user-land, and we make it non-writable, non-configurable
      // to preserve this definition.
      descriptors.attributeChangedCallback = {
        value: createAttributeChangedCallback(attributeToPropMap, superAttributeChangedCallback)
      };
      // Specify attributes for which we want to reflect changes back to their corresponding
      // properties via attributeChangedCallback.
      defineProperty(HTMLBridgeElement, 'observedAttributes', {
        get: function get() {
          return [].concat(_toConsumableArray(superObservedAttributes), _toConsumableArray(keys(attributeToPropMap)));
        }
      });
      defineProperties(HTMLBridgeElement.prototype, descriptors);
      return HTMLBridgeElement;
    }
    var BaseBridgeElement = HTMLBridgeElementFactory(HTMLElementConstructor, getOwnPropertyNames$1(HTMLElementOriginalDescriptors), []);
    {
      // This ARIA reflection only really makes sense in the browser. On the server, there is no `renderedCallback()`,
      // so you cannot do e.g. `this.template.querySelector('x-child').ariaBusy = 'true'`. So we don't need to expose
      // ARIA props outside the LightningElement
      if (lwcRuntimeFlags.DISABLE_ARIA_REFLECTION_POLYFILL) {
        // If ARIA reflection is not applied globally to Element.prototype, apply it to HTMLBridgeElement.prototype.
        // This allows `elm.aria*` property accessors to work from outside a component, and to reflect `aria-*` attrs.
        // This is especially important because the template compiler compiles aria-* attrs on components to aria* props
        //
        // Also note that we apply this to BaseBridgeElement.prototype to avoid excessively redefining property
        // accessors inside the HTMLBridgeElementFactory.
        applyAriaReflection(BaseBridgeElement.prototype);
      }
    }
    freeze(BaseBridgeElement);
    seal(BaseBridgeElement.prototype);

    /*
     * Copyright (c) 2023, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var supportsWeakRefs = typeof WeakRef === 'function' && typeof FinalizationRegistry === 'function';
    // In browsers that doesn't support WeakRefs, the values will still leak, but at least the keys won't
    var LegacyWeakMultiMap = /*#__PURE__*/function () {
      function LegacyWeakMultiMap() {
        _classCallCheck(this, LegacyWeakMultiMap);
        this._map = new WeakMap();
      }
      _createClass(LegacyWeakMultiMap, [{
        key: "_getValues",
        value: function _getValues(key) {
          var values = this._map.get(key);
          if (isUndefined$1(values)) {
            values = new Set();
            this._map.set(key, values);
          }
          return values;
        }
      }, {
        key: "get",
        value: function get(key) {
          return this._getValues(key);
        }
      }, {
        key: "add",
        value: function add(key, vm) {
          var set = this._getValues(key);
          set.add(vm);
        }
      }, {
        key: "delete",
        value: function _delete(key) {
          this._map.delete(key);
        }
      }]);
      return LegacyWeakMultiMap;
    }(); // This implementation relies on the WeakRef/FinalizationRegistry proposal.
    // For some background, see: https://github.com/tc39/proposal-weakrefs
    var ModernWeakMultiMap = /*#__PURE__*/function () {
      function ModernWeakMultiMap() {
        _classCallCheck(this, ModernWeakMultiMap);
        this._map = new WeakMap();
        this._registry = new FinalizationRegistry(function (weakRefs) {
          // This should be considered an optional cleanup method to remove GC'ed values from their respective arrays.
          // JS VMs are not obligated to call FinalizationRegistry callbacks.
          // Work backwards, removing stale VMs
          for (var _i13 = weakRefs.length - 1; _i13 >= 0; _i13--) {
            var vm = weakRefs[_i13].deref();
            if (isUndefined$1(vm)) {
              ArraySplice.call(weakRefs, _i13, 1); // remove
            }
          }
        });
      }
      _createClass(ModernWeakMultiMap, [{
        key: "_getWeakRefs",
        value: function _getWeakRefs(key) {
          var weakRefs = this._map.get(key);
          if (isUndefined$1(weakRefs)) {
            weakRefs = [];
            this._map.set(key, weakRefs);
          }
          return weakRefs;
        }
      }, {
        key: "get",
        value: function get(key) {
          var weakRefs = this._getWeakRefs(key);
          var result = new Set();
          var _iterator5 = _createForOfIteratorHelper(weakRefs),
            _step5;
          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
              var weakRef = _step5.value;
              var vm = weakRef.deref();
              if (!isUndefined$1(vm)) {
                result.add(vm);
              }
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }
          return result;
        }
      }, {
        key: "add",
        value: function add(key, value) {
          var weakRefs = this._getWeakRefs(key);
          // We could check for duplicate values here, but it doesn't seem worth it.
          // We transform the output into a Set anyway
          ArrayPush$1.call(weakRefs, new WeakRef(value));
          // It's important here not to leak the second argument, which is the "held value." The FinalizationRegistry
          // effectively creates a strong reference between the first argument (the "target") and the held value. When
          // the target is GC'ed, the callback is called, and then the held value is GC'ed.
          // Putting the key here would mean the key is not GC'ed until the value is GC'ed, which defeats the purpose
          // of the WeakMap. Whereas putting the weakRefs array here is fine, because it doesn't have a strong reference
          // to anything. See also this example:
          // https://gist.github.com/nolanlawson/79a3d36e8e6cc25c5048bb17c1795aea
          this._registry.register(value, weakRefs);
        }
      }, {
        key: "delete",
        value: function _delete(key) {
          this._map.delete(key);
        }
      }]);
      return ModernWeakMultiMap;
    }();
    var WeakMultiMap = supportsWeakRefs ? ModernWeakMultiMap : LegacyWeakMultiMap;

    /*
     * Copyright (c) 2020, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var swappedTemplateMap = new WeakMap();
    var swappedComponentMap = new WeakMap();
    var swappedStyleMap = new WeakMap();
    // The important thing here is the weak values – VMs are transient (one per component instance) and should be GC'ed,
    // so we don't want to create strong references to them.
    // The weak keys are kind of useless, because Templates, LightningElementConstructors, and StylesheetFactories are
    // never GC'ed. But maybe they will be someday, so we may as well use weak keys too.
    var activeTemplates = new WeakMultiMap();
    var activeComponents = new WeakMultiMap();
    var activeStyles = new WeakMultiMap();
    function rehydrateHotTemplate(tpl) {
      var list = activeTemplates.get(tpl);
      var _iterator6 = _createForOfIteratorHelper(list),
        _step6;
      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var vm = _step6.value;
          if (isFalse(vm.isDirty)) {
            // forcing the vm to rehydrate in the micro-task:
            markComponentAsDirty(vm);
            scheduleRehydration(vm);
          }
        }
        // Resetting the Set since these VMs are no longer related to this template, instead
        // they will get re-associated once these instances are rehydrated.
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
      activeTemplates.delete(tpl);
      return true;
    }
    function rehydrateHotStyle(style) {
      var list = activeStyles.get(style);
      var _iterator7 = _createForOfIteratorHelper(list),
        _step7;
      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var vm = _step7.value;
          // if a style definition is swapped, we must reset
          // vm's template content in the next micro-task:
          forceRehydration(vm);
        }
        // Resetting the Set since these VMs are no longer related to this style, instead
        // they will get re-associated once these instances are rehydrated.
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }
      activeStyles.delete(style);
      return true;
    }
    function rehydrateHotComponent(Ctor) {
      var list = activeComponents.get(Ctor);
      var canRefreshAllInstances = true;
      var _iterator8 = _createForOfIteratorHelper(list),
        _step8;
      try {
        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
          var vm = _step8.value;
          var owner = vm.owner;
          if (!isNull(owner)) {
            // if a component class definition is swapped, we must reset
            // owner's template content in the next micro-task:
            forceRehydration(owner);
          } else {
            // the hot swapping for components only work for instances of components
            // created from a template, root elements can't be swapped because we
            // don't have a way to force the creation of the element with the same state
            // of the current element.
            // Instead, we can report the problem to the caller so it can take action,
            // for example: reload the entire page.
            canRefreshAllInstances = false;
          }
        }
        // resetting the Set since these VMs are no longer related to this constructor, instead
        // they will get re-associated once these instances are rehydrated.
      } catch (err) {
        _iterator8.e(err);
      } finally {
        _iterator8.f();
      }
      activeComponents.delete(Ctor);
      return canRefreshAllInstances;
    }
    function getTemplateOrSwappedTemplate(tpl) {
      assertNotProd(); // this method should never leak to prod
      var visited = new Set();
      while (swappedTemplateMap.has(tpl) && !visited.has(tpl)) {
        visited.add(tpl);
        tpl = swappedTemplateMap.get(tpl);
      }
      return tpl;
    }
    function getComponentOrSwappedComponent(Ctor) {
      assertNotProd(); // this method should never leak to prod
      var visited = new Set();
      while (swappedComponentMap.has(Ctor) && !visited.has(Ctor)) {
        visited.add(Ctor);
        Ctor = swappedComponentMap.get(Ctor);
      }
      return Ctor;
    }
    function getStyleOrSwappedStyle(style) {
      assertNotProd(); // this method should never leak to prod
      var visited = new Set();
      while (swappedStyleMap.has(style) && !visited.has(style)) {
        visited.add(style);
        style = swappedStyleMap.get(style);
      }
      return style;
    }
    function setActiveVM(vm) {
      assertNotProd(); // this method should never leak to prod
      // tracking active component
      var Ctor = vm.def.ctor;
      // this will allow us to keep track of the hot components
      activeComponents.add(Ctor, vm);
      // tracking active template
      var tpl = vm.cmpTemplate;
      if (tpl) {
        // this will allow us to keep track of the templates that are
        // being used by a hot component
        activeTemplates.add(tpl, vm);
        // tracking active styles associated to template
        var stylesheets = tpl.stylesheets;
        if (!isUndefined$1(stylesheets)) {
          var _iterator9 = _createForOfIteratorHelper(flattenStylesheets(stylesheets)),
            _step9;
          try {
            for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
              var stylesheet = _step9.value;
              // this is necessary because we don't hold the list of styles
              // in the vm, we only hold the selected (already swapped template)
              // but the styles attached to the template might not be the actual
              // active ones, but the swapped versions of those.
              var swappedStylesheet = getStyleOrSwappedStyle(stylesheet);
              // this will allow us to keep track of the stylesheet that are
              // being used by a hot component
              activeStyles.add(swappedStylesheet, vm);
            }
          } catch (err) {
            _iterator9.e(err);
          } finally {
            _iterator9.f();
          }
        }
      }
    }
    function swapTemplate(oldTpl, newTpl) {
      if (process.env.NODE_ENV !== 'production') {
        if (isTemplateRegistered(oldTpl) && isTemplateRegistered(newTpl)) {
          swappedTemplateMap.set(oldTpl, newTpl);
          return rehydrateHotTemplate(oldTpl);
        } else {
          throw new TypeError("Invalid Template");
        }
      }
      return false;
    }
    function swapComponent(oldComponent, newComponent) {
      if (process.env.NODE_ENV !== 'production') {
        if (isComponentConstructor(oldComponent) && isComponentConstructor(newComponent)) {
          swappedComponentMap.set(oldComponent, newComponent);
          return rehydrateHotComponent(oldComponent);
        } else {
          throw new TypeError("Invalid Component");
        }
      }
      return false;
    }
    function swapStyle(oldStyle, newStyle) {
      if (process.env.NODE_ENV !== 'production') {
        // TODO [#1887]: once the support for registering styles is implemented
        // we can add the validation of both styles around this block.
        swappedStyleMap.set(oldStyle, newStyle);
        return rehydrateHotStyle(oldStyle);
      }
      return false;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var CtorToDefMap = new WeakMap();
    function getCtorProto(Ctor) {
      var proto = getPrototypeOf$1(Ctor);
      if (isNull(proto)) {
        throw new ReferenceError("Invalid prototype chain for ".concat(Ctor.name, ", you must extend LightningElement."));
      }
      // covering the cases where the ref is circular in AMD
      if (isCircularModuleDependency(proto)) {
        var p = resolveCircularModuleDependency(proto);
        if (process.env.NODE_ENV !== 'production') {
          if (isNull(p)) {
            throw new ReferenceError("Circular module dependency for ".concat(Ctor.name, ", must resolve to a constructor that extends LightningElement."));
          }
        }
        // escape hatch for Locker and other abstractions to provide their own base class instead
        // of our Base class without having to leak it to user-land. If the circular function returns
        // itself, that's the signal that we have hit the end of the proto chain, which must always
        // be base.
        proto = p === proto ? LightningElement : p;
      }
      return proto;
    }
    function createComponentDef(Ctor) {
      var ctorShadowSupportMode = Ctor.shadowSupportMode,
        ctorRenderMode = Ctor.renderMode;
      if (process.env.NODE_ENV !== 'production') {
        var ctorName = Ctor.name;
        // Removing the following assert until https://bugs.webkit.org/show_bug.cgi?id=190140 is fixed.
        // assert.isTrue(ctorName && isString(ctorName), `${toString(Ctor)} should have a "name" property with string value, but found ${ctorName}.`);
        if (!Ctor.constructor) {
          // This error seems impossible to hit, due to an earlier check in `isComponentConstructor()`.
          // But we keep it here just in case.
          logError("Missing ".concat(ctorName, ".constructor, ").concat(ctorName, " should have a \"constructor\" property."));
        }
        if (!isUndefined$1(ctorShadowSupportMode) && ctorShadowSupportMode !== "any" /* ShadowSupportMode.Any */ && ctorShadowSupportMode !== "reset" /* ShadowSupportMode.Default */) {
          logError("Invalid value for static property shadowSupportMode: '".concat(ctorShadowSupportMode, "'"));
        }
        if (!isUndefined$1(ctorRenderMode) && ctorRenderMode !== 'light' && ctorRenderMode !== 'shadow') {
          logError("Invalid value for static property renderMode: '".concat(ctorRenderMode, "'. renderMode must be either 'light' or 'shadow'."));
        }
      }
      var decoratorsMeta = getDecoratorsMeta(Ctor);
      var apiFields = decoratorsMeta.apiFields,
        apiFieldsConfig = decoratorsMeta.apiFieldsConfig,
        apiMethods = decoratorsMeta.apiMethods,
        wiredFields = decoratorsMeta.wiredFields,
        wiredMethods = decoratorsMeta.wiredMethods,
        observedFields = decoratorsMeta.observedFields;
      var proto = Ctor.prototype;
      var connectedCallback = proto.connectedCallback,
        disconnectedCallback = proto.disconnectedCallback,
        renderedCallback = proto.renderedCallback,
        errorCallback = proto.errorCallback,
        render = proto.render;
      var superProto = getCtorProto(Ctor);
      var superDef = superProto !== LightningElement ? getComponentInternalDef(superProto) : lightingElementDef;
      var bridge = HTMLBridgeElementFactory(superDef.bridge, keys(apiFields), keys(apiMethods));
      var props = assign(create(null), superDef.props, apiFields);
      var propsConfig = assign(create(null), superDef.propsConfig, apiFieldsConfig);
      var methods = assign(create(null), superDef.methods, apiMethods);
      var wire = assign(create(null), superDef.wire, wiredFields, wiredMethods);
      connectedCallback = connectedCallback || superDef.connectedCallback;
      disconnectedCallback = disconnectedCallback || superDef.disconnectedCallback;
      renderedCallback = renderedCallback || superDef.renderedCallback;
      errorCallback = errorCallback || superDef.errorCallback;
      render = render || superDef.render;
      var shadowSupportMode = superDef.shadowSupportMode;
      if (!isUndefined$1(ctorShadowSupportMode)) {
        shadowSupportMode = ctorShadowSupportMode;
      }
      var renderMode = superDef.renderMode;
      if (!isUndefined$1(ctorRenderMode)) {
        renderMode = ctorRenderMode === 'light' ? 0 /* RenderMode.Light */ : 1 /* RenderMode.Shadow */;
      }

      var template = getComponentRegisteredTemplate(Ctor) || superDef.template;
      var name = Ctor.name || superDef.name;
      // installing observed fields into the prototype.
      defineProperties(proto, observedFields);
      var def = {
        ctor: Ctor,
        name: name,
        wire: wire,
        props: props,
        propsConfig: propsConfig,
        methods: methods,
        bridge: bridge,
        template: template,
        renderMode: renderMode,
        shadowSupportMode: shadowSupportMode,
        connectedCallback: connectedCallback,
        disconnectedCallback: disconnectedCallback,
        renderedCallback: renderedCallback,
        errorCallback: errorCallback,
        render: render
      };
      if (process.env.NODE_ENV !== 'production') {
        freeze(Ctor.prototype);
      }
      return def;
    }
    /**
     * EXPERIMENTAL: This function allows for the identification of LWC constructors. This API is
     * subject to change or being removed.
     */
    function isComponentConstructor(ctor) {
      if (!isFunction$1(ctor)) {
        return false;
      }
      // Fast path: LightningElement is part of the prototype chain of the constructor.
      if (ctor.prototype instanceof LightningElement) {
        return true;
      }
      // Slow path: LightningElement is not part of the prototype chain of the constructor, we need
      // climb up the constructor prototype chain to check in case there are circular dependencies
      // to resolve.
      var current = ctor;
      do {
        if (isCircularModuleDependency(current)) {
          var circularResolved = resolveCircularModuleDependency(current);
          // If the circular function returns itself, that's the signal that we have hit the end
          // of the proto chain, which must always be a valid base constructor.
          if (circularResolved === current) {
            return true;
          }
          current = circularResolved;
        }
        if (current === LightningElement) {
          return true;
        }
      } while (!isNull(current) && (current = getPrototypeOf$1(current)));
      // Finally return false if the LightningElement is not part of the prototype chain.
      return false;
    }
    function getComponentInternalDef(Ctor) {
      if (process.env.NODE_ENV !== 'production') {
        Ctor = getComponentOrSwappedComponent(Ctor);
      }
      var def = CtorToDefMap.get(Ctor);
      if (isUndefined$1(def)) {
        if (isCircularModuleDependency(Ctor)) {
          var resolvedCtor = resolveCircularModuleDependency(Ctor);
          def = getComponentInternalDef(resolvedCtor);
          // Cache the unresolved component ctor too. The next time if the same unresolved ctor is used,
          // look up the definition in cache instead of re-resolving and recreating the def.
          CtorToDefMap.set(Ctor, def);
          return def;
        }
        if (!isComponentConstructor(Ctor)) {
          throw new TypeError("".concat(Ctor, " is not a valid component, or does not extends LightningElement from \"lwc\". You probably forgot to add the extend clause on the class declaration."));
        }
        def = createComponentDef(Ctor);
        CtorToDefMap.set(Ctor, def);
      }
      return def;
    }
    function getComponentHtmlPrototype(Ctor) {
      var def = getComponentInternalDef(Ctor);
      return def.bridge;
    }
    var lightingElementDef = {
      ctor: LightningElement,
      name: LightningElement.name,
      props: lightningBasedDescriptors,
      propsConfig: EmptyObject,
      methods: EmptyObject,
      renderMode: 1 /* RenderMode.Shadow */,
      shadowSupportMode: "reset" /* ShadowSupportMode.Default */,
      wire: EmptyObject,
      bridge: BaseBridgeElement,
      template: defaultEmptyTemplate,
      render: LightningElement.prototype.render
    };
    /**
     * EXPERIMENTAL: This function allows for the collection of internal component metadata. This API is
     * subject to change or being removed.
     */
    function getComponentDef(Ctor) {
      var def = getComponentInternalDef(Ctor);
      // From the internal def object, we need to extract the info that is useful
      // for some external services, e.g.: Locker Service, usually, all they care
      // is about the shape of the constructor, the internals of it are not relevant
      // because they don't have a way to mess with that.
      var ctor = def.ctor,
        name = def.name,
        props = def.props,
        propsConfig = def.propsConfig,
        methods = def.methods;
      var publicProps = {};
      for (var key in props) {
        // avoid leaking the reference to the public props descriptors
        publicProps[key] = {
          config: propsConfig[key] || 0,
          type: "any" /* PropDefType.any */,
          attr: htmlPropertyToAttribute(key)
        };
      }
      var publicMethods = {};
      for (var _key2 in methods) {
        // avoid leaking the reference to the public method descriptors
        publicMethods[_key2] = methods[_key2].value;
      }
      return {
        ctor: ctor,
        name: name,
        props: publicProps,
        methods: publicMethods
      };
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function makeHostToken(token) {
      return "".concat(token, "-host");
    }
    function createInlineStyleVNode(content) {
      return api.h('style', {
        key: 'style',
        attrs: {
          type: 'text/css'
        }
      }, [api.t(content)]);
    }
    function updateStylesheetToken(vm, template) {
      var elm = vm.elm,
        context = vm.context,
        renderMode = vm.renderMode,
        shadowMode = vm.shadowMode,
        _vm$renderer = vm.renderer,
        getClassList = _vm$renderer.getClassList,
        removeAttribute = _vm$renderer.removeAttribute,
        setAttribute = _vm$renderer.setAttribute;
      var newStylesheets = template.stylesheets,
        newStylesheetToken = template.stylesheetToken;
      var newVmStylesheets = vm.stylesheets;
      var isSyntheticShadow = renderMode === 1 /* RenderMode.Shadow */ && shadowMode === 1 /* ShadowMode.Synthetic */;
      var hasScopedStyles = context.hasScopedStyles;
      var newToken;
      var newHasTokenInClass;
      var newHasTokenInAttribute;
      // Reset the styling token applied to the host element.
      var oldToken = context.stylesheetToken,
        oldHasTokenInClass = context.hasTokenInClass,
        oldHasTokenInAttribute = context.hasTokenInAttribute;
      if (!isUndefined$1(oldToken)) {
        if (oldHasTokenInClass) {
          getClassList(elm).remove(makeHostToken(oldToken));
        }
        if (oldHasTokenInAttribute) {
          removeAttribute(elm, makeHostToken(oldToken));
        }
      }
      // Apply the new template styling token to the host element, if the new template has any
      // associated stylesheets. In the case of light DOM, also ensure there is at least one scoped stylesheet.
      var hasNewStylesheets = hasStyles(newStylesheets);
      var hasNewVmStylesheets = hasStyles(newVmStylesheets);
      if (hasNewStylesheets || hasNewVmStylesheets) {
        newToken = newStylesheetToken;
      }
      // Set the new styling token on the host element
      if (!isUndefined$1(newToken)) {
        if (hasScopedStyles) {
          getClassList(elm).add(makeHostToken(newToken));
          newHasTokenInClass = true;
        }
        if (isSyntheticShadow) {
          setAttribute(elm, makeHostToken(newToken), '');
          newHasTokenInAttribute = true;
        }
      }
      // Update the styling tokens present on the context object.
      context.stylesheetToken = newToken;
      context.hasTokenInClass = newHasTokenInClass;
      context.hasTokenInAttribute = newHasTokenInAttribute;
    }
    function evaluateStylesheetsContent(stylesheets, stylesheetToken, vm) {
      var content = [];
      var root;
      for (var _i14 = 0; _i14 < stylesheets.length; _i14++) {
        var stylesheet = stylesheets[_i14];
        if (isArray$1(stylesheet)) {
          ArrayPush$1.apply(content, evaluateStylesheetsContent(stylesheet, stylesheetToken, vm));
        } else {
          if (process.env.NODE_ENV !== 'production') {
            // Check for compiler version mismatch in dev mode only
            checkVersionMismatch(stylesheet, 'stylesheet');
            // in dev-mode, we support hot swapping of stylesheet, which means that
            // the component instance might be attempting to use an old version of
            // the stylesheet, while internally, we have a replacement for it.
            stylesheet = getStyleOrSwappedStyle(stylesheet);
          }
          var isScopedCss = stylesheet[KEY__SCOPED_CSS];
          if (lwcRuntimeFlags.DISABLE_LIGHT_DOM_UNSCOPED_CSS && !isScopedCss && vm.renderMode === 0 /* RenderMode.Light */) {
            logError('Unscoped CSS is not supported in Light DOM. Please use scoped CSS (*.scoped.css) instead of unscoped CSS (*.css).');
            continue;
          }
          // Apply the scope token only if the stylesheet itself is scoped, or if we're rendering synthetic shadow.
          var scopeToken = isScopedCss || vm.shadowMode === 1 /* ShadowMode.Synthetic */ && vm.renderMode === 1 /* RenderMode.Shadow */ ? stylesheetToken : undefined;
          // Use the actual `:host` selector if we're rendering global CSS for light DOM, or if we're rendering
          // native shadow DOM. Synthetic shadow DOM never uses `:host`.
          var useActualHostSelector = vm.renderMode === 0 /* RenderMode.Light */ ? !isScopedCss : vm.shadowMode === 0 /* ShadowMode.Native */;
          // Use the native :dir() pseudoclass only in native shadow DOM. Otherwise, in synthetic shadow,
          // we use an attribute selector on the host to simulate :dir().
          var useNativeDirPseudoclass = void 0;
          if (vm.renderMode === 1 /* RenderMode.Shadow */) {
            useNativeDirPseudoclass = vm.shadowMode === 0 /* ShadowMode.Native */;
          } else {
            // Light DOM components should only render `[dir]` if they're inside of a synthetic shadow root.
            // At the top level (root is null) or inside of a native shadow root, they should use `:dir()`.
            if (isUndefined$1(root)) {
              // Only calculate the root once as necessary
              root = getNearestShadowComponent(vm);
            }
            useNativeDirPseudoclass = isNull(root) || root.shadowMode === 0 /* ShadowMode.Native */;
          }

          ArrayPush$1.call(content, stylesheet(scopeToken, useActualHostSelector, useNativeDirPseudoclass));
        }
      }
      return content;
    }
    function getStylesheetsContent(vm, template) {
      var stylesheets = template.stylesheets,
        stylesheetToken = template.stylesheetToken;
      var vmStylesheets = vm.stylesheets;
      var content = [];
      if (hasStyles(stylesheets)) {
        content = evaluateStylesheetsContent(stylesheets, stylesheetToken, vm);
      }
      // VM (component) stylesheets apply after template stylesheets
      if (hasStyles(vmStylesheets)) {
        ArrayPush$1.apply(content, evaluateStylesheetsContent(vmStylesheets, stylesheetToken, vm));
      }
      return content;
    }
    // It might be worth caching this to avoid doing the lookup repeatedly, but
    // perf testing has not shown it to be a huge improvement yet:
    // https://github.com/salesforce/lwc/pull/2460#discussion_r691208892
    function getNearestShadowComponent(vm) {
      var owner = vm;
      while (!isNull(owner)) {
        if (owner.renderMode === 1 /* RenderMode.Shadow */) {
          return owner;
        }
        owner = owner.owner;
      }
      return owner;
    }
    /**
     * If the component that is currently being rendered uses scoped styles,
     * this returns the unique token for that scoped stylesheet. Otherwise
     * it returns null.
     */
    function getScopeTokenClass(owner) {
      var cmpTemplate = owner.cmpTemplate,
        context = owner.context;
      return context.hasScopedStyles && (cmpTemplate === null || cmpTemplate === void 0 ? void 0 : cmpTemplate.stylesheetToken) || null;
    }
    /**
     * This function returns the host style token for a custom element if it
     * exists. Otherwise it returns null.
     *
     * A host style token is applied to the component if scoped styles are used.
     */
    function getStylesheetTokenHost(vnode) {
      var _getComponentInternal = getComponentInternalDef(vnode.ctor),
        template = _getComponentInternal.template;
      var vm = vnode.vm;
      var stylesheetToken = template.stylesheetToken;
      return !isUndefined$1(stylesheetToken) && computeHasScopedStyles(template, vm) ? makeHostToken(stylesheetToken) : null;
    }
    function getNearestNativeShadowComponent(vm) {
      var owner = getNearestShadowComponent(vm);
      if (!isNull(owner) && owner.shadowMode === 1 /* ShadowMode.Synthetic */) {
        // Synthetic-within-native is impossible. So if the nearest shadow component is
        // synthetic, we know we won't find a native component if we go any further.
        return null;
      }
      return owner;
    }
    function createStylesheet(vm, stylesheets) {
      var renderMode = vm.renderMode,
        shadowMode = vm.shadowMode,
        insertStylesheet = vm.renderer.insertStylesheet;
      if (renderMode === 1 /* RenderMode.Shadow */ && shadowMode === 1 /* ShadowMode.Synthetic */) {
        for (var _i15 = 0; _i15 < stylesheets.length; _i15++) {
          insertStylesheet(stylesheets[_i15]);
        }
      } else if (vm.hydrated) {
        // Note: We need to ensure that during hydration, the stylesheets method is the same as those in ssr.
        //       This works in the client, because the stylesheets are created, and cached in the VM
        //       the first time the VM renders.
        // native shadow or light DOM, SSR
        return ArrayMap.call(stylesheets, createInlineStyleVNode);
      } else {
        // native shadow or light DOM, DOM renderer
        var root = getNearestNativeShadowComponent(vm);
        // null root means a global style
        var target = isNull(root) ? undefined : root.shadowRoot;
        for (var _i16 = 0; _i16 < stylesheets.length; _i16++) {
          insertStylesheet(stylesheets[_i16], target);
        }
      }
      return null;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function isVBaseElement(vnode) {
      var type = vnode.type;
      return type === 2 /* VNodeType.Element */ || type === 3 /* VNodeType.CustomElement */;
    }

    function isSameVnode(vnode1, vnode2) {
      return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;
    }
    function isVCustomElement(vnode) {
      return vnode.type === 3 /* VNodeType.CustomElement */;
    }

    function isVFragment(vnode) {
      return vnode.type === 5 /* VNodeType.Fragment */;
    }

    function isVScopedSlotFragment(vnode) {
      return vnode.type === 6 /* VNodeType.ScopedSlotFragment */;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var ColonCharCode$1 = 58;
    function patchAttributes(oldVnode, vnode, renderer) {
      var attrs = vnode.data.attrs;
      if (isUndefined$1(attrs)) {
        return;
      }
      var oldAttrs = isNull(oldVnode) ? EmptyObject : oldVnode.data.attrs;
      if (oldAttrs === attrs) {
        return;
      }
      var elm = vnode.elm;
      var setAttribute = renderer.setAttribute,
        removeAttribute = renderer.removeAttribute;
      for (var key in attrs) {
        var cur = attrs[key];
        var old = oldAttrs[key];
        if (old !== cur) {
          unlockAttribute(elm, key);
          if (StringCharCodeAt.call(key, 3) === ColonCharCode$1) {
            // Assume xml namespace
            setAttribute(elm, key, cur, XML_NAMESPACE);
          } else if (StringCharCodeAt.call(key, 5) === ColonCharCode$1) {
            // Assume xlink namespace
            setAttribute(elm, key, cur, XLINK_NAMESPACE);
          } else if (isNull(cur) || isUndefined$1(cur)) {
            removeAttribute(elm, key);
          } else {
            setAttribute(elm, key, cur);
          }
          lockAttribute();
        }
      }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var ColonCharCode = 58;
    function patchAttrUnlessProp(oldVnode, vnode, renderer) {
      var attrs = vnode.data.attrs,
        elm = vnode.elm;
      if (isUndefined$1(attrs)) {
        return;
      }
      var removeAttribute = renderer.removeAttribute,
        setAttribute = renderer.setAttribute,
        setProperty = renderer.setProperty;
      var oldAttrs = isNull(oldVnode) ? EmptyObject : oldVnode.data.attrs;
      for (var name in attrs) {
        var cur = attrs[name];
        var old = oldAttrs[name];
        if (old !== cur) {
          var _propName2 = htmlAttributeToProperty(name);
          if (_propName2 in elm) {
            setProperty(elm, name, cur);
          } else if (StringCharCodeAt.call(name, 3) === ColonCharCode) {
            // Assume xml namespace
            setAttribute(elm, name, cur, XML_NAMESPACE);
          } else if (StringCharCodeAt.call(name, 5) === ColonCharCode) {
            // Assume xlink namespace
            setAttribute(elm, name, cur, XLINK_NAMESPACE);
          } else if (isNull(cur) || isUndefined$1(cur)) {
            removeAttribute(elm, name);
          } else {
            setAttribute(elm, name, cur);
          }
        }
      }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function isLiveBindingProp(sel, key) {
      // For properties with live bindings, we read values from the DOM element
      // instead of relying on internally tracked values.
      return sel === 'input' && (key === 'value' || key === 'checked');
    }
    function patchProps(oldVnode, vnode, renderer) {
      var props = vnode.data.props;
      var spread = vnode.data.spread;
      if (isUndefined$1(props) && isUndefined$1(spread)) {
        return;
      }
      var oldProps;
      if (!isNull(oldVnode)) {
        oldProps = oldVnode.data.props;
        var oldSpread = oldVnode.data.spread;
        if (oldProps === props && oldSpread === spread) {
          return;
        }
        if (isUndefined$1(oldProps)) {
          oldProps = EmptyObject;
        }
        if (!isUndefined$1(oldSpread)) {
          oldProps = assign({}, oldProps, oldSpread);
        }
      }
      if (!isUndefined$1(spread)) {
        props = assign({}, props, spread);
      }
      var isFirstPatch = isNull(oldVnode);
      var elm = vnode.elm,
        sel = vnode.sel;
      var getProperty = renderer.getProperty,
        setProperty = renderer.setProperty;
      for (var key in props) {
        var cur = props[key];
        // Set the property if it's the first time is is patched or if the previous property is
        // different than the one previously set.
        if (isFirstPatch || cur !== (isLiveBindingProp(sel, key) ? getProperty(elm, key) : oldProps[key]) || !(key in oldProps) // this is required because the above case will pass when `cur` is `undefined` and key is missing in `oldProps`
        ) {
          // Additional verification if properties are supported by the element
          // Validation relies on html properties and public properties being defined on the element,
          // SSR has its own custom validation.
          if (process.env.NODE_ENV !== 'production') {
            if (!(key in elm)) {
              logWarn("Unknown public property \"".concat(key, "\" of element <").concat(elm.tagName.toLowerCase(), ">. This is either a typo on the corresponding attribute \"").concat(htmlPropertyToAttribute(key), "\", or the attribute does not exist in this browser or DOM implementation."));
            }
          }
          setProperty(elm, key, cur);
        }
      }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var classNameToClassMap = create(null);
    function getMapFromClassName(className) {
      // Intentionally using == to match undefined and null values from computed style attribute
      if (className == null) {
        return EmptyObject;
      }
      // computed class names must be string
      className = isString(className) ? className : className + '';
      var map = classNameToClassMap[className];
      if (map) {
        return map;
      }
      map = create(null);
      var start = 0;
      var o;
      var len = className.length;
      for (o = 0; o < len; o++) {
        if (StringCharCodeAt.call(className, o) === SPACE_CHAR) {
          if (o > start) {
            map[StringSlice.call(className, start, o)] = true;
          }
          start = o + 1;
        }
      }
      if (o > start) {
        map[StringSlice.call(className, start, o)] = true;
      }
      classNameToClassMap[className] = map;
      if (process.env.NODE_ENV !== 'production') {
        // just to make sure that this object never changes as part of the diffing algo
        freeze(map);
      }
      return map;
    }
    function patchClassAttribute(oldVnode, vnode, renderer) {
      var elm = vnode.elm,
        newClass = vnode.data.className;
      var oldClass = isNull(oldVnode) ? undefined : oldVnode.data.className;
      if (oldClass === newClass) {
        return;
      }
      var getClassList = renderer.getClassList;
      var classList = getClassList(elm);
      var newClassMap = getMapFromClassName(newClass);
      var oldClassMap = getMapFromClassName(oldClass);
      var name;
      for (name in oldClassMap) {
        // remove only if it is not in the new class collection and it is not set from within the instance
        if (isUndefined$1(newClassMap[name])) {
          classList.remove(name);
        }
      }
      for (name in newClassMap) {
        if (isUndefined$1(oldClassMap[name])) {
          classList.add(name);
        }
      }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // The style property is a string when defined via an expression in the template.
    function patchStyleAttribute(oldVnode, vnode, renderer) {
      var elm = vnode.elm,
        newStyle = vnode.data.style;
      var oldStyle = isNull(oldVnode) ? undefined : oldVnode.data.style;
      if (oldStyle === newStyle) {
        return;
      }
      var setAttribute = renderer.setAttribute,
        removeAttribute = renderer.removeAttribute;
      if (!isString(newStyle) || newStyle === '') {
        removeAttribute(elm, 'style');
      } else {
        setAttribute(elm, 'style', newStyle);
      }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function applyEventListeners(vnode, renderer) {
      var elm = vnode.elm,
        on = vnode.data.on;
      if (isUndefined$1(on)) {
        return;
      }
      var addEventListener = renderer.addEventListener;
      for (var name in on) {
        var handler = on[name];
        addEventListener(elm, name, handler);
      }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // The HTML class property becomes the vnode.data.classMap object when defined as a string in the template.
    // The compiler takes care of transforming the inline classnames into an object. It's faster to set the
    // different classnames properties individually instead of via a string.
    function applyStaticClassAttribute(vnode, renderer) {
      var elm = vnode.elm,
        classMap = vnode.data.classMap;
      if (isUndefined$1(classMap)) {
        return;
      }
      var getClassList = renderer.getClassList;
      var classList = getClassList(elm);
      for (var name in classMap) {
        classList.add(name);
      }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // The HTML style property becomes the vnode.data.styleDecls object when defined as a string in the template.
    // The compiler takes care of transforming the inline style into an object. It's faster to set the
    // different style properties individually instead of via a string.
    function applyStaticStyleAttribute(vnode, renderer) {
      var elm = vnode.elm,
        styleDecls = vnode.data.styleDecls;
      if (isUndefined$1(styleDecls)) {
        return;
      }
      var setCSSStyleProperty = renderer.setCSSStyleProperty;
      for (var _i17 = 0; _i17 < styleDecls.length; _i17++) {
        var _styleDecls$_i = _slicedToArray(styleDecls[_i17], 3),
          prop = _styleDecls$_i[0],
          value = _styleDecls$_i[1],
          important = _styleDecls$_i[2];
        setCSSStyleProperty(elm, prop, value, important);
      }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function patchChildren(c1, c2, parent, renderer) {
      if (hasDynamicChildren(c2)) {
        updateDynamicChildren(c1, c2, parent, renderer);
      } else {
        updateStaticChildren(c1, c2, parent, renderer);
      }
    }
    function patch(n1, n2, parent, renderer) {
      var _a, _b;
      if (n1 === n2) {
        return;
      }
      if (process.env.NODE_ENV !== 'production') {
        if (!isSameVnode(n1, n2) &&
        // Currently the only scenario when patch does not receive the same vnodes are for
        // dynamic components. When a dynamic component's constructor changes, the value of its
        // tag name (sel) will be different. The engine will unmount the previous element
        // and mount the new one using the new constructor in patchCustomElement.
        !(isVCustomElement(n1) && isVCustomElement(n2))) {
          throw new Error('Expected these VNodes to be the same: ' + JSON.stringify({
            sel: n1.sel,
            key: n1.key
          }) + ', ' + JSON.stringify({
            sel: n2.sel,
            key: n2.key
          }));
        }
      }
      switch (n2.type) {
        case 0 /* VNodeType.Text */:
          // VText has no special capability, fallback to the owner's renderer
          patchText(n1, n2, renderer);
          break;
        case 1 /* VNodeType.Comment */:
          // VComment has no special capability, fallback to the owner's renderer
          patchComment(n1, n2, renderer);
          break;
        case 4 /* VNodeType.Static */:
          n2.elm = n1.elm;
          break;
        case 5 /* VNodeType.Fragment */:
          patchFragment(n1, n2, parent, renderer);
          break;
        case 2 /* VNodeType.Element */:
          patchElement(n1, n2, (_a = n2.data.renderer) !== null && _a !== void 0 ? _a : renderer);
          break;
        case 3 /* VNodeType.CustomElement */:
          patchCustomElement(n1, n2, parent, (_b = n2.data.renderer) !== null && _b !== void 0 ? _b : renderer);
          break;
      }
    }
    function mount(node, parent, renderer, anchor) {
      var _a, _b;
      switch (node.type) {
        case 0 /* VNodeType.Text */:
          // VText has no special capability, fallback to the owner's renderer
          mountText(node, parent, anchor, renderer);
          break;
        case 1 /* VNodeType.Comment */:
          // VComment has no special capability, fallback to the owner's renderer
          mountComment(node, parent, anchor, renderer);
          break;
        case 4 /* VNodeType.Static */:
          // VStatic cannot have a custom renderer associated to them, using owner's renderer
          mountStatic(node, parent, anchor, renderer);
          break;
        case 5 /* VNodeType.Fragment */:
          mountFragment(node, parent, anchor, renderer);
          break;
        case 2 /* VNodeType.Element */:
          // If the vnode data has a renderer override use it, else fallback to owner's renderer
          mountElement(node, parent, anchor, (_a = node.data.renderer) !== null && _a !== void 0 ? _a : renderer);
          break;
        case 3 /* VNodeType.CustomElement */:
          // If the vnode data has a renderer override use it, else fallback to owner's renderer
          mountCustomElement(node, parent, anchor, (_b = node.data.renderer) !== null && _b !== void 0 ? _b : renderer);
          break;
      }
    }
    function patchText(n1, n2, renderer) {
      n2.elm = n1.elm;
      if (n2.text !== n1.text) {
        updateTextContent(n2, renderer);
      }
    }
    function mountText(vnode, parent, anchor, renderer) {
      var owner = vnode.owner;
      var createText = renderer.createText;
      var textNode = vnode.elm = createText(vnode.text);
      linkNodeToShadow(textNode, owner, renderer);
      insertNode(textNode, parent, anchor, renderer);
    }
    function patchComment(n1, n2, renderer) {
      n2.elm = n1.elm;
      // FIXME: Comment nodes should be static, we shouldn't need to diff them together. However
      // it is the case today.
      if (n2.text !== n1.text) {
        updateTextContent(n2, renderer);
      }
    }
    function mountComment(vnode, parent, anchor, renderer) {
      var owner = vnode.owner;
      var createComment = renderer.createComment;
      var commentNode = vnode.elm = createComment(vnode.text);
      linkNodeToShadow(commentNode, owner, renderer);
      insertNode(commentNode, parent, anchor, renderer);
    }
    function mountFragment(vnode, parent, anchor, renderer) {
      var children = vnode.children;
      mountVNodes(children, parent, renderer, anchor);
      vnode.elm = vnode.leading.elm;
    }
    function patchFragment(n1, n2, parent, renderer) {
      var children = n2.children,
        stable = n2.stable;
      if (stable) {
        updateStaticChildren(n1.children, children, parent, renderer);
      } else {
        updateDynamicChildren(n1.children, children, parent, renderer);
      }
      // Note: not reusing n1.elm, because during patching, it may be patched with another text node.
      n2.elm = n2.leading.elm;
    }
    function mountElement(vnode, parent, anchor, renderer) {
      var sel = vnode.sel,
        owner = vnode.owner,
        svg = vnode.data.svg;
      var createElement = renderer.createElement;
      var namespace = isTrue(svg) ? SVG_NAMESPACE : undefined;
      var elm = vnode.elm = createElement(sel, namespace);
      linkNodeToShadow(elm, owner, renderer);
      applyStyleScoping(elm, owner, renderer);
      applyDomManual(elm, vnode);
      applyElementRestrictions(elm, vnode);
      patchElementPropsAndAttrs$1(null, vnode, renderer);
      insertNode(elm, parent, anchor, renderer);
      mountVNodes(vnode.children, elm, renderer, null);
    }
    function patchElement(n1, n2, renderer) {
      var elm = n2.elm = n1.elm;
      patchElementPropsAndAttrs$1(n1, n2, renderer);
      patchChildren(n1.children, n2.children, elm, renderer);
    }
    function mountStatic(vnode, parent, anchor, renderer) {
      var owner = vnode.owner;
      var cloneNode = renderer.cloneNode,
        isSyntheticShadowDefined = renderer.isSyntheticShadowDefined;
      var elm = vnode.elm = cloneNode(vnode.fragment, true);
      linkNodeToShadow(elm, owner, renderer);
      applyElementRestrictions(elm, vnode);
      // Marks this node as Static to propagate the shadow resolver. must happen after elm is assigned to the proper shadow
      var renderMode = owner.renderMode,
        shadowMode = owner.shadowMode;
      if (isSyntheticShadowDefined) {
        if (shadowMode === 1 /* ShadowMode.Synthetic */ || renderMode === 0 /* RenderMode.Light */) {
          elm[KEY__SHADOW_STATIC] = true;
        }
      }
      insertNode(elm, parent, anchor, renderer);
    }
    function mountCustomElement(vnode, parent, anchor, renderer) {
      var sel = vnode.sel,
        owner = vnode.owner;
      var createCustomElement = renderer.createCustomElement;
      /**
       * Note: if the upgradable constructor does not expect, or throw when we new it
       * with a callback as the first argument, we could implement a more advanced
       * mechanism that only passes that argument if the constructor is known to be
       * an upgradable custom element.
       */
      var vm;
      var upgradeCallback = function upgradeCallback(elm) {
        // the custom element from the registry is expecting an upgrade callback
        vm = createViewModelHook(elm, vnode, renderer);
      };
      var connectedCallback;
      var disconnectedCallback;
      if (lwcRuntimeFlags.ENABLE_NATIVE_CUSTOM_ELEMENT_LIFECYCLE) {
        connectedCallback = function connectedCallback(elm) {
          connectRootElement(elm);
        };
        disconnectedCallback = function disconnectedCallback(elm) {
          disconnectRootElement(elm);
        };
      }
      // Should never get a tag with upper case letter at this point; the compiler
      // should produce only tags with lowercase letters. However, the Java
      // compiler may generate tagnames with uppercase letters so - for backwards
      // compatibility, we lower case the tagname here.
      var normalizedTagname = sel.toLowerCase();
      var elm = createCustomElement(normalizedTagname, upgradeCallback, connectedCallback, disconnectedCallback);
      vnode.elm = elm;
      vnode.vm = vm;
      linkNodeToShadow(elm, owner, renderer);
      applyStyleScoping(elm, owner, renderer);
      if (vm) {
        allocateChildren(vnode, vm);
      }
      patchElementPropsAndAttrs$1(null, vnode, renderer);
      insertNode(elm, parent, anchor, renderer);
      if (vm) {
        {
          if (!lwcRuntimeFlags.ENABLE_NATIVE_CUSTOM_ELEMENT_LIFECYCLE) {
            if (process.env.NODE_ENV !== 'production') {
              // With synthetic lifecycle callbacks, it's possible for elements to be removed without the engine
              // noticing it (e.g. `appendChild` the same host element twice). This test ensures we don't regress.
              assert.isTrue(vm.state === 0 /* VMState.created */, "".concat(vm, " cannot be recycled."));
            }
            runConnectedCallback(vm);
          }
        }
      }
      mountVNodes(vnode.children, elm, renderer, null);
      if (vm) {
        appendVM(vm);
      }
    }
    function patchCustomElement(n1, n2, parent, renderer) {
      // TODO [#3331]: This if branch should be removed in 246 with lwc:dynamic
      if (n1.ctor !== n2.ctor) {
        // If the constructor differs, unmount the current component and mount a new one using the new
        // constructor.
        var anchor = renderer.nextSibling(n1.elm);
        unmount(n1, parent, renderer, true);
        mountCustomElement(n2, parent, anchor, renderer);
      } else {
        // Otherwise patch the existing component with new props/attrs/etc.
        var elm = n2.elm = n1.elm;
        var vm = n2.vm = n1.vm;
        patchElementPropsAndAttrs$1(n1, n2, renderer);
        if (!isUndefined$1(vm)) {
          // in fallback mode, the allocation will always set children to
          // empty and delegate the real allocation to the slot elements
          allocateChildren(n2, vm);
          // Solves an edge case with slotted VFragments in native shadow mode.
          //
          // During allocation, in native shadow, slotted VFragment nodes are flattened and their text delimiters are removed
          // to avoid interfering with native slot behavior. When this happens, if any of the fragments
          // were not stable, the children must go through the dynamic diffing algo.
          //
          // If the new children (n2.children) contain no VFragments, but the previous children (n1.children) were dynamic,
          // the new nodes must be marked dynamic so that all nodes are properly updated. The only indicator that the new
          // nodes need to be dynamic comes from the previous children, so we check that to determine whether we need to
          // mark the new children dynamic.
          //
          // Example:
          // n1.children: [div, VFragment('', div, null, ''), div] => [div, div, null, div]; // marked dynamic
          // n2.children: [div, null, div] => [div, null, div] // marked ???
          var shadowMode = vm.shadowMode,
            renderMode = vm.renderMode;
          if (shadowMode == 0 /* ShadowMode.Native */ && renderMode !== 0 /* RenderMode.Light */ && hasDynamicChildren(n1.children)) {
            // No-op if children has already been marked dynamic by 'allocateChildren()'.
            markAsDynamicChildren(n2.children);
          }
        }
        // in fallback mode, the children will be always empty, so, nothing
        // will happen, but in native, it does allocate the light dom
        patchChildren(n1.children, n2.children, elm, renderer);
        if (!isUndefined$1(vm)) {
          // this will probably update the shadowRoot, but only if the vm is in a dirty state
          // this is important to preserve the top to bottom synchronous rendering phase.
          rerenderVM(vm);
        }
      }
    }
    function mountVNodes(vnodes, parent, renderer, anchor) {
      var start = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var end = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : vnodes.length;
      for (; start < end; ++start) {
        var vnode = vnodes[start];
        if (isVNode(vnode)) {
          mount(vnode, parent, renderer, anchor);
        }
      }
    }
    function unmount(vnode, parent, renderer) {
      var doRemove = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var type = vnode.type,
        elm = vnode.elm,
        sel = vnode.sel;
      // When unmounting a VNode subtree not all the elements have to removed from the DOM. The
      // subtree root, is the only element worth unmounting from the subtree.
      if (doRemove) {
        if (type === 5 /* VNodeType.Fragment */) {
          unmountVNodes(vnode.children, parent, renderer, doRemove);
        } else {
          // The vnode might or might not have a data.renderer associated to it
          // but the removal used here is from the owner instead.
          removeNode(elm, parent, renderer);
        }
      }
      switch (type) {
        case 2 /* VNodeType.Element */:
          {
            // Slot content is removed to trigger slotchange event when removing slot.
            // Only required for synthetic shadow.
            var shouldRemoveChildren = sel === 'slot' && vnode.owner.shadowMode === 1 /* ShadowMode.Synthetic */;
            unmountVNodes(vnode.children, elm, renderer, shouldRemoveChildren);
            break;
          }
        case 3 /* VNodeType.CustomElement */:
          {
            var vm = vnode.vm;
            // No need to unmount the children here, `removeVM` will take care of removing the
            // children.
            if (!isUndefined$1(vm)) {
              removeVM(vm);
            }
          }
      }
    }
    function unmountVNodes(vnodes, parent, renderer) {
      var doRemove = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var start = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var end = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : vnodes.length;
      for (; start < end; ++start) {
        var ch = vnodes[start];
        if (isVNode(ch)) {
          unmount(ch, parent, renderer, doRemove);
        }
      }
    }
    function isVNode(vnode) {
      return vnode != null;
    }
    function linkNodeToShadow(elm, owner, renderer) {
      var renderRoot = owner.renderRoot,
        renderMode = owner.renderMode,
        shadowMode = owner.shadowMode;
      var isSyntheticShadowDefined = renderer.isSyntheticShadowDefined;
      // TODO [#1164]: this should eventually be done by the polyfill directly
      if (isSyntheticShadowDefined) {
        if (shadowMode === 1 /* ShadowMode.Synthetic */ || renderMode === 0 /* RenderMode.Light */) {
          elm[KEY__SHADOW_RESOLVER] = renderRoot[KEY__SHADOW_RESOLVER];
        }
      }
    }
    function updateTextContent(vnode, renderer) {
      var elm = vnode.elm,
        text = vnode.text;
      var setText = renderer.setText;
      if (process.env.NODE_ENV !== 'production') {
        unlockDomMutation();
      }
      setText(elm, text);
      if (process.env.NODE_ENV !== 'production') {
        lockDomMutation();
      }
    }
    function insertFragmentOrNode(vnode, parent, anchor, renderer) {
      if (process.env.NODE_ENV !== 'production') {
        unlockDomMutation();
      }
      if (isVFragment(vnode)) {
        var children = vnode.children;
        for (var _i18 = 0; _i18 < children.length; _i18 += 1) {
          var child = children[_i18];
          if (!isNull(child)) {
            renderer.insert(child.elm, parent, anchor);
          }
        }
      } else {
        renderer.insert(vnode.elm, parent, anchor);
      }
      if (process.env.NODE_ENV !== 'production') {
        lockDomMutation();
      }
    }
    function insertNode(node, parent, anchor, renderer) {
      if (process.env.NODE_ENV !== 'production') {
        unlockDomMutation();
      }
      renderer.insert(node, parent, anchor);
      if (process.env.NODE_ENV !== 'production') {
        lockDomMutation();
      }
    }
    function removeNode(node, parent, renderer) {
      if (process.env.NODE_ENV !== 'production') {
        unlockDomMutation();
      }
      renderer.remove(node, parent);
      if (process.env.NODE_ENV !== 'production') {
        lockDomMutation();
      }
    }
    function patchElementPropsAndAttrs$1(oldVnode, vnode, renderer) {
      if (isNull(oldVnode)) {
        applyEventListeners(vnode, renderer);
        applyStaticClassAttribute(vnode, renderer);
        applyStaticStyleAttribute(vnode, renderer);
      }
      // Attrs need to be applied to element before props IE11 will wipe out value on radio inputs if
      // value is set before type=radio.
      patchClassAttribute(oldVnode, vnode, renderer);
      patchStyleAttribute(oldVnode, vnode, renderer);
      if (vnode.data.external) {
        patchAttrUnlessProp(oldVnode, vnode, renderer);
      } else {
        patchAttributes(oldVnode, vnode, renderer);
      }
      patchProps(oldVnode, vnode, renderer);
    }
    function applyStyleScoping(elm, owner, renderer) {
      // Set the class name for `*.scoped.css` style scoping.
      var scopeToken = getScopeTokenClass(owner);
      if (!isNull(scopeToken)) {
        var getClassList = renderer.getClassList;
        // TODO [#2762]: this dot notation with add is probably problematic
        // probably we should have a renderer api for just the add operation
        getClassList(elm).add(scopeToken);
      }
      // Set property element for synthetic shadow DOM style scoping.
      var syntheticToken = owner.context.stylesheetToken;
      if (owner.shadowMode === 1 /* ShadowMode.Synthetic */ && !isUndefined$1(syntheticToken)) {
        elm.$shadowToken$ = syntheticToken;
      }
    }
    function applyDomManual(elm, vnode) {
      var _a;
      var owner = vnode.owner,
        context = vnode.data.context;
      if (owner.shadowMode === 1 /* ShadowMode.Synthetic */ && ((_a = context === null || context === void 0 ? void 0 : context.lwc) === null || _a === void 0 ? void 0 : _a.dom) === "manual" /* LwcDomMode.Manual */) {
        elm.$domManual$ = true;
      }
    }
    function applyElementRestrictions(elm, vnode) {
      var _a, _b;
      if (process.env.NODE_ENV !== 'production') {
        var isSynthetic = vnode.owner.shadowMode === 1 /* ShadowMode.Synthetic */;
        var isPortal = vnode.type === 2 /* VNodeType.Element */ && ((_b = (_a = vnode.data.context) === null || _a === void 0 ? void 0 : _a.lwc) === null || _b === void 0 ? void 0 : _b.dom) === "manual" /* LwcDomMode.Manual */;
        var isLight = vnode.owner.renderMode === 0 /* RenderMode.Light */;
        patchElementWithRestrictions(elm, {
          isPortal: isPortal,
          isLight: isLight,
          isSynthetic: isSynthetic
        });
      }
    }
    function allocateChildren(vnode, vm) {
      // A component with slots will re-render because:
      // 1- There is a change of the internal state.
      // 2- There is a change on the external api (ex: slots)
      //
      // In case #1, the vnodes in the cmpSlots will be reused since they didn't changed. This routine emptied the
      // slotted children when those VCustomElement were rendered and therefore in subsequent calls to allocate children
      // in a reused VCustomElement, there won't be any slotted children.
      // For those cases, we will use the reference for allocated children stored when rendering the fresh VCustomElement.
      //
      // In case #2, we will always get a fresh VCustomElement.
      var children = vnode.aChildren || vnode.children;
      var renderMode = vm.renderMode,
        shadowMode = vm.shadowMode;
      if (process.env.NODE_ENV !== 'production') {
        // If any of the children being allocated is a scoped slot fragment, make sure the receiving
        // component is a light DOM component. This is mainly to validate light dom parent running
        // in native shadow mode.
        if (renderMode !== 0 /* RenderMode.Light */ && ArraySome.call(children, function (child) {
          return !isNull(child) && isVScopedSlotFragment(child);
        })) {
          logError("Invalid usage of 'lwc:slot-data' on ".concat(getComponentTag(vm), " tag. Scoped slot content can only be passed to a light dom child."));
        }
      }
      // If any of the children being allocated are VFragments, we remove the text delimiters and flatten all immediate
      // children VFragments to avoid them interfering with default slot behavior.
      var allocatedChildren = flattenFragmentsInChildren(children);
      vnode.children = allocatedChildren;
      vm.aChildren = allocatedChildren;
      if (shadowMode === 1 /* ShadowMode.Synthetic */ || renderMode === 0 /* RenderMode.Light */) {
        // slow path
        allocateInSlot(vm, allocatedChildren, vnode.owner);
        // save the allocated children in case this vnode is reused.
        vnode.aChildren = allocatedChildren;
        // every child vnode is now allocated, and the host should receive none directly, it receives them via the shadow!
        vnode.children = EmptyArray;
      }
    }
    /**
     * Flattens the contents of all VFragments in an array of VNodes, removes the text delimiters on those VFragments, and
     * marks the resulting children array as dynamic. Uses a stack (array) to iteratively traverse the nested VFragments
     * and avoid the perf overhead of creating/destroying throwaway arrays/objects in a recursive approach.
     *
     * With the delimiters removed, the contents are marked dynamic so they are diffed correctly.
     *
     * This function is used for slotted VFragments to avoid the text delimiters interfering with slotting functionality.
     */
    function flattenFragmentsInChildren(children) {
      var flattenedChildren = [];
      // Initialize our stack with the direct children of the custom component and check whether we have a VFragment.
      // If no VFragment is found in children, we don't need to traverse anything or mark the children dynamic and can return early.
      var nodeStack = [];
      var fragmentFound = false;
      for (var _i19 = children.length - 1; _i19 > -1; _i19 -= 1) {
        var child = children[_i19];
        ArrayPush$1.call(nodeStack, child);
        fragmentFound = fragmentFound || !!(child && isVFragment(child));
      }
      if (!fragmentFound) {
        return children;
      }
      var currentNode;
      while (!isUndefined$1(currentNode = ArrayPop.call(nodeStack))) {
        if (!isNull(currentNode) && isVFragment(currentNode)) {
          var fChildren = currentNode.children;
          // Ignore the start and end text node delimiters
          for (var _i20 = fChildren.length - 2; _i20 > 0; _i20 -= 1) {
            ArrayPush$1.call(nodeStack, fChildren[_i20]);
          }
        } else {
          ArrayPush$1.call(flattenedChildren, currentNode);
        }
      }
      // We always mark the children as dynamic because nothing generates stable VFragments yet.
      // If/when stable VFragments are generated by the compiler, this code should be updated to
      // not mark dynamic if all flattened VFragments were stable.
      markAsDynamicChildren(flattenedChildren);
      return flattenedChildren;
    }
    function createViewModelHook(elm, vnode, renderer) {
      var vm = getAssociatedVMIfPresent(elm);
      // There is a possibility that a custom element is registered under tagName, in which case, the
      // initialization is already carry on, and there is nothing else to do here since this hook is
      // called right after invoking `document.createElement`.
      if (!isUndefined$1(vm)) {
        return vm;
      }
      var sel = vnode.sel,
        mode = vnode.mode,
        ctor = vnode.ctor,
        owner = vnode.owner;
      vm = createVM(elm, ctor, renderer, {
        mode: mode,
        owner: owner,
        tagName: sel
      });
      if (process.env.NODE_ENV !== 'production') {
        assert.isTrue(isArray$1(vnode.children), "Invalid vnode for a custom element, it must have children defined.");
      }
      return vm;
    }
    function allocateInSlot(vm, children, owner) {
      var _a, _b;
      var oldSlotsMapping = vm.cmpSlots.slotAssignments;
      var cmpSlotsMapping = create(null);
      // Collect all slots into cmpSlotsMapping
      for (var _i21 = 0, len = children.length; _i21 < len; _i21 += 1) {
        var vnode = children[_i21];
        if (isNull(vnode)) {
          continue;
        }
        var slotName = '';
        if (isVBaseElement(vnode)) {
          slotName = (_b = (_a = vnode.data.attrs) === null || _a === void 0 ? void 0 : _a.slot) !== null && _b !== void 0 ? _b : '';
        } else if (isVScopedSlotFragment(vnode)) {
          slotName = vnode.slotName;
        }
        // Can't use toString here because Symbol(1).toString() is 'Symbol(1)'
        // but elm.setAttribute('slot', Symbol(1)) is an error.
        // the following line also throws same error for symbols
        // Similar for Object.create(null)
        var normalizedSlotName = '' + slotName;
        var vnodes = cmpSlotsMapping[normalizedSlotName] = cmpSlotsMapping[normalizedSlotName] || [];
        ArrayPush$1.call(vnodes, vnode);
      }
      vm.cmpSlots = {
        owner: owner,
        slotAssignments: cmpSlotsMapping
      };
      if (isFalse(vm.isDirty)) {
        // We need to determine if the old allocation is really different from the new one
        // and mark the vm as dirty
        var oldKeys = keys(oldSlotsMapping);
        if (oldKeys.length !== keys(cmpSlotsMapping).length) {
          markComponentAsDirty(vm);
          return;
        }
        for (var _i22 = 0, _len2 = oldKeys.length; _i22 < _len2; _i22 += 1) {
          var key = oldKeys[_i22];
          if (isUndefined$1(cmpSlotsMapping[key]) || oldSlotsMapping[key].length !== cmpSlotsMapping[key].length) {
            markComponentAsDirty(vm);
            return;
          }
          var oldVNodes = oldSlotsMapping[key];
          var _vnodes = cmpSlotsMapping[key];
          for (var j = 0, a = cmpSlotsMapping[key].length; j < a; j += 1) {
            if (oldVNodes[j] !== _vnodes[j]) {
              markComponentAsDirty(vm);
              return;
            }
          }
        }
      }
    }
    // Using a WeakMap instead of a WeakSet because this one works in IE11 :(
    var DynamicChildren = new WeakMap();
    // dynamic children means it was either generated by an iteration in a template
    // or part of an unstable fragment, and will require a more complex diffing algo.
    function markAsDynamicChildren(children) {
      DynamicChildren.set(children, 1);
    }
    function hasDynamicChildren(children) {
      return DynamicChildren.has(children);
    }
    function createKeyToOldIdx(children, beginIdx, endIdx) {
      var map = {};
      // TODO [#1637]: simplify this by assuming that all vnodes has keys
      for (var j = beginIdx; j <= endIdx; ++j) {
        var ch = children[j];
        if (isVNode(ch)) {
          var key = ch.key;
          if (key !== undefined) {
            map[key] = j;
          }
        }
      }
      return map;
    }
    function updateDynamicChildren(oldCh, newCh, parent, renderer) {
      var oldStartIdx = 0;
      var newStartIdx = 0;
      var oldEndIdx = oldCh.length - 1;
      var oldStartVnode = oldCh[0];
      var oldEndVnode = oldCh[oldEndIdx];
      var newChEnd = newCh.length - 1;
      var newEndIdx = newChEnd;
      var newStartVnode = newCh[0];
      var newEndVnode = newCh[newEndIdx];
      var oldKeyToIdx;
      var idxInOld;
      var elmToMove;
      var before;
      var clonedOldCh = false;
      while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
        if (!isVNode(oldStartVnode)) {
          oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left
        } else if (!isVNode(oldEndVnode)) {
          oldEndVnode = oldCh[--oldEndIdx];
        } else if (!isVNode(newStartVnode)) {
          newStartVnode = newCh[++newStartIdx];
        } else if (!isVNode(newEndVnode)) {
          newEndVnode = newCh[--newEndIdx];
        } else if (isSameVnode(oldStartVnode, newStartVnode)) {
          patch(oldStartVnode, newStartVnode, parent, renderer);
          oldStartVnode = oldCh[++oldStartIdx];
          newStartVnode = newCh[++newStartIdx];
        } else if (isSameVnode(oldEndVnode, newEndVnode)) {
          patch(oldEndVnode, newEndVnode, parent, renderer);
          oldEndVnode = oldCh[--oldEndIdx];
          newEndVnode = newCh[--newEndIdx];
        } else if (isSameVnode(oldStartVnode, newEndVnode)) {
          // Vnode moved right
          patch(oldStartVnode, newEndVnode, parent, renderer);
          // In the case of fragments, the `elm` property of a vfragment points to the leading
          // anchor. To determine the next sibling of the whole fragment, we need to use the
          // trailing anchor as the argument to nextSibling():
          // [..., [leading, ...content, trailing], nextSibling, ...]
          var anchor = void 0;
          if (isVFragment(oldEndVnode)) {
            anchor = renderer.nextSibling(oldEndVnode.trailing.elm);
          } else {
            anchor = renderer.nextSibling(oldEndVnode.elm);
          }
          insertFragmentOrNode(oldStartVnode, parent, anchor, renderer);
          oldStartVnode = oldCh[++oldStartIdx];
          newEndVnode = newCh[--newEndIdx];
        } else if (isSameVnode(oldEndVnode, newStartVnode)) {
          // Vnode moved left
          patch(oldEndVnode, newStartVnode, parent, renderer);
          insertFragmentOrNode(newStartVnode, parent, oldStartVnode.elm, renderer);
          oldEndVnode = oldCh[--oldEndIdx];
          newStartVnode = newCh[++newStartIdx];
        } else {
          if (oldKeyToIdx === undefined) {
            oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
          }
          idxInOld = oldKeyToIdx[newStartVnode.key];
          if (isUndefined$1(idxInOld)) {
            // New element
            mount(newStartVnode, parent, renderer, oldStartVnode.elm);
            newStartVnode = newCh[++newStartIdx];
          } else {
            elmToMove = oldCh[idxInOld];
            if (isVNode(elmToMove)) {
              if (elmToMove.sel !== newStartVnode.sel) {
                // New element
                mount(newStartVnode, parent, renderer, oldStartVnode.elm);
              } else {
                patch(elmToMove, newStartVnode, parent, renderer);
                // Delete the old child, but copy the array since it is read-only.
                // The `oldCh` will be GC'ed after `updateDynamicChildren` is complete,
                // so we only care about the `oldCh` object inside this function.
                // To avoid cloning over and over again, we check `clonedOldCh`
                // and only clone once.
                if (!clonedOldCh) {
                  clonedOldCh = true;
                  oldCh = _toConsumableArray(oldCh);
                }
                // We've already cloned at least once, so it's no longer read-only
                oldCh[idxInOld] = undefined;
                insertFragmentOrNode(elmToMove, parent, oldStartVnode.elm, renderer);
              }
            }
            newStartVnode = newCh[++newStartIdx];
          }
        }
      }
      if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {
        if (oldStartIdx > oldEndIdx) {
          // There's some cases in which the sub array of vnodes to be inserted is followed by null(s) and an
          // already processed vnode, in such cases the vnodes to be inserted should be before that processed vnode.
          var _i23 = newEndIdx;
          var n;
          do {
            n = newCh[++_i23];
          } while (!isVNode(n) && _i23 < newChEnd);
          before = isVNode(n) ? n.elm : null;
          mountVNodes(newCh, parent, renderer, before, newStartIdx, newEndIdx + 1);
        } else {
          unmountVNodes(oldCh, parent, renderer, true, oldStartIdx, oldEndIdx + 1);
        }
      }
    }
    function updateStaticChildren(c1, c2, parent, renderer) {
      var c1Length = c1.length;
      var c2Length = c2.length;
      if (c1Length === 0) {
        // the old list is empty, we can directly insert anything new
        mountVNodes(c2, parent, renderer, null);
        return;
      }
      if (c2Length === 0) {
        // the old list is nonempty and the new list is empty so we can directly remove all old nodes
        // this is the case in which the dynamic children of an if-directive should be removed
        unmountVNodes(c1, parent, renderer, true);
        return;
      }
      // if the old list is not empty, the new list MUST have the same
      // amount of nodes, that's why we call this static children
      var anchor = null;
      for (var _i24 = c2Length - 1; _i24 >= 0; _i24 -= 1) {
        var n1 = c1[_i24];
        var n2 = c2[_i24];
        if (n2 !== n1) {
          if (isVNode(n1)) {
            if (isVNode(n2)) {
              if (isSameVnode(n1, n2)) {
                // both vnodes are equivalent, and we just need to patch them
                patch(n1, n2, parent, renderer);
                anchor = n2.elm;
              } else {
                // removing the old vnode since the new one is different
                unmount(n1, parent, renderer, true);
                mount(n2, parent, renderer, anchor);
                anchor = n2.elm;
              }
            } else {
              // removing the old vnode since the new one is null
              unmount(n1, parent, renderer, true);
            }
          } else if (isVNode(n2)) {
            mount(n2, parent, renderer, anchor);
            anchor = n2.elm;
          }
        }
      }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var SymbolIterator = Symbol.iterator;
    function addVNodeToChildLWC(vnode) {
      ArrayPush$1.call(getVMBeingRendered().velements, vnode);
    }
    // [s]coped [s]lot [f]actory
    function ssf(slotName, factory) {
      return {
        type: 6 /* VNodeType.ScopedSlotFragment */,
        factory: factory,
        owner: getVMBeingRendered(),
        elm: undefined,
        sel: undefined,
        key: undefined,
        slotName: slotName
      };
    }
    // [st]atic node
    function st(fragment, key) {
      return {
        type: 4 /* VNodeType.Static */,
        sel: undefined,
        key: key,
        elm: undefined,
        fragment: fragment,
        owner: getVMBeingRendered()
      };
    }
    // [fr]agment node
    function fr(key, children, stable) {
      var leading = t('');
      var trailing = t('');
      return {
        type: 5 /* VNodeType.Fragment */,
        sel: undefined,
        key: key,
        elm: undefined,
        children: [leading].concat(_toConsumableArray(children), [trailing]),
        stable: stable,
        owner: getVMBeingRendered(),
        leading: leading,
        trailing: trailing
      };
    }
    // [h]tml node
    function h(sel, data) {
      var children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EmptyArray;
      var vmBeingRendered = getVMBeingRendered();
      if (process.env.NODE_ENV !== 'production') {
        assert.isTrue(isString(sel), "h() 1st argument sel must be a string.");
        assert.isTrue(isObject(data), "h() 2nd argument data must be an object.");
        assert.isTrue(isArray$1(children), "h() 3rd argument children must be an array.");
        assert.isTrue('key' in data, " <".concat(sel, "> \"key\" attribute is invalid or missing for ").concat(vmBeingRendered, ". Key inside iterator is either undefined or null."));
        // checking reserved internal data properties
        assert.isFalse(data.className && data.classMap, "vnode.data.className and vnode.data.classMap ambiguous declaration.");
        assert.isFalse(data.styleDecls && data.style, "vnode.data.styleDecls and vnode.data.style ambiguous declaration.");
        if (data.style && !isString(data.style)) {
          logError("Invalid 'style' attribute passed to <".concat(sel, "> is ignored. This attribute must be a string value."), vmBeingRendered);
        }
        forEach.call(children, function (childVnode) {
          if (childVnode != null) {
            assert.isTrue('type' in childVnode && 'sel' in childVnode && 'elm' in childVnode && 'key' in childVnode, "".concat(childVnode, " is not a vnode."));
          }
        });
      }
      var key = data.key,
        ref = data.ref;
      var vnode = {
        type: 2 /* VNodeType.Element */,
        sel: sel,
        data: data,
        children: children,
        elm: undefined,
        key: key,
        owner: vmBeingRendered
      };
      if (!isUndefined$1(ref)) {
        setRefVNode(vmBeingRendered, ref, vnode);
      }
      return vnode;
    }
    // [t]ab[i]ndex function
    function ti(value) {
      // if value is greater than 0, we normalize to 0
      // If value is an invalid tabIndex value (null, undefined, string, etc), we let that value pass through
      // If value is less than -1, we don't care
      var shouldNormalize = value > 0 && !(isTrue(value) || isFalse(value));
      if (process.env.NODE_ENV !== 'production') {
        var _vmBeingRendered6 = getVMBeingRendered();
        if (shouldNormalize) {
          logError("Invalid tabindex value `".concat(toString$1(value), "` in template for ").concat(_vmBeingRendered6, ". This attribute must be set to 0 or -1."), _vmBeingRendered6);
        }
      }
      return shouldNormalize ? 0 : value;
    }
    // [s]lot element node
    function s(slotName, data, children, slotset) {
      if (process.env.NODE_ENV !== 'production') {
        assert.isTrue(isString(slotName), "s() 1st argument slotName must be a string.");
        assert.isTrue(isObject(data), "s() 2nd argument data must be an object.");
        assert.isTrue(isArray$1(children), "h() 3rd argument children must be an array.");
      }
      if (!isUndefined$1(slotset) && !isUndefined$1(slotset.slotAssignments) && !isUndefined$1(slotset.slotAssignments[slotName]) && slotset.slotAssignments[slotName].length !== 0) {
        var newChildren = [];
        var slotAssignments = slotset.slotAssignments[slotName];
        for (var _i25 = 0; _i25 < slotAssignments.length; _i25++) {
          var vnode = slotAssignments[_i25];
          if (!isNull(vnode)) {
            var assignedNodeIsScopedSlot = isVScopedSlotFragment(vnode);
            // The only sniff test for a scoped <slot> element is the presence of `slotData`
            var isScopedSlotElement = !isUndefined$1(data.slotData);
            // Check if slot types of parent and child are matching
            if (assignedNodeIsScopedSlot !== isScopedSlotElement) {
              if (process.env.NODE_ENV !== 'production') {
                logError("Mismatched slot types for ".concat(slotName === '' ? '(default)' : slotName, " slot. Both parent and child component must use standard type or scoped type for a given slot."), slotset.owner);
              }
              // Ignore slot content from parent
              continue;
            }
            // If the passed slot content is factory, evaluate it and add the produced vnodes
            if (assignedNodeIsScopedSlot) {
              var vmBeingRenderedInception = getVMBeingRendered();
              // Evaluate in the scope of the slot content's owner
              // if a slotset is provided, there will always be an owner. The only case where owner is
              // undefined is for root components, but root components cannot accept slotted content
              setVMBeingRendered(slotset.owner);
              try {
                ArrayPush$1.call(newChildren, vnode.factory(data.slotData, data.key));
              } finally {
                setVMBeingRendered(vmBeingRenderedInception);
              }
            } else {
              // If the slot content is standard type, the content is static, no additional
              // processing needed on the vnode
              ArrayPush$1.call(newChildren, vnode);
            }
          }
        }
        children = newChildren;
      }
      var vmBeingRendered = getVMBeingRendered();
      var renderMode = vmBeingRendered.renderMode,
        shadowMode = vmBeingRendered.shadowMode;
      if (renderMode === 0 /* RenderMode.Light */) {
        sc(children);
        return children;
      }
      if (shadowMode === 1 /* ShadowMode.Synthetic */) {
        // TODO [#1276]: compiler should give us some sort of indicator when a vnodes collection is dynamic
        sc(children);
      }
      return h('slot', data, children);
    }
    // [c]ustom element node
    function c(sel, Ctor, data) {
      var children = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : EmptyArray;
      var vmBeingRendered = getVMBeingRendered();
      if (process.env.NODE_ENV !== 'production') {
        assert.isTrue(isString(sel), "c() 1st argument sel must be a string.");
        assert.isTrue(isFunction$1(Ctor), "c() 2nd argument Ctor must be a function.");
        assert.isTrue(isObject(data), "c() 3nd argument data must be an object.");
        assert.isTrue(arguments.length === 3 || isArray$1(children), "c() 4nd argument data must be an array.");
        // checking reserved internal data properties
        assert.isFalse(data.className && data.classMap, "vnode.data.className and vnode.data.classMap ambiguous declaration.");
        assert.isFalse(data.styleDecls && data.style, "vnode.data.styleDecls and vnode.data.style ambiguous declaration.");
        if (data.style && !isString(data.style)) {
          logError("Invalid 'style' attribute passed to <".concat(sel, "> is ignored. This attribute must be a string value."), vmBeingRendered);
        }
        if (arguments.length === 4) {
          forEach.call(children, function (childVnode) {
            if (childVnode != null) {
              assert.isTrue('type' in childVnode && 'sel' in childVnode && 'elm' in childVnode && 'key' in childVnode, "".concat(childVnode, " is not a vnode."));
            }
          });
        }
      }
      var key = data.key,
        ref = data.ref;
      var elm, aChildren, vm;
      var vnode = {
        type: 3 /* VNodeType.CustomElement */,
        sel: sel,
        data: data,
        children: children,
        elm: elm,
        key: key,
        ctor: Ctor,
        owner: vmBeingRendered,
        mode: 'open',
        aChildren: aChildren,
        vm: vm
      };
      addVNodeToChildLWC(vnode);
      if (!isUndefined$1(ref)) {
        setRefVNode(vmBeingRendered, ref, vnode);
      }
      return vnode;
    }
    // [i]terable node
    function i(iterable, factory) {
      var list = [];
      // TODO [#1276]: compiler should give us some sort of indicator when a vnodes collection is dynamic
      sc(list);
      var vmBeingRendered = getVMBeingRendered();
      if (isUndefined$1(iterable) || iterable === null) {
        if (process.env.NODE_ENV !== 'production') {
          logError("Invalid template iteration for value \"".concat(toString$1(iterable), "\" in ").concat(vmBeingRendered, ". It must be an Array or an iterable Object."), vmBeingRendered);
        }
        return list;
      }
      if (process.env.NODE_ENV !== 'production') {
        assert.isFalse(isUndefined$1(iterable[SymbolIterator]), "Invalid template iteration for value `".concat(toString$1(iterable), "` in ").concat(vmBeingRendered, ". It must be an array-like object and not `null` nor `undefined`."));
      }
      var iterator = iterable[SymbolIterator]();
      if (process.env.NODE_ENV !== 'production') {
        assert.isTrue(iterator && isFunction$1(iterator.next), "Invalid iterator function for \"".concat(toString$1(iterable), "\" in ").concat(vmBeingRendered, "."));
      }
      var next = iterator.next();
      var j = 0;
      var _next = next,
        value = _next.value,
        last = _next.done;
      var keyMap;
      var iterationError;
      if (process.env.NODE_ENV !== 'production') {
        keyMap = create(null);
      }
      while (last === false) {
        // implementing a look-back-approach because we need to know if the element is the last
        next = iterator.next();
        last = next.done;
        // template factory logic based on the previous collected value
        var vnode = factory(value, j, j === 0, last === true);
        if (isArray$1(vnode)) {
          ArrayPush$1.apply(list, vnode);
        } else {
          ArrayPush$1.call(list, vnode);
        }
        if (process.env.NODE_ENV !== 'production') {
          var vnodes = isArray$1(vnode) ? vnode : [vnode];
          forEach.call(vnodes, function (childVnode) {
            if (!isNull(childVnode) && isObject(childVnode) && !isUndefined$1(childVnode.sel)) {
              var key = childVnode.key;
              if (isString(key) || isNumber(key)) {
                if (keyMap[key] === 1 && isUndefined$1(iterationError)) {
                  iterationError = "Duplicated \"key\" attribute value for \"<".concat(childVnode.sel, ">\" in ").concat(vmBeingRendered, " for item number ").concat(j, ". A key with value \"").concat(childVnode.key, "\" appears more than once in the iteration. Key values must be unique numbers or strings.");
                }
                keyMap[key] = 1;
              } else if (isUndefined$1(iterationError)) {
                iterationError = "Invalid \"key\" attribute value in \"<".concat(childVnode.sel, ">\" in ").concat(vmBeingRendered, " for item number ").concat(j, ". Set a unique \"key\" value on all iterated child elements.");
              }
            }
          });
        }
        // preparing next value
        j += 1;
        value = next.value;
      }
      if (process.env.NODE_ENV !== 'production') {
        if (!isUndefined$1(iterationError)) {
          logError(iterationError, vmBeingRendered);
        }
      }
      return list;
    }
    /**
     * [f]lattening
     */
    function f(items) {
      if (process.env.NODE_ENV !== 'production') {
        assert.isTrue(isArray$1(items), 'flattening api can only work with arrays.');
      }
      var len = items.length;
      var flattened = [];
      // TODO [#1276]: compiler should give us some sort of indicator when a vnodes collection is dynamic
      sc(flattened);
      for (var j = 0; j < len; j += 1) {
        var item = items[j];
        if (isArray$1(item)) {
          ArrayPush$1.apply(flattened, item);
        } else {
          ArrayPush$1.call(flattened, item);
        }
      }
      return flattened;
    }
    // [t]ext node
    function t(text) {
      var sel, key, elm;
      return {
        type: 0 /* VNodeType.Text */,
        sel: sel,
        text: text,
        elm: elm,
        key: key,
        owner: getVMBeingRendered()
      };
    }
    // [co]mment node
    function co(text) {
      var sel, elm;
      return {
        type: 1 /* VNodeType.Comment */,
        sel: sel,
        text: text,
        elm: elm,
        key: 'c',
        owner: getVMBeingRendered()
      };
    }
    // [d]ynamic text
    function d(value) {
      return value == null ? '' : String(value);
    }
    // [b]ind function
    function b(fn) {
      var vmBeingRendered = getVMBeingRendered();
      if (isNull(vmBeingRendered)) {
        throw new Error();
      }
      var vm = vmBeingRendered;
      return function (event) {
        invokeEventListener(vm, fn, vm.component, event);
      };
    }
    // [k]ey function
    function k(compilerKey, obj) {
      switch (_typeof(obj)) {
        case 'number':
        case 'string':
          return compilerKey + ':' + obj;
        case 'object':
          if (process.env.NODE_ENV !== 'production') {
            logError("Invalid key value \"".concat(obj, "\" in ").concat(getVMBeingRendered(), ". Key must be a string or number."));
          }
      }
    }
    // [g]lobal [id] function
    function gid(id) {
      var vmBeingRendered = getVMBeingRendered();
      if (isUndefined$1(id) || id === '') {
        if (process.env.NODE_ENV !== 'production') {
          logError("Invalid id value \"".concat(id, "\". The id attribute must contain a non-empty string."), vmBeingRendered);
        }
        return id;
      }
      // We remove attributes when they are assigned a value of null
      if (isNull(id)) {
        return null;
      }
      var idx = vmBeingRendered.idx,
        shadowMode = vmBeingRendered.shadowMode;
      if (shadowMode === 1 /* ShadowMode.Synthetic */) {
        return StringReplace.call(id, /\S+/g, function (id) {
          return "".concat(id, "-").concat(idx);
        });
      }
      return id;
    }
    // [f]ragment [id] function
    function fid(url) {
      var vmBeingRendered = getVMBeingRendered();
      if (isUndefined$1(url) || url === '') {
        if (process.env.NODE_ENV !== 'production') {
          if (isUndefined$1(url)) {
            logError("Undefined url value for \"href\" or \"xlink:href\" attribute. Expected a non-empty string.", vmBeingRendered);
          }
        }
        return url;
      }
      // We remove attributes when they are assigned a value of null
      if (isNull(url)) {
        return null;
      }
      var idx = vmBeingRendered.idx,
        shadowMode = vmBeingRendered.shadowMode;
      // Apply transformation only for fragment-only-urls, and only in shadow DOM
      if (shadowMode === 1 /* ShadowMode.Synthetic */ && /^#/.test(url)) {
        return "".concat(url, "-").concat(idx);
      }
      return url;
    }
    /**
     * [ddc] - create a (deprecated) dynamic component via `<x-foo lwc:dynamic={Ctor}>`
     *
     * TODO [#3331]: remove usage of lwc:dynamic in 246
     */
    function ddc(sel, Ctor, data) {
      var children = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : EmptyArray;
      if (process.env.NODE_ENV !== 'production') {
        assert.isTrue(isString(sel), "dc() 1st argument sel must be a string.");
        assert.isTrue(isObject(data), "dc() 3nd argument data must be an object.");
        assert.isTrue(arguments.length === 3 || isArray$1(children), "dc() 4nd argument data must be an array.");
      }
      // null or undefined values should produce a null value in the VNodes
      if (isNull(Ctor) || isUndefined$1(Ctor)) {
        return null;
      }
      if (!isComponentConstructor(Ctor)) {
        throw new Error("Invalid LWC Constructor ".concat(toString$1(Ctor), " for custom element <").concat(sel, ">."));
      }
      return c(sel, Ctor, data, children);
    }
    /**
     * [dc] - create a dynamic component via `<lwc:component lwc:is={Ctor}>`
     */
    function dc(Ctor, data) {
      var children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EmptyArray;
      if (process.env.NODE_ENV !== 'production') {
        assert.isTrue(isObject(data), "dc() 2nd argument data must be an object.");
        assert.isTrue(arguments.length === 3 || isArray$1(children), "dc() 3rd argument data must be an array.");
      }
      // Null or undefined values should produce a null value in the VNodes.
      // This is the only value at compile time as the constructor will not be known.
      if (isNull(Ctor) || isUndefined$1(Ctor)) {
        return null;
      }
      if (!isComponentConstructor(Ctor)) {
        throw new Error("Invalid constructor ".concat(toString$1(Ctor), " is not a LightningElement constructor."));
      }
      // Look up the dynamic component's name at runtime once the constructor is available.
      // This information is only known at runtime and is stored as part of registerComponent.
      var sel = getComponentRegisteredName(Ctor);
      if (isUndefined$1(sel) || sel === '') {
        throw new Error("Invalid LWC constructor ".concat(toString$1(Ctor), " does not have a registered name"));
      }
      return c(sel, Ctor, data, children);
    }
    /**
     * slow children collection marking mechanism. this API allows the compiler to signal
     * to the engine that a particular collection of children must be diffed using the slow
     * algo based on keys due to the nature of the list. E.g.:
     *
     *   - slot element's children: the content of the slot has to be dynamic when in synthetic
     *                              shadow mode because the `vnode.children` might be the slotted
     *                              content vs default content, in which case the size and the
     *                              keys are not matching.
     *   - children that contain dynamic components
     *   - children that are produced by iteration
     *
     */
    function sc(vnodes) {
      if (process.env.NODE_ENV !== 'production') {
        assert.isTrue(isArray$1(vnodes), 'sc() api can only work with arrays.');
      }
      // We have to mark the vnodes collection as dynamic so we can later on
      // choose to use the snabbdom virtual dom diffing algo instead of our
      // static dummy algo.
      markAsDynamicChildren(vnodes);
      return vnodes;
    }
    /**
     * EXPERIMENTAL: This function acts like a hook for Lightning Locker Service and other similar
     * libraries to sanitize HTML content. This hook process the content passed via the template to
     * lwc:inner-html directive.
     * It is meant to be overridden with setSanitizeHtmlContentHook, it throws an error by default.
     */
    var sanitizeHtmlContentHook = function sanitizeHtmlContentHook() {
      // locker-service patches this function during runtime to sanitize HTML content.
      throw new Error('sanitizeHtmlContent hook must be implemented.');
    };
    /**
     * Sets the sanitizeHtmlContentHook.
     */
    function setSanitizeHtmlContentHook(newHookImpl) {
      sanitizeHtmlContentHook = newHookImpl;
    }
    // [s]anitize [h]tml [c]ontent
    function shc(content) {
      return sanitizeHtmlContentHook(content);
    }
    var api = freeze({
      s: s,
      h: h,
      c: c,
      i: i,
      f: f,
      t: t,
      d: d,
      b: b,
      k: k,
      co: co,
      dc: dc,
      fr: fr,
      ti: ti,
      st: st,
      gid: gid,
      fid: fid,
      shc: shc,
      ssf: ssf,
      ddc: ddc
    });

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var operationIdNameMapping = ['constructor', 'render', 'patch', 'connectedCallback', 'renderedCallback', 'disconnectedCallback', 'errorCallback', 'lwc-hydrate', 'lwc-rehydrate'];
    // Even if all the browser the engine supports implements the UserTiming API, we need to guard the measure APIs.
    // JSDom (used in Jest) for example doesn't implement the UserTiming APIs.
    var isUserTimingSupported = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';
    var start = !isUserTimingSupported ? noop : function (markName) {
      performance.mark(markName);
    };
    var end = !isUserTimingSupported ? noop : function (measureName, markName) {
      performance.measure(measureName, markName);
      // Clear the created marks and measure to avoid filling the performance entries buffer.
      // Note: Even if the entries get deleted, existing PerformanceObservers preserve a copy of those entries.
      performance.clearMarks(markName);
      performance.clearMeasures(measureName);
    };
    function getOperationName(opId) {
      return operationIdNameMapping[opId];
    }
    function getMeasureName(opId, vm) {
      return "".concat(getComponentTag(vm), " - ").concat(getOperationName(opId));
    }
    function getMarkName(opId, vm) {
      // Adding the VM idx to the mark name creates a unique mark name component instance. This is necessary to produce
      // the right measures for components that are recursive.
      return "".concat(getMeasureName(opId, vm), " - ").concat(vm.idx);
    }
    /** Indicates if operations should be logged via the User Timing API. */
    var isMeasureEnabled = process.env.NODE_ENV !== 'production';
    /** Indicates if operations should be logged by the profiler. */
    var isProfilerEnabled = false;
    /** The currently assigned profiler dispatcher. */
    var currentDispatcher = noop;
    var profilerControl = {
      enableProfiler: function enableProfiler() {
        isProfilerEnabled = true;
      },
      disableProfiler: function disableProfiler() {
        isProfilerEnabled = false;
      },
      attachDispatcher: function attachDispatcher(dispatcher) {
        currentDispatcher = dispatcher;
        this.enableProfiler();
      },
      detachDispatcher: function detachDispatcher() {
        var dispatcher = currentDispatcher;
        currentDispatcher = noop;
        this.disableProfiler();
        return dispatcher;
      }
    };
    function logOperationStart(opId, vm) {
      if (isMeasureEnabled) {
        var markName = getMarkName(opId, vm);
        start(markName);
      }
      if (isProfilerEnabled) {
        currentDispatcher(opId, 0 /* Phase.Start */, vm.tagName, vm.idx, vm.renderMode, vm.shadowMode);
      }
    }
    function logOperationEnd(opId, vm) {
      if (isMeasureEnabled) {
        var markName = getMarkName(opId, vm);
        var measureName = getMeasureName(opId, vm);
        end(measureName, markName);
      }
      if (isProfilerEnabled) {
        currentDispatcher(opId, 1 /* Phase.Stop */, vm.tagName, vm.idx, vm.renderMode, vm.shadowMode);
      }
    }
    function logGlobalOperationStart(opId, vm) {
      if (isMeasureEnabled) {
        var opName = getOperationName(opId);
        var markName = isUndefined$1(vm) ? opName : getMarkName(opId, vm);
        start(markName);
      }
      if (isProfilerEnabled) {
        currentDispatcher(opId, 0 /* Phase.Start */, vm === null || vm === void 0 ? void 0 : vm.tagName, vm === null || vm === void 0 ? void 0 : vm.idx, vm === null || vm === void 0 ? void 0 : vm.renderMode, vm === null || vm === void 0 ? void 0 : vm.shadowMode);
      }
    }
    function logGlobalOperationEnd(opId, vm) {
      if (isMeasureEnabled) {
        var opName = getOperationName(opId);
        var markName = isUndefined$1(vm) ? opName : getMarkName(opId, vm);
        end(opName, markName);
      }
      if (isProfilerEnabled) {
        currentDispatcher(opId, 1 /* Phase.Stop */, vm === null || vm === void 0 ? void 0 : vm.tagName, vm === null || vm === void 0 ? void 0 : vm.idx, vm === null || vm === void 0 ? void 0 : vm.renderMode, vm === null || vm === void 0 ? void 0 : vm.shadowMode);
      }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var isUpdatingTemplate = false;
    var vmBeingRendered = null;
    function getVMBeingRendered() {
      return vmBeingRendered;
    }
    function setVMBeingRendered(vm) {
      vmBeingRendered = vm;
    }
    function validateSlots(vm) {
      assertNotProd(); // this method should never leak to prod
      var cmpSlots = vm.cmpSlots;
      for (var slotName in cmpSlots.slotAssignments) {
        // eslint-disable-next-line @lwc/lwc-internal/no-production-assert
        assert.isTrue(isArray$1(cmpSlots.slotAssignments[slotName]), "Slots can only be set to an array, instead received ".concat(toString$1(cmpSlots.slotAssignments[slotName]), " for slot \"").concat(slotName, "\" in ").concat(vm, "."));
      }
    }
    function validateLightDomTemplate(template, vm) {
      assertNotProd(); // should never leak to prod mode
      if (template === defaultEmptyTemplate) {
        return;
      }
      if (vm.renderMode === 0 /* RenderMode.Light */) {
        if (template.renderMode !== 'light') {
          logError("Light DOM components can't render shadow DOM templates. Add an 'lwc:render-mode=\"light\"' directive to the root template tag of ".concat(getComponentTag(vm), "."));
        }
      } else {
        if (!isUndefined$1(template.renderMode)) {
          logError("Shadow DOM components template can't render light DOM templates. Either remove the 'lwc:render-mode' directive from ".concat(getComponentTag(vm), " or set it to 'lwc:render-mode=\"shadow\""));
        }
      }
    }
    function buildParseFragmentFn(createFragmentFn) {
      return function (strings) {
        for (var _len3 = arguments.length, keys = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          keys[_key3 - 1] = arguments[_key3];
        }
        var cache = create(null);
        return function () {
          var _getVMBeingRendered = getVMBeingRendered(),
            _getVMBeingRendered$c = _getVMBeingRendered.context,
            hasScopedStyles = _getVMBeingRendered$c.hasScopedStyles,
            stylesheetToken = _getVMBeingRendered$c.stylesheetToken,
            shadowMode = _getVMBeingRendered.shadowMode,
            renderer = _getVMBeingRendered.renderer;
          var hasStyleToken = !isUndefined$1(stylesheetToken);
          var isSyntheticShadow = shadowMode === 1 /* ShadowMode.Synthetic */;
          var cacheKey = 0;
          if (hasStyleToken && hasScopedStyles) {
            cacheKey |= 1 /* FragmentCache.HAS_SCOPED_STYLE */;
          }

          if (hasStyleToken && isSyntheticShadow) {
            cacheKey |= 2 /* FragmentCache.SHADOW_MODE_SYNTHETIC */;
          }

          if (!isUndefined$1(cache[cacheKey])) {
            return cache[cacheKey];
          }
          var classToken = hasScopedStyles && hasStyleToken ? ' ' + stylesheetToken : '';
          var classAttrToken = hasScopedStyles && hasStyleToken ? " class=\"".concat(stylesheetToken, "\"") : '';
          var attrToken = hasStyleToken && isSyntheticShadow ? ' ' + stylesheetToken : '';
          var htmlFragment = '';
          for (var _i26 = 0, n = keys.length; _i26 < n; _i26++) {
            switch (keys[_i26]) {
              case 0:
                // styleToken in existing class attr
                htmlFragment += strings[_i26] + classToken;
                break;
              case 1:
                // styleToken for added class attr
                htmlFragment += strings[_i26] + classAttrToken;
                break;
              case 2:
                // styleToken as attr
                htmlFragment += strings[_i26] + attrToken;
                break;
              case 3:
                // ${1}${2}
                htmlFragment += strings[_i26] + classAttrToken + attrToken;
                break;
            }
          }
          htmlFragment += strings[strings.length - 1];
          cache[cacheKey] = createFragmentFn(htmlFragment, renderer);
          return cache[cacheKey];
        };
      };
    }
    // Note: at the moment this code executes, we don't have a renderer yet.
    var parseFragment = buildParseFragmentFn(function (html, renderer) {
      var createFragment = renderer.createFragment;
      return createFragment(html);
    });
    var parseSVGFragment = buildParseFragmentFn(function (html, renderer) {
      var createFragment = renderer.createFragment,
        getFirstChild = renderer.getFirstChild;
      var fragment = createFragment('<svg>' + html + '</svg>');
      return getFirstChild(fragment);
    });
    function evaluateTemplate(vm, html) {
      if (process.env.NODE_ENV !== 'production') {
        assert.isTrue(isFunction$1(html), "evaluateTemplate() second argument must be an imported template instead of ".concat(toString$1(html)));
        // in dev-mode, we support hot swapping of templates, which means that
        // the component instance might be attempting to use an old version of
        // the template, while internally, we have a replacement for it.
        html = getTemplateOrSwappedTemplate(html);
      }
      var isUpdatingTemplateInception = isUpdatingTemplate;
      var vmOfTemplateBeingUpdatedInception = vmBeingRendered;
      var vnodes = [];
      runWithBoundaryProtection(vm, vm.owner, function () {
        // pre
        vmBeingRendered = vm;
        logOperationStart(1 /* OperationId.Render */, vm);
      }, function () {
        // job
        var component = vm.component,
          context = vm.context,
          cmpSlots = vm.cmpSlots,
          cmpTemplate = vm.cmpTemplate,
          tro = vm.tro;
        tro.observe(function () {
          // Reset the cache memoizer for template when needed.
          if (html !== cmpTemplate) {
            if (process.env.NODE_ENV !== 'production') {
              validateLightDomTemplate(html, vm);
            }
            // Perf opt: do not reset the shadow root during the first rendering (there is
            // nothing to reset).
            if (!isNull(cmpTemplate)) {
              // It is important to reset the content to avoid reusing similar elements
              // generated from a different template, because they could have similar IDs,
              // and snabbdom just rely on the IDs.
              resetComponentRoot(vm);
            }
            // Check that the template was built by the compiler.
            if (!isTemplateRegistered(html)) {
              throw new TypeError("Invalid template returned by the render() method on ".concat(vm, ". It must return an imported template (e.g.: `import html from \"./").concat(vm.def.name, ".html\"`), instead, it has returned: ").concat(toString$1(html), "."));
            }
            vm.cmpTemplate = html;
            // Create a brand new template cache for the swapped templated.
            context.tplCache = create(null);
            // Set the computeHasScopedStyles property in the context, to avoid recomputing it repeatedly.
            context.hasScopedStyles = computeHasScopedStyles(html, vm);
            // Update the scoping token on the host element.
            updateStylesheetToken(vm, html);
            // Evaluate, create stylesheet and cache the produced VNode for future
            // re-rendering.
            var stylesheetsContent = getStylesheetsContent(vm, html);
            context.styleVNodes = stylesheetsContent.length === 0 ? null : createStylesheet(vm, stylesheetsContent);
          }
          if (process.env.NODE_ENV !== 'production') {
            // validating slots in every rendering since the allocated content might change over time
            validateSlots(vm);
            // add the VM to the list of host VMs that can be re-rendered if html is swapped
            setActiveVM(vm);
          }
          // reset the refs; they will be set during the tmpl() instantiation
          vm.refVNodes = html.hasRefs ? create(null) : null;
          // right before producing the vnodes, we clear up all internal references
          // to custom elements from the template.
          vm.velements = [];
          // Set the global flag that template is being updated
          isUpdatingTemplate = true;
          vnodes = html.call(undefined, api, component, cmpSlots, context.tplCache);
          var styleVNodes = context.styleVNodes;
          if (!isNull(styleVNodes)) {
            ArrayUnshift.apply(vnodes, styleVNodes);
          }
        });
      }, function () {
        // post
        isUpdatingTemplate = isUpdatingTemplateInception;
        vmBeingRendered = vmOfTemplateBeingUpdatedInception;
        logOperationEnd(1 /* OperationId.Render */, vm);
      });
      if (process.env.NODE_ENV !== 'production') {
        if (!isArray$1(vnodes)) {
          logError("Compiler should produce html functions that always return an array.");
        }
      }
      return vnodes;
    }
    function computeHasScopedStylesInStylesheets(stylesheets) {
      if (hasStyles(stylesheets)) {
        for (var _i27 = 0; _i27 < stylesheets.length; _i27++) {
          if (isTrue(stylesheets[_i27][KEY__SCOPED_CSS])) {
            return true;
          }
        }
      }
      return false;
    }
    function computeHasScopedStyles(template, vm) {
      var stylesheets = template.stylesheets;
      var vmStylesheets = !isUndefined$1(vm) ? vm.stylesheets : null;
      return computeHasScopedStylesInStylesheets(stylesheets) || computeHasScopedStylesInStylesheets(vmStylesheets);
    }
    function hasStyles(stylesheets) {
      return !isUndefined$1(stylesheets) && !isNull(stylesheets) && stylesheets.length > 0;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var isInvokingRender = false;
    var vmBeingConstructed = null;
    function isBeingConstructed(vm) {
      return vmBeingConstructed === vm;
    }
    function invokeComponentCallback(vm, fn, args) {
      var component = vm.component,
        callHook = vm.callHook,
        owner = vm.owner;
      runWithBoundaryProtection(vm, owner, noop, function () {
        callHook(component, fn, args);
      }, noop);
    }
    function invokeComponentConstructor(vm, Ctor) {
      var vmBeingConstructedInception = vmBeingConstructed;
      var error;
      logOperationStart(0 /* OperationId.Constructor */, vm);
      vmBeingConstructed = vm;
      /**
       * Constructors don't need to be wrapped with a boundary because for root elements
       * it should throw, while elements from template are already wrapped by a boundary
       * associated to the diffing algo.
       */
      try {
        // job
        var result = new Ctor();
        // Check indirectly if the constructor result is an instance of LightningElement. Using
        // the "instanceof" operator would not work here since Locker Service provides its own
        // implementation of LightningElement, so we indirectly check if the base constructor is
        // invoked by accessing the component on the vm.
        if (vmBeingConstructed.component !== result) {
          throw new TypeError('Invalid component constructor, the class should extend LightningElement.');
        }
      } catch (e) {
        error = Object(e);
      } finally {
        logOperationEnd(0 /* OperationId.Constructor */, vm);
        vmBeingConstructed = vmBeingConstructedInception;
        if (!isUndefined$1(error)) {
          addErrorComponentStack(vm, error);
          // re-throwing the original error annotated after restoring the context
          throw error; // eslint-disable-line no-unsafe-finally
        }
      }
    }

    function invokeComponentRenderMethod(vm) {
      var render = vm.def.render,
        callHook = vm.callHook,
        component = vm.component,
        owner = vm.owner;
      var isRenderBeingInvokedInception = isInvokingRender;
      var vmBeingRenderedInception = getVMBeingRendered();
      var html;
      var renderInvocationSuccessful = false;
      runWithBoundaryProtection(vm, owner, function () {
        // pre
        isInvokingRender = true;
        setVMBeingRendered(vm);
      }, function () {
        // job
        vm.tro.observe(function () {
          html = callHook(component, render);
          renderInvocationSuccessful = true;
        });
      }, function () {
        // post
        isInvokingRender = isRenderBeingInvokedInception;
        setVMBeingRendered(vmBeingRenderedInception);
      });
      // If render() invocation failed, process errorCallback in boundary and return an empty template
      return renderInvocationSuccessful ? evaluateTemplate(vm, html) : [];
    }
    function invokeEventListener(vm, fn, thisValue, event) {
      var callHook = vm.callHook,
        owner = vm.owner;
      runWithBoundaryProtection(vm, owner, noop, function () {
        // job
        if (process.env.NODE_ENV !== 'production') {
          assert.isTrue(isFunction$1(fn), "Invalid event handler for event '".concat(event.type, "' on ").concat(vm, "."));
        }
        callHook(thisValue, fn, [event]);
      }, noop);
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var registeredComponentMap = new Map();
    /**
     * INTERNAL: This function can only be invoked by compiled code. The compiler
     * will prevent this function from being imported by userland code.
     */
    function registerComponent(
    // We typically expect a LightningElementConstructor, but technically you can call this with anything
    Ctor, metadata) {
      if (isFunction$1(Ctor)) {
        if (process.env.NODE_ENV !== 'production') {
          // There is no point in running this in production, because the version mismatch check relies
          // on code comments which are stripped out in production by minifiers
          checkVersionMismatch(Ctor, 'component');
        }
        // TODO [#3331]: add validation to check the value of metadata.sel is not an empty string.
        registeredComponentMap.set(Ctor, metadata);
      }
      // chaining this method as a way to wrap existing assignment of component constructor easily,
      // without too much transformation
      return Ctor;
    }
    function getComponentRegisteredTemplate(Ctor) {
      var _a;
      return (_a = registeredComponentMap.get(Ctor)) === null || _a === void 0 ? void 0 : _a.tmpl;
    }
    function getComponentRegisteredName(Ctor) {
      var _a;
      return (_a = registeredComponentMap.get(Ctor)) === null || _a === void 0 ? void 0 : _a.sel;
    }
    function getTemplateReactiveObserver(vm) {
      return createReactiveObserver(function () {
        var isDirty = vm.isDirty;
        if (isFalse(isDirty)) {
          markComponentAsDirty(vm);
          scheduleRehydration(vm);
        }
      });
    }
    function renderComponent(vm) {
      if (process.env.NODE_ENV !== 'production') {
        assert.invariant(vm.isDirty, "".concat(vm, " is not dirty."));
      }
      vm.tro.reset();
      var vnodes = invokeComponentRenderMethod(vm);
      vm.isDirty = false;
      vm.isScheduled = false;
      return vnodes;
    }
    function markComponentAsDirty(vm) {
      if (process.env.NODE_ENV !== 'production') {
        var _vmBeingRendered7 = getVMBeingRendered();
        assert.isFalse(vm.isDirty, "markComponentAsDirty() for ".concat(vm, " should not be called when the component is already dirty."));
        assert.isFalse(isInvokingRender, "markComponentAsDirty() for ".concat(vm, " cannot be called during rendering of ").concat(_vmBeingRendered7, "."));
        assert.isFalse(isUpdatingTemplate, "markComponentAsDirty() for ".concat(vm, " cannot be called while updating template of ").concat(_vmBeingRendered7, "."));
      }
      vm.isDirty = true;
    }
    var cmpEventListenerMap = new WeakMap();
    function getWrappedComponentsListener(vm, listener) {
      if (!isFunction$1(listener)) {
        throw new TypeError('Expected an EventListener but received ' + _typeof(listener)); // avoiding problems with non-valid listeners
      }

      var wrappedListener = cmpEventListenerMap.get(listener);
      if (isUndefined$1(wrappedListener)) {
        wrappedListener = function wrappedListener(event) {
          invokeEventListener(vm, listener, undefined, event);
        };
        cmpEventListenerMap.set(listener, wrappedListener);
      }
      return wrappedListener;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var Services = create(null);
    var hooks = ['rendered', 'connected', 'disconnected'];
    /**
     * EXPERIMENTAL: This function allows for the registration of "services"
     * in LWC by exposing hooks into the component life-cycle. This API is
     * subject to change or being removed.
     */
    function register(service) {
      if (process.env.NODE_ENV !== 'production') {
        assert.isTrue(isObject(service), "Invalid service declaration, ".concat(service, ": service must be an object"));
      }
      for (var _i28 = 0; _i28 < hooks.length; ++_i28) {
        var hookName = hooks[_i28];
        if (hookName in service) {
          var l = Services[hookName];
          if (isUndefined$1(l)) {
            Services[hookName] = l = [];
          }
          ArrayPush$1.call(l, service[hookName]);
        }
      }
    }
    function invokeServiceHook(vm, cbs) {
      if (process.env.NODE_ENV !== 'production') {
        assert.isTrue(isArray$1(cbs) && cbs.length > 0, "Optimize invokeServiceHook() to be invoked only when needed");
      }
      var component = vm.component,
        def = vm.def,
        context = vm.context;
      for (var _i29 = 0, len = cbs.length; _i29 < len; ++_i29) {
        cbs[_i29].call(undefined, component, {}, def, context);
      }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var idx = 0;
    /** The internal slot used to associate different objects the engine manipulates with the VM */
    var ViewModelReflection = new WeakMap();
    function callHook(cmp, fn) {
      var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      return fn.apply(cmp, args);
    }
    function setHook(cmp, prop, newValue) {
      cmp[prop] = newValue;
    }
    function getHook(cmp, prop) {
      return cmp[prop];
    }
    function rerenderVM(vm) {
      rehydrate(vm);
    }
    function connectRootElement(elm) {
      var vm = getAssociatedVM(elm);
      logGlobalOperationStart(7 /* OperationId.GlobalHydrate */, vm);
      // Usually means moving the element from one place to another, which is observable via
      // life-cycle hooks.
      if (vm.state === 1 /* VMState.connected */) {
        disconnectRootElement(elm);
      }
      runConnectedCallback(vm);
      rehydrate(vm);
      logGlobalOperationEnd(7 /* OperationId.GlobalHydrate */, vm);
    }
    function disconnectRootElement(elm) {
      var vm = getAssociatedVM(elm);
      resetComponentStateWhenRemoved(vm);
    }
    function appendVM(vm) {
      rehydrate(vm);
    }
    // just in case the component comes back, with this we guarantee re-rendering it
    // while preventing any attempt to rehydration until after reinsertion.
    function resetComponentStateWhenRemoved(vm) {
      var state = vm.state;
      if (state !== 2 /* VMState.disconnected */) {
        var tro = vm.tro;
        // Making sure that any observing record will not trigger the rehydrated on this vm
        tro.reset();
        runDisconnectedCallback(vm);
        // Spec: https://dom.spec.whatwg.org/#concept-node-remove (step 14-15)
        runChildNodesDisconnectedCallback(vm);
        runLightChildNodesDisconnectedCallback(vm);
      }
    }
    // this method is triggered by the diffing algo only when a vnode from the
    // old vnode.children is removed from the DOM.
    function removeVM(vm) {
      if (process.env.NODE_ENV !== 'production') {
        assert.isTrue(vm.state === 1 /* VMState.connected */ || vm.state === 2 /* VMState.disconnected */, "".concat(vm, " must have been connected."));
      }
      resetComponentStateWhenRemoved(vm);
    }
    function getNearestShadowAncestor(vm) {
      var ancestor = vm.owner;
      while (!isNull(ancestor) && ancestor.renderMode === 0 /* RenderMode.Light */) {
        ancestor = ancestor.owner;
      }
      return ancestor;
    }
    function createVM(elm, ctor, renderer, options) {
      var mode = options.mode,
        owner = options.owner,
        tagName = options.tagName,
        hydrated = options.hydrated;
      var def = getComponentInternalDef(ctor);
      var vm = {
        elm: elm,
        def: def,
        idx: idx++,
        state: 0 /* VMState.created */,
        isScheduled: false,
        isDirty: true,
        tagName: tagName,
        mode: mode,
        owner: owner,
        refVNodes: null,
        children: EmptyArray,
        aChildren: EmptyArray,
        velements: EmptyArray,
        cmpProps: create(null),
        cmpFields: create(null),
        cmpSlots: {
          slotAssignments: create(null)
        },
        cmpTemplate: null,
        hydrated: Boolean(hydrated),
        renderMode: def.renderMode,
        context: {
          stylesheetToken: undefined,
          hasTokenInClass: undefined,
          hasTokenInAttribute: undefined,
          hasScopedStyles: undefined,
          styleVNodes: null,
          tplCache: EmptyObject,
          wiredConnecting: EmptyArray,
          wiredDisconnecting: EmptyArray
        },
        // Properties set right after VM creation.
        tro: null,
        shadowMode: null,
        stylesheets: null,
        // Properties set by the LightningElement constructor.
        component: null,
        shadowRoot: null,
        renderRoot: null,
        callHook: callHook,
        setHook: setHook,
        getHook: getHook,
        renderer: renderer
      };
      if (process.env.NODE_ENV !== 'production') {
        vm.debugInfo = create(null);
      }
      vm.stylesheets = computeStylesheets(vm, def.ctor);
      vm.shadowMode = computeShadowMode(vm, renderer);
      vm.tro = getTemplateReactiveObserver(vm);
      if (process.env.NODE_ENV !== 'production') {
        vm.toString = function () {
          return "[object:vm ".concat(def.name, " (").concat(vm.idx, ")]");
        };
        if (lwcRuntimeFlags.ENABLE_FORCE_NATIVE_SHADOW_MODE_FOR_TEST) {
          vm.shadowMode = 0 /* ShadowMode.Native */;
        }
      }
      // Create component instance associated to the vm and the element.
      invokeComponentConstructor(vm, def.ctor);
      // Initializing the wire decorator per instance only when really needed
      if (hasWireAdapters(vm)) {
        installWireAdapters(vm);
      }
      return vm;
    }
    function validateComponentStylesheets(vm, stylesheets) {
      var valid = true;
      var validate = function validate(arrayOrStylesheet) {
        if (isArray$1(arrayOrStylesheet)) {
          for (var _i30 = 0; _i30 < arrayOrStylesheet.length; _i30++) {
            validate(arrayOrStylesheet[_i30]);
          }
        } else if (!isFunction$1(arrayOrStylesheet)) {
          // function assumed to be a stylesheet factory
          valid = false;
        }
      };
      if (!isArray$1(stylesheets)) {
        valid = false;
      } else {
        validate(stylesheets);
      }
      return valid;
    }
    // Validate and flatten any stylesheets defined as `static stylesheets`
    function computeStylesheets(vm, ctor) {
      warnOnStylesheetsMutation(ctor);
      var stylesheets = ctor.stylesheets;
      if (!isUndefined$1(stylesheets)) {
        var valid = validateComponentStylesheets(vm, stylesheets);
        if (valid) {
          return flattenStylesheets(stylesheets);
        } else if (process.env.NODE_ENV !== 'production') {
          logError("static stylesheets must be an array of CSS stylesheets. Found invalid stylesheets on <".concat(vm.tagName, ">"), vm);
        }
      }
      return null;
    }
    function warnOnStylesheetsMutation(ctor) {
      if (process.env.NODE_ENV !== 'production') {
        var stylesheets = ctor.stylesheets;
        defineProperty(ctor, 'stylesheets', {
          enumerable: true,
          configurable: true,
          get: function get() {
            return stylesheets;
          },
          set: function set(newValue) {
            logWarnOnce("Dynamically setting the \"stylesheets\" static property on ".concat(ctor.name, " ") + 'will not affect the stylesheets injected.');
            stylesheets = newValue;
          }
        });
      }
    }
    function computeShadowMode(vm, renderer) {
      var def = vm.def;
      var isSyntheticShadowDefined = renderer.isSyntheticShadowDefined,
        isNativeShadowDefined = renderer.isNativeShadowDefined;
      var shadowMode;
      if (isSyntheticShadowDefined) {
        if (def.renderMode === 0 /* RenderMode.Light */) {
          // ShadowMode.Native implies "not synthetic shadow" which is consistent with how
          // everything defaults to native when the synthetic shadow polyfill is unavailable.
          shadowMode = 0 /* ShadowMode.Native */;
        } else if (isNativeShadowDefined) {
          // Not combined with above condition because @lwc/features only supports identifiers in
          // the if-condition.
          if (lwcRuntimeFlags.ENABLE_MIXED_SHADOW_MODE) {
            if (def.shadowSupportMode === "any" /* ShadowSupportMode.Any */) {
              shadowMode = 0 /* ShadowMode.Native */;
            } else {
              var shadowAncestor = getNearestShadowAncestor(vm);
              if (!isNull(shadowAncestor) && shadowAncestor.shadowMode === 0 /* ShadowMode.Native */) {
                // Transitive support for native Shadow DOM. A component in native mode
                // transitively opts all of its descendants into native.
                shadowMode = 0 /* ShadowMode.Native */;
              } else {
                // Synthetic if neither this component nor any of its ancestors are configured
                // to be native.
                shadowMode = 1 /* ShadowMode.Synthetic */;
              }
            }
          } else {
            shadowMode = 1 /* ShadowMode.Synthetic */;
          }
        } else {
          // Synthetic if there is no native Shadow DOM support.
          shadowMode = 1 /* ShadowMode.Synthetic */;
        }
      } else {
        // Native if the synthetic shadow polyfill is unavailable.
        shadowMode = 0 /* ShadowMode.Native */;
      }

      return shadowMode;
    }
    function assertIsVM(obj) {
      if (isNull(obj) || !isObject(obj) || !('renderRoot' in obj)) {
        throw new TypeError("".concat(obj, " is not a VM."));
      }
    }
    function associateVM(obj, vm) {
      ViewModelReflection.set(obj, vm);
    }
    function getAssociatedVM(obj) {
      var vm = ViewModelReflection.get(obj);
      if (process.env.NODE_ENV !== 'production') {
        assertIsVM(vm);
      }
      return vm;
    }
    function getAssociatedVMIfPresent(obj) {
      var maybeVm = ViewModelReflection.get(obj);
      if (process.env.NODE_ENV !== 'production') {
        if (!isUndefined$1(maybeVm)) {
          assertIsVM(maybeVm);
        }
      }
      return maybeVm;
    }
    function rehydrate(vm) {
      if (isTrue(vm.isDirty)) {
        var children = renderComponent(vm);
        patchShadowRoot(vm, children);
      }
    }
    function patchShadowRoot(vm, newCh) {
      var renderRoot = vm.renderRoot,
        oldCh = vm.children,
        renderer = vm.renderer;
      // caching the new children collection
      vm.children = newCh;
      if (newCh.length > 0 || oldCh.length > 0) {
        // patch function mutates vnodes by adding the element reference,
        // however, if patching fails it contains partial changes.
        if (oldCh !== newCh) {
          runWithBoundaryProtection(vm, vm, function () {
            // pre
            logOperationStart(2 /* OperationId.Patch */, vm);
          }, function () {
            // job
            patchChildren(oldCh, newCh, renderRoot, renderer);
          }, function () {
            // post
            logOperationEnd(2 /* OperationId.Patch */, vm);
          });
        }
      }
      if (vm.state === 1 /* VMState.connected */) {
        // If the element is connected, that means connectedCallback was already issued, and
        // any successive rendering should finish with the call to renderedCallback, otherwise
        // the connectedCallback will take care of calling it in the right order at the end of
        // the current rehydration process.
        runRenderedCallback(vm);
      }
    }
    function runRenderedCallback(vm) {
      var renderedCallback = vm.def.renderedCallback;
      var rendered = Services.rendered;
      if (rendered) {
        invokeServiceHook(vm, rendered);
      }
      if (!isUndefined$1(renderedCallback)) {
        logOperationStart(4 /* OperationId.RenderedCallback */, vm);
        invokeComponentCallback(vm, renderedCallback);
        logOperationEnd(4 /* OperationId.RenderedCallback */, vm);
      }
    }
    var rehydrateQueue = [];
    function flushRehydrationQueue() {
      logGlobalOperationStart(8 /* OperationId.GlobalRehydrate */);
      if (process.env.NODE_ENV !== 'production') {
        assert.invariant(rehydrateQueue.length, "If rehydrateQueue was scheduled, it is because there must be at least one VM on this pending queue instead of ".concat(rehydrateQueue, "."));
      }
      var vms = rehydrateQueue.sort(function (a, b) {
        return a.idx - b.idx;
      });
      rehydrateQueue = []; // reset to a new queue
      for (var _i31 = 0, len = vms.length; _i31 < len; _i31 += 1) {
        var vm = vms[_i31];
        try {
          rehydrate(vm);
        } catch (error) {
          if (_i31 + 1 < len) {
            // pieces of the queue are still pending to be rehydrated, those should have priority
            if (rehydrateQueue.length === 0) {
              addCallbackToNextTick(flushRehydrationQueue);
            }
            ArrayUnshift.apply(rehydrateQueue, ArraySlice.call(vms, _i31 + 1));
          }
          // we need to end the measure before throwing.
          logGlobalOperationEnd(8 /* OperationId.GlobalRehydrate */);
          // re-throwing the original error will break the current tick, but since the next tick is
          // already scheduled, it should continue patching the rest.
          throw error; // eslint-disable-line no-unsafe-finally
        }
      }

      logGlobalOperationEnd(8 /* OperationId.GlobalRehydrate */);
    }

    function runConnectedCallback(vm) {
      var state = vm.state;
      if (state === 1 /* VMState.connected */) {
        return; // nothing to do since it was already connected
      }

      vm.state = 1 /* VMState.connected */;
      // reporting connection
      var connected = Services.connected;
      if (connected) {
        invokeServiceHook(vm, connected);
      }
      if (hasWireAdapters(vm)) {
        connectWireAdapters(vm);
      }
      var connectedCallback = vm.def.connectedCallback;
      if (!isUndefined$1(connectedCallback)) {
        logOperationStart(3 /* OperationId.ConnectedCallback */, vm);
        invokeComponentCallback(vm, connectedCallback);
        logOperationEnd(3 /* OperationId.ConnectedCallback */, vm);
      }
    }
    function hasWireAdapters(vm) {
      return getOwnPropertyNames$1(vm.def.wire).length > 0;
    }
    function runDisconnectedCallback(vm) {
      if (process.env.NODE_ENV !== 'production') {
        assert.isTrue(vm.state !== 2 /* VMState.disconnected */, "".concat(vm, " must be inserted."));
      }
      if (isFalse(vm.isDirty)) {
        // this guarantees that if the component is reused/reinserted,
        // it will be re-rendered because we are disconnecting the reactivity
        // linking, so mutations are not automatically reflected on the state
        // of disconnected components.
        vm.isDirty = true;
      }
      vm.state = 2 /* VMState.disconnected */;
      // reporting disconnection
      var disconnected = Services.disconnected;
      if (disconnected) {
        invokeServiceHook(vm, disconnected);
      }
      if (hasWireAdapters(vm)) {
        disconnectWireAdapters(vm);
      }
      var disconnectedCallback = vm.def.disconnectedCallback;
      if (!isUndefined$1(disconnectedCallback)) {
        logOperationStart(5 /* OperationId.DisconnectedCallback */, vm);
        invokeComponentCallback(vm, disconnectedCallback);
        logOperationEnd(5 /* OperationId.DisconnectedCallback */, vm);
      }
    }
    function runChildNodesDisconnectedCallback(vm) {
      var vCustomElementCollection = vm.velements;
      // Reporting disconnection for every child in inverse order since they are
      // inserted in reserved order.
      for (var _i32 = vCustomElementCollection.length - 1; _i32 >= 0; _i32 -= 1) {
        var elm = vCustomElementCollection[_i32].elm;
        // There are two cases where the element could be undefined:
        // * when there is an error during the construction phase, and an error
        //   boundary picks it, there is a possibility that the VCustomElement
        //   is not properly initialized, and therefore is should be ignored.
        // * when slotted custom element is not used by the element where it is
        //   slotted into it, as  a result, the custom element was never
        //   initialized.
        if (!isUndefined$1(elm)) {
          var childVM = getAssociatedVMIfPresent(elm);
          // The VM associated with the element might be associated undefined
          // in the case where the VM failed in the middle of its creation,
          // eg: constructor throwing before invoking super().
          if (!isUndefined$1(childVM)) {
            resetComponentStateWhenRemoved(childVM);
          }
        }
      }
    }
    function runLightChildNodesDisconnectedCallback(vm) {
      var adoptedChildren = vm.aChildren;
      recursivelyDisconnectChildren(adoptedChildren);
    }
    /**
     * The recursion doesn't need to be a complete traversal of the vnode graph,
     * instead it can be partial, when a custom element vnode is found, we don't
     * need to continue into its children because by attempting to disconnect the
     * custom element itself will trigger the removal of anything slotted or anything
     * defined on its shadow.
     */
    function recursivelyDisconnectChildren(vnodes) {
      for (var _i33 = 0, len = vnodes.length; _i33 < len; _i33 += 1) {
        var vnode = vnodes[_i33];
        if (!isNull(vnode) && !isUndefined$1(vnode.elm)) {
          switch (vnode.type) {
            case 2 /* VNodeType.Element */:
              recursivelyDisconnectChildren(vnode.children);
              break;
            case 3 /* VNodeType.CustomElement */:
              {
                var vm = getAssociatedVM(vnode.elm);
                resetComponentStateWhenRemoved(vm);
                break;
              }
          }
        }
      }
    }
    // This is a super optimized mechanism to remove the content of the root node (shadow root
    // for shadow DOM components and the root element itself for light DOM) without having to go
    // into snabbdom. Especially useful when the reset is a consequence of an error, in which case the
    // children VNodes might not be representing the current state of the DOM.
    function resetComponentRoot(vm) {
      recursivelyRemoveChildren(vm.children, vm);
      vm.children = EmptyArray;
      runChildNodesDisconnectedCallback(vm);
      vm.velements = EmptyArray;
    }
    // Helper function to remove all children of the root node.
    // If the set of children includes VFragment nodes, we need to remove the children of those nodes too.
    // Since VFragments can contain other VFragments, we need to traverse the entire of tree of VFragments.
    // If the set contains no VFragment nodes, no traversal is needed.
    function recursivelyRemoveChildren(vnodes, vm) {
      var renderRoot = vm.renderRoot,
        remove = vm.renderer.remove;
      for (var _i34 = 0, len = vnodes.length; _i34 < len; _i34 += 1) {
        var vnode = vnodes[_i34];
        if (!isNull(vnode)) {
          // VFragments are special; their .elm property does not point to the root element since they have no single root.
          if (isVFragment(vnode)) {
            recursivelyRemoveChildren(vnode.children, vm);
          } else if (!isUndefined$1(vnode.elm)) {
            remove(vnode.elm, renderRoot);
          }
        }
      }
    }
    function scheduleRehydration(vm) {
      if (isTrue(vm.isScheduled)) {
        return;
      }
      vm.isScheduled = true;
      if (rehydrateQueue.length === 0) {
        addCallbackToNextTick(flushRehydrationQueue);
      }
      ArrayPush$1.call(rehydrateQueue, vm);
    }
    function getErrorBoundaryVM(vm) {
      var currentVm = vm;
      while (!isNull(currentVm)) {
        if (!isUndefined$1(currentVm.def.errorCallback)) {
          return currentVm;
        }
        currentVm = currentVm.owner;
      }
    }
    function runWithBoundaryProtection(vm, owner, pre, job, post) {
      var error;
      pre();
      try {
        job();
      } catch (e) {
        error = Object(e);
      } finally {
        post();
        if (!isUndefined$1(error)) {
          addErrorComponentStack(vm, error);
          var errorBoundaryVm = isNull(owner) ? undefined : getErrorBoundaryVM(owner);
          if (isUndefined$1(errorBoundaryVm)) {
            throw error; // eslint-disable-line no-unsafe-finally
          }

          resetComponentRoot(vm); // remove offenders
          logOperationStart(6 /* OperationId.ErrorCallback */, vm);
          // error boundaries must have an ErrorCallback
          var errorCallback = errorBoundaryVm.def.errorCallback;
          invokeComponentCallback(errorBoundaryVm, errorCallback, [error, error.wcStack]);
          logOperationEnd(6 /* OperationId.ErrorCallback */, vm);
        }
      }
    }
    function forceRehydration(vm) {
      // if we must reset the shadowRoot content and render the template
      // from scratch on an active instance, the way to force the reset
      // is by replacing the value of old template, which is used during
      // to determine if the template has changed or not during the rendering
      // process. If the template returned by render() is different from the
      // previous stored template, the styles will be reset, along with the
      // content of the shadowRoot, this way we can guarantee that all children
      // elements will be throw away, and new instances will be created.
      vm.cmpTemplate = function () {
        return [];
      };
      if (isFalse(vm.isDirty)) {
        // forcing the vm to rehydrate in the next tick
        markComponentAsDirty(vm);
        scheduleRehydration(vm);
      }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    //
    // The goal of this code is to detect invalid cross-root ARIA references in synthetic shadow DOM.
    // These invalid references should be fixed before the offending components can be migrated to native shadow DOM.
    // When invalid usage is detected, we warn in dev mode and call the reporting API if enabled.
    // See: https://sfdc.co/synthetic-aria
    //
    // Use the unpatched native getElementById/querySelectorAll rather than the synthetic one
    var getElementById = _globalThis[KEY__NATIVE_GET_ELEMENT_BY_ID];
    var querySelectorAll = _globalThis[KEY__NATIVE_QUERY_SELECTOR_ALL];
    // This is a "handoff" from synthetic-shadow to engine-core – we want to clean up after ourselves
    // so nobody else can misuse these global APIs.
    delete _globalThis[KEY__NATIVE_GET_ELEMENT_BY_ID];
    delete _globalThis[KEY__NATIVE_QUERY_SELECTOR_ALL];
    function isSyntheticShadowRootInstance(rootNode) {
      return rootNode !== document && isTrue(rootNode.synthetic);
    }
    function reportViolation$1(source, target, attrName) {
      // The vm is either for the source, the target, or both. Either one or both must be using synthetic
      // shadow for a violation to be detected.
      var vm = getAssociatedVMIfPresent(source.getRootNode().host);
      if (isUndefined$1(vm)) {
        vm = getAssociatedVMIfPresent(target.getRootNode().host);
      }
      if (isUndefined$1(vm)) {
        // vm should never be undefined here, but just to be safe, bail out and don't report
        return;
      }
      report("CrossRootAriaInSyntheticShadow" /* ReportingEventId.CrossRootAriaInSyntheticShadow */, {
        tagName: vm.tagName,
        attributeName: attrName
      });
      if (process.env.NODE_ENV !== 'production') {
        // Avoid excessively logging to the console in the case of duplicates.
        logWarnOnce("Element <".concat(source.tagName.toLowerCase(), "> uses attribute \"").concat(attrName, "\" to reference element ") + "<".concat(target.tagName.toLowerCase(), ">, which is not in the same shadow root. This will break in native shadow DOM. ") + "For details, see: https://sfdc.co/synthetic-aria", vm);
      }
    }
    function parseIdRefAttributeValue(attrValue) {
      // split on whitespace and skip empty strings after splitting
      return isString(attrValue) ? ArrayFilter.call(StringSplit.call(attrValue, /\s+/), Boolean) : [];
    }
    function detectSyntheticCrossRootAria(elm, attrName, attrValue) {
      var root = elm.getRootNode();
      if (!isSyntheticShadowRootInstance(root)) {
        return;
      }
      if (attrName === 'id') {
        // elm is the target, find the source
        if (!isString(attrValue) || attrValue.length === 0) {
          // if our id is null or empty, nobody can reference us
          return;
        }
        var _iterator10 = _createForOfIteratorHelper(ID_REFERENCING_ATTRIBUTES_SET),
          _step10;
        try {
          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
            var idRefAttrName = _step10.value;
            // Query all global elements with this attribute. The attribute selector syntax `~=` is for values
            // that reference multiple IDs, separated by whitespace.
            var query = "[".concat(idRefAttrName, "~=\"").concat(CSS.escape(attrValue), "\"]");
            var sourceElements = querySelectorAll.call(document, query);
            for (var _i35 = 0; _i35 < sourceElements.length; _i35++) {
              var sourceElement = sourceElements[_i35];
              var sourceRoot = sourceElement.getRootNode();
              if (sourceRoot !== root) {
                reportViolation$1(sourceElement, elm, idRefAttrName);
                break;
              }
            }
          }
        } catch (err) {
          _iterator10.e(err);
        } finally {
          _iterator10.f();
        }
      } else {
        // elm is the source, find the target
        var ids = parseIdRefAttributeValue(attrValue);
        var _iterator11 = _createForOfIteratorHelper(ids),
          _step11;
        try {
          for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
            var id = _step11.value;
            var target = getElementById.call(document, id);
            if (!isNull(target)) {
              var targetRoot = target.getRootNode();
              if (targetRoot !== root) {
                // target element's shadow root is not the same as ours
                reportViolation$1(elm, target, attrName);
              }
            }
          }
        } catch (err) {
          _iterator11.e(err);
        } finally {
          _iterator11.f();
        }
      }
    }
    var enabled = false;
    // We want to avoid patching globals whenever possible, so this should be tree-shaken out in prod-mode and if
    // reporting is not enabled. It should also only run once
    function enableDetection$1() {
      if (enabled) {
        return; // don't double-apply the patches
      }

      enabled = true;
      var _setAttribute = Element.prototype.setAttribute;
      // Detect calling `setAttribute` to set an idref or an id
      assign(Element.prototype, {
        setAttribute: function setAttribute(attrName, attrValue) {
          _setAttribute.call(this, attrName, attrValue);
          if (attrName === 'id' || ID_REFERENCING_ATTRIBUTES_SET.has(attrName)) {
            detectSyntheticCrossRootAria(this, attrName, attrValue);
          }
        }
      });
      // Detect `elm.id = 'foo'`
      var idDescriptor = getOwnPropertyDescriptor$1(Element.prototype, 'id');
      if (!isUndefined$1(idDescriptor)) {
        var _get3 = idDescriptor.get,
          _set3 = idDescriptor.set;
        // These should always be a getter and a setter, but if someone is monkeying with the global descriptor, ignore it
        if (isFunction$1(_get3) && isFunction$1(_set3)) {
          defineProperty(Element.prototype, 'id', {
            get: function get() {
              return _get3.call(this);
            },
            set: function set(value) {
              _set3.call(this, value);
              detectSyntheticCrossRootAria(this, 'id', value);
            },
            // On the default descriptor for 'id', enumerable and configurable are true
            enumerable: true,
            configurable: true
          });
        }
      }
    }
    // Our detection logic relies on some modern browser features. We can just skip reporting the data
    // for unsupported browsers
    function supportsCssEscape() {
      return typeof CSS !== 'undefined' && isFunction$1(CSS.escape);
    }
    // If this page is not using synthetic shadow, then we don't need to install detection. Note
    // that we are assuming synthetic shadow is loaded before LWC.
    function isSyntheticShadowLoaded() {
      // We should probably be calling `renderer.isSyntheticShadowDefined`, but 1) we don't have access to the renderer,
      // and 2) this code needs to run in @lwc/engine-core, so it can access `logWarn()` and `report()`.
      return hasOwnProperty$1.call(Element.prototype, KEY__SHADOW_TOKEN);
    }
    // Detecting cross-root ARIA in synthetic shadow only makes sense for the browser
    if (supportsCssEscape() && isSyntheticShadowLoaded()) {
      // Always run detection in dev mode, so we can at least print to the console
      if (process.env.NODE_ENV !== 'production') {
        enableDetection$1();
      } else {
        // In prod mode, only enable detection if reporting is enabled
        onReportingEnabled(enableDetection$1);
      }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    //
    // The goal of this code is to detect usages of non-standard reflected ARIA properties. These are caused by
    // legacy non-standard Element.prototype extensions added by the @lwc/aria-reflection package.
    //
    // See the README for @lwc/aria-reflection
    var NON_STANDARD_ARIA_PROPS = ['ariaActiveDescendant', 'ariaControls', 'ariaDescribedBy', 'ariaDetails', 'ariaErrorMessage', 'ariaFlowTo', 'ariaLabelledBy', 'ariaOwns'];
    function isLightningElement(elm) {
      // The former case is for `this.prop` (inside component) and the latter is for `element.prop` (outside component).
      // In both cases, we apply the non-standard prop even when the global polyfill is disabled, so this is kosher.
      return elm instanceof LightningElement || elm instanceof BaseBridgeElement;
    }
    function findVM(elm) {
      // If it's a shadow DOM component, then it has a host
      var _elm$getRootNode = elm.getRootNode(),
        host = _elm$getRootNode.host;
      var vm = isUndefined$1(host) ? undefined : getAssociatedVMIfPresent(host);
      if (!isUndefined$1(vm)) {
        return vm;
      }
      // Else it might be a light DOM component. Walk up the tree trying to find the owner
      var parentElement = elm;
      while (!isNull(parentElement = parentElement.parentElement)) {
        if (isLightningElement(parentElement)) {
          var _vm = getAssociatedVMIfPresent(parentElement);
          if (!isUndefined$1(_vm)) {
            return _vm;
          }
        }
      }
      // If we return undefined, it's because the element was rendered wholly outside a LightningElement
    }

    function checkAndReportViolation(elm, prop, isSetter, setValue) {
      if (!isLightningElement(elm)) {
        var vm = findVM(elm);
        if (process.env.NODE_ENV !== 'production') {
          logWarnOnce("Element <".concat(elm.tagName.toLowerCase(), "> ") + (isUndefined$1(vm) ? '' : "owned by <".concat(vm.elm.tagName.toLowerCase(), "> ")) + "uses non-standard property \"".concat(prop, "\". This will be removed in a future version of LWC. ") + "See https://sfdc.co/deprecated-aria");
        }
        var setValueType;
        if (isSetter) {
          // `typeof null` is "object" which is not very useful for detecting null.
          // We mostly want to know null vs undefined vs other types here, due to
          // https://github.com/salesforce/lwc/issues/3284
          setValueType = isNull(setValue) ? 'null' : _typeof(setValue);
        }
        report("NonStandardAriaReflection" /* ReportingEventId.NonStandardAriaReflection */, {
          tagName: vm === null || vm === void 0 ? void 0 : vm.tagName,
          propertyName: prop,
          isSetter: isSetter,
          setValueType: setValueType
        });
      }
    }
    function enableDetection() {
      var _Element = Element,
        prototype = _Element.prototype;
      var _iterator12 = _createForOfIteratorHelper(NON_STANDARD_ARIA_PROPS),
        _step12;
      try {
        var _loop3 = function _loop3() {
          var prop = _step12.value;
          var descriptor = getOwnPropertyDescriptor$1(prototype, prop);
          // The descriptor should exist because the @lwc/aria-reflection polyfill has run by now.
          // This happens automatically because of the ordering of imports.
          if (process.env.NODE_ENV !== 'production') {
            /* istanbul ignore if */
            if (isUndefined$1(descriptor) || isUndefined$1(descriptor.get) || isUndefined$1(descriptor.set)) {
              // should never happen
              throw new Error('detect-non-standard-aria.ts loaded before @lwc/aria-reflection');
            }
          }
          // @ts-ignore
          var _get4 = descriptor.get,
            _set4 = descriptor.set;
          defineProperty(prototype, prop, {
            get: function get() {
              checkAndReportViolation(this, prop, false, undefined);
              return _get4.call(this);
            },
            set: function set(val) {
              checkAndReportViolation(this, prop, true, val);
              return _set4.call(this, val);
            },
            configurable: true,
            enumerable: true
          });
        };
        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
          _loop3();
        }
      } catch (err) {
        _iterator12.e(err);
      } finally {
        _iterator12.f();
      }
    }
    // No point in running this code if we're not in a browser, or if the global polyfill is not loaded
    {
      if (!lwcRuntimeFlags.DISABLE_ARIA_REFLECTION_POLYFILL) {
        // Always run detection in dev mode, so we can at least print to the console
        if (process.env.NODE_ENV !== 'production') {
          enableDetection();
        } else {
          // In prod mode, only enable detection if reporting is enabled
          onReportingEnabled(enableDetection);
        }
      }
    }

    /*
     * Copyright (c) 2022, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // flag indicating if the hydration recovered from the DOM mismatch
    var hasMismatch = false;
    function hydrateRoot(vm) {
      hasMismatch = false;
      runConnectedCallback(vm);
      hydrateVM(vm);
      if (hasMismatch) {
        logError('Hydration completed with errors.', vm);
      }
    }
    function hydrateVM(vm) {
      var children = renderComponent(vm);
      vm.children = children;
      var parentNode = vm.renderRoot,
        getFirstChild = vm.renderer.getFirstChild;
      hydrateChildren(getFirstChild(parentNode), children, parentNode, vm);
      runRenderedCallback(vm);
    }
    function hydrateNode(node, vnode, renderer) {
      var _a, _b;
      var hydratedNode;
      switch (vnode.type) {
        case 0 /* VNodeType.Text */:
          // VText has no special capability, fallback to the owner's renderer
          hydratedNode = hydrateText(node, vnode, renderer);
          break;
        case 1 /* VNodeType.Comment */:
          // VComment has no special capability, fallback to the owner's renderer
          hydratedNode = hydrateComment(node, vnode, renderer);
          break;
        case 4 /* VNodeType.Static */:
          // VStatic are cacheable and cannot have custom renderer associated to them
          hydratedNode = hydrateStaticElement(node, vnode, renderer);
          break;
        case 5 /* VNodeType.Fragment */:
          // a fragment does not represent any element, therefore there is no need to use a custom renderer.
          hydratedNode = hydrateFragment(node, vnode, renderer);
          break;
        case 2 /* VNodeType.Element */:
          hydratedNode = hydrateElement(node, vnode, (_a = vnode.data.renderer) !== null && _a !== void 0 ? _a : renderer);
          break;
        case 3 /* VNodeType.CustomElement */:
          hydratedNode = hydrateCustomElement(node, vnode, (_b = vnode.data.renderer) !== null && _b !== void 0 ? _b : renderer);
          break;
      }
      return renderer.nextSibling(hydratedNode);
    }
    var NODE_VALUE_PROP = 'nodeValue';
    function textNodeContentsAreEqual(node, vnode, renderer) {
      var getProperty = renderer.getProperty;
      var nodeValue = getProperty(node, NODE_VALUE_PROP);
      if (nodeValue === vnode.text) {
        return true;
      }
      // Special case for empty text nodes – these are serialized differently on the server
      // See https://github.com/salesforce/lwc/pull/2656
      if (nodeValue === "\u200D" && vnode.text === '') {
        return true;
      }
      return false;
    }
    function hydrateText(node, vnode, renderer) {
      var _a;
      if (!hasCorrectNodeType(vnode, node, 3 /* EnvNodeTypes.TEXT */, renderer)) {
        return handleMismatch(node, vnode, renderer);
      }
      if (process.env.NODE_ENV !== 'production') {
        if (!textNodeContentsAreEqual(node, vnode, renderer)) {
          logWarn('Hydration mismatch: text values do not match, will recover from the difference', vnode.owner);
        }
      }
      var setText = renderer.setText;
      setText(node, (_a = vnode.text) !== null && _a !== void 0 ? _a : null);
      vnode.elm = node;
      return node;
    }
    function hydrateComment(node, vnode, renderer) {
      var _a;
      if (!hasCorrectNodeType(vnode, node, 8 /* EnvNodeTypes.COMMENT */, renderer)) {
        return handleMismatch(node, vnode, renderer);
      }
      if (process.env.NODE_ENV !== 'production') {
        var getProperty = renderer.getProperty;
        var nodeValue = getProperty(node, NODE_VALUE_PROP);
        if (nodeValue !== vnode.text) {
          logWarn('Hydration mismatch: comment values do not match, will recover from the difference', vnode.owner);
        }
      }
      var setProperty = renderer.setProperty;
      setProperty(node, NODE_VALUE_PROP, (_a = vnode.text) !== null && _a !== void 0 ? _a : null);
      vnode.elm = node;
      return node;
    }
    function hydrateStaticElement(elm, vnode, renderer) {
      if (!areCompatibleNodes(vnode.fragment, elm, vnode, renderer)) {
        return handleMismatch(elm, vnode, renderer);
      }
      vnode.elm = elm;
      return elm;
    }
    function hydrateFragment(elm, vnode, renderer) {
      var children = vnode.children,
        owner = vnode.owner;
      hydrateChildren(elm, children, renderer.getProperty(elm, 'parentNode'), owner);
      return vnode.elm = children[children.length - 1].elm;
    }
    function hydrateElement(elm, vnode, renderer) {
      if (!hasCorrectNodeType(vnode, elm, 1 /* EnvNodeTypes.ELEMENT */, renderer) || !isMatchingElement(vnode, elm, renderer)) {
        return handleMismatch(elm, vnode, renderer);
      }
      vnode.elm = elm;
      var owner = vnode.owner;
      var context = vnode.data.context;
      var isDomManual = Boolean(!isUndefined$1(context) && !isUndefined$1(context.lwc) && context.lwc.dom === "manual" /* LwcDomMode.Manual */);
      if (isDomManual) {
        // it may be that this element has lwc:inner-html, we need to diff and in case are the same,
        // remove the innerHTML from props so it reuses the existing dom elements.
        var props = vnode.data.props;
        var getProperty = renderer.getProperty;
        if (!isUndefined$1(props) && !isUndefined$1(props.innerHTML)) {
          if (getProperty(elm, 'innerHTML') === props.innerHTML) {
            // Do a shallow clone since VNodeData may be shared across VNodes due to hoist optimization
            vnode.data = Object.assign(Object.assign({}, vnode.data), {
              props: cloneAndOmitKey(props, 'innerHTML')
            });
          } else {
            if (process.env.NODE_ENV !== 'production') {
              logWarn("Mismatch hydrating element <".concat(getProperty(elm, 'tagName').toLowerCase(), ">: innerHTML values do not match for element, will recover from the difference"), owner);
            }
          }
        }
      }
      patchElementPropsAndAttrs(vnode, renderer);
      if (!isDomManual) {
        var getFirstChild = renderer.getFirstChild;
        hydrateChildren(getFirstChild(elm), vnode.children, elm, owner);
      }
      return elm;
    }
    function hydrateCustomElement(elm, vnode, renderer) {
      if (!hasCorrectNodeType(vnode, elm, 1 /* EnvNodeTypes.ELEMENT */, renderer) || !isMatchingElement(vnode, elm, renderer)) {
        return handleMismatch(elm, vnode, renderer);
      }
      var sel = vnode.sel,
        mode = vnode.mode,
        ctor = vnode.ctor,
        owner = vnode.owner;
      var vm = createVM(elm, ctor, renderer, {
        mode: mode,
        owner: owner,
        tagName: sel,
        hydrated: true
      });
      vnode.elm = elm;
      vnode.vm = vm;
      allocateChildren(vnode, vm);
      patchElementPropsAndAttrs(vnode, renderer);
      // Insert hook section:
      if (process.env.NODE_ENV !== 'production') {
        assert.isTrue(vm.state === 0 /* VMState.created */, "".concat(vm, " cannot be recycled."));
      }
      runConnectedCallback(vm);
      if (vm.renderMode !== 0 /* RenderMode.Light */) {
        var getFirstChild = renderer.getFirstChild;
        // VM is not rendering in Light DOM, we can proceed and hydrate the slotted content.
        // Note: for Light DOM, this is handled while hydrating the VM
        hydrateChildren(getFirstChild(elm), vnode.children, elm, vm);
      }
      hydrateVM(vm);
      return elm;
    }
    function hydrateChildren(node, children, parentNode, owner) {
      var hasWarned = false;
      var nextNode = node;
      var anchor = null;
      var renderer = owner.renderer;
      for (var _i36 = 0; _i36 < children.length; _i36++) {
        var childVnode = children[_i36];
        if (!isNull(childVnode)) {
          if (nextNode) {
            nextNode = hydrateNode(nextNode, childVnode, renderer);
            anchor = childVnode.elm;
          } else {
            hasMismatch = true;
            if (process.env.NODE_ENV !== 'production') {
              if (!hasWarned) {
                hasWarned = true;
                logError("Hydration mismatch: incorrect number of rendered nodes. Client produced more nodes than the server.", owner);
              }
            }
            mount(childVnode, parentNode, renderer, anchor);
            anchor = childVnode.elm;
          }
        }
      }
      if (nextNode) {
        hasMismatch = true;
        if (process.env.NODE_ENV !== 'production') {
          if (!hasWarned) {
            logError("Hydration mismatch: incorrect number of rendered nodes. Server rendered more nodes than the client.", owner);
          }
        }
        // nextSibling is mostly harmless, and since we don't have
        // a good reference to what element to act upon, we instead
        // rely on the vm's associated renderer for navigating to the
        // next node in the list to be hydrated.
        var nextSibling = renderer.nextSibling;
        do {
          var current = nextNode;
          nextNode = nextSibling(nextNode);
          removeNode(current, parentNode, renderer);
        } while (nextNode);
      }
    }
    function handleMismatch(node, vnode, renderer) {
      hasMismatch = true;
      var getProperty = renderer.getProperty;
      var parentNode = getProperty(node, 'parentNode');
      mount(vnode, parentNode, renderer, node);
      removeNode(node, parentNode, renderer);
      return vnode.elm;
    }
    function patchElementPropsAndAttrs(vnode, renderer) {
      applyEventListeners(vnode, renderer);
      patchProps(null, vnode, renderer);
    }
    function hasCorrectNodeType(vnode, node, nodeType, renderer) {
      var getProperty = renderer.getProperty;
      if (getProperty(node, 'nodeType') !== nodeType) {
        if (process.env.NODE_ENV !== 'production') {
          logError('Hydration mismatch: incorrect node type received', vnode.owner);
        }
        return false;
      }
      return true;
    }
    function isMatchingElement(vnode, elm, renderer) {
      var getProperty = renderer.getProperty;
      if (vnode.sel.toLowerCase() !== getProperty(elm, 'tagName').toLowerCase()) {
        if (process.env.NODE_ENV !== 'production') {
          logError("Hydration mismatch: expecting element with tag \"".concat(vnode.sel.toLowerCase(), "\" but found \"").concat(getProperty(elm, 'tagName').toLowerCase(), "\"."), vnode.owner);
        }
        return false;
      }
      var hasIncompatibleAttrs = validateAttrs(vnode, elm, renderer);
      var hasIncompatibleClass = validateClassAttr(vnode, elm, renderer);
      var hasIncompatibleStyle = validateStyleAttr(vnode, elm, renderer);
      return hasIncompatibleAttrs && hasIncompatibleClass && hasIncompatibleStyle;
    }
    function attributeValuesAreEqual(vnodeValue, value) {
      var vnodeValueAsString = String(vnodeValue);
      if (vnodeValueAsString === value) {
        return true;
      }
      // If the expected value is null, this means that the attribute does not exist. In that case,
      // we accept any nullish value (undefined or null).
      if (isNull(value) && (isUndefined$1(vnodeValue) || isNull(vnodeValue))) {
        return true;
      }
      // In all other cases, the two values are not considered equal
      return false;
    }
    function validateAttrs(vnode, elm, renderer) {
      var _vnode$data$attrs = vnode.data.attrs,
        attrs = _vnode$data$attrs === void 0 ? {} : _vnode$data$attrs;
      var nodesAreCompatible = true;
      // Validate attributes, though we could always recovery from those by running the update mods.
      // Note: intentionally ONLY matching vnodes.attrs to elm.attrs, in case SSR is adding extra attributes.
      for (var _i37 = 0, _Object$entries = Object.entries(attrs); _i37 < _Object$entries.length; _i37++) {
        var _Object$entries$_i = _slicedToArray(_Object$entries[_i37], 2),
          attrName = _Object$entries$_i[0],
          attrValue = _Object$entries$_i[1];
        var owner = vnode.owner;
        var getAttribute = renderer.getAttribute;
        var elmAttrValue = getAttribute(elm, attrName);
        if (!attributeValuesAreEqual(attrValue, elmAttrValue)) {
          if (process.env.NODE_ENV !== 'production') {
            var getProperty = renderer.getProperty;
            logError("Mismatch hydrating element <".concat(getProperty(elm, 'tagName').toLowerCase(), ">: attribute \"").concat(attrName, "\" has different values, expected \"").concat(attrValue, "\" but found ").concat(isNull(elmAttrValue) ? 'null' : "\"".concat(elmAttrValue, "\"")), owner);
          }
          nodesAreCompatible = false;
        }
      }
      return nodesAreCompatible;
    }
    function validateClassAttr(vnode, elm, renderer) {
      var data = vnode.data,
        owner = vnode.owner;
      var className = data.className,
        classMap = data.classMap;
      var getProperty = renderer.getProperty,
        getClassList = renderer.getClassList,
        getAttribute = renderer.getAttribute;
      var scopedToken = getScopeTokenClass(owner);
      var stylesheetTokenHost = isVCustomElement(vnode) ? getStylesheetTokenHost(vnode) : null;
      // Classnames for scoped CSS are added directly to the DOM during rendering,
      // or to the VDOM on the server in the case of SSR. As such, these classnames
      // are never present in VDOM nodes in the browser.
      //
      // Consequently, hydration mismatches will occur if scoped CSS token classnames
      // are rendered during SSR. This needs to be accounted for when validating.
      if (!isNull(scopedToken) || !isNull(stylesheetTokenHost)) {
        if (!isUndefined$1(className)) {
          // The order of the className should be scopedToken className stylesheetTokenHost
          var classTokens = [scopedToken, className, stylesheetTokenHost];
          var classNames = ArrayFilter.call(classTokens, function (token) {
            return !isNull(token);
          });
          className = ArrayJoin.call(classNames, ' ');
        } else if (!isUndefined$1(classMap)) {
          classMap = Object.assign(Object.assign(Object.assign({}, classMap), !isNull(scopedToken) ? _defineProperty({}, scopedToken, true) : {}), !isNull(stylesheetTokenHost) ? _defineProperty({}, stylesheetTokenHost, true) : {});
        } else {
          // The order of the className should be scopedToken stylesheetTokenHost
          var _classTokens = [scopedToken, stylesheetTokenHost];
          var _classNames = ArrayFilter.call(_classTokens, function (token) {
            return !isNull(token);
          });
          if (_classNames.length) {
            className = ArrayJoin.call(_classNames, ' ');
          }
        }
      }
      var nodesAreCompatible = true;
      var readableVnodeClassname;
      var elmClassName = getAttribute(elm, 'class');
      if (!isUndefined$1(className) && String(className) !== elmClassName) {
        // className is used when class is bound to an expr.
        nodesAreCompatible = false;
        // stringify for pretty-printing
        readableVnodeClassname = JSON.stringify(className);
      } else if (!isUndefined$1(classMap)) {
        // classMap is used when class is set to static value.
        var classList = getClassList(elm);
        var computedClassName = '';
        // all classes from the vnode should be in the element.classList
        for (var name in classMap) {
          computedClassName += ' ' + name;
          if (!classList.contains(name)) {
            nodesAreCompatible = false;
          }
        }
        // stringify for pretty-printing
        readableVnodeClassname = JSON.stringify(computedClassName.trim());
        if (classList.length > keys(classMap).length) {
          nodesAreCompatible = false;
        }
      } else if (isUndefined$1(className) && !isNull(elmClassName)) {
        // SSR contains a className but client-side VDOM does not
        nodesAreCompatible = false;
        readableVnodeClassname = '""';
      }
      if (!nodesAreCompatible) {
        if (process.env.NODE_ENV !== 'production') {
          logError("Mismatch hydrating element <".concat(getProperty(elm, 'tagName').toLowerCase(), ">: attribute \"class\" has different values, expected ").concat(readableVnodeClassname, " but found ").concat(JSON.stringify(elmClassName)), vnode.owner);
        }
      }
      return nodesAreCompatible;
    }
    function validateStyleAttr(vnode, elm, renderer) {
      var _vnode$data = vnode.data,
        style = _vnode$data.style,
        styleDecls = _vnode$data.styleDecls;
      var getAttribute = renderer.getAttribute;
      var elmStyle = getAttribute(elm, 'style') || '';
      var vnodeStyle;
      var nodesAreCompatible = true;
      if (!isUndefined$1(style) && style !== elmStyle) {
        nodesAreCompatible = false;
        vnodeStyle = style;
      } else if (!isUndefined$1(styleDecls)) {
        var parsedVnodeStyle = parseStyleText(elmStyle);
        var expectedStyle = [];
        // styleMap is used when style is set to static value.
        for (var _i38 = 0, n = styleDecls.length; _i38 < n; _i38++) {
          var _styleDecls$_i2 = _slicedToArray(styleDecls[_i38], 3),
            prop = _styleDecls$_i2[0],
            value = _styleDecls$_i2[1],
            important = _styleDecls$_i2[2];
          expectedStyle.push("".concat(prop, ": ").concat(value + (important ? ' important!' : '')));
          var parsedPropValue = parsedVnodeStyle[prop];
          if (isUndefined$1(parsedPropValue)) {
            nodesAreCompatible = false;
          } else if (!parsedPropValue.startsWith(value)) {
            nodesAreCompatible = false;
          } else if (important && !parsedPropValue.endsWith('!important')) {
            nodesAreCompatible = false;
          }
        }
        if (keys(parsedVnodeStyle).length > styleDecls.length) {
          nodesAreCompatible = false;
        }
        vnodeStyle = ArrayJoin.call(expectedStyle, ';');
      }
      if (!nodesAreCompatible) {
        if (process.env.NODE_ENV !== 'production') {
          var getProperty = renderer.getProperty;
          logError("Mismatch hydrating element <".concat(getProperty(elm, 'tagName').toLowerCase(), ">: attribute \"style\" has different values, expected \"").concat(vnodeStyle, "\" but found \"").concat(elmStyle, "\"."), vnode.owner);
        }
      }
      return nodesAreCompatible;
    }
    function areCompatibleNodes(client, ssr, vnode, renderer) {
      var getProperty = renderer.getProperty,
        getAttribute = renderer.getAttribute;
      if (getProperty(client, 'nodeType') === 3 /* EnvNodeTypes.TEXT */) {
        if (!hasCorrectNodeType(vnode, ssr, 3 /* EnvNodeTypes.TEXT */, renderer)) {
          return false;
        }
        return getProperty(client, NODE_VALUE_PROP) === getProperty(ssr, NODE_VALUE_PROP);
      }
      if (getProperty(client, 'nodeType') === 8 /* EnvNodeTypes.COMMENT */) {
        if (!hasCorrectNodeType(vnode, ssr, 8 /* EnvNodeTypes.COMMENT */, renderer)) {
          return false;
        }
        return getProperty(client, NODE_VALUE_PROP) === getProperty(ssr, NODE_VALUE_PROP);
      }
      if (!hasCorrectNodeType(vnode, ssr, 1 /* EnvNodeTypes.ELEMENT */, renderer)) {
        return false;
      }
      var isCompatibleElements = true;
      if (getProperty(client, 'tagName') !== getProperty(ssr, 'tagName')) {
        if (process.env.NODE_ENV !== 'production') {
          logError("Hydration mismatch: expecting element with tag \"".concat(getProperty(client, 'tagName').toLowerCase(), "\" but found \"").concat(getProperty(ssr, 'tagName').toLowerCase(), "\"."), vnode.owner);
        }
        return false;
      }
      var clientAttrsNames = getProperty(client, 'getAttributeNames').call(client);
      clientAttrsNames.forEach(function (attrName) {
        if (getAttribute(client, attrName) !== getAttribute(ssr, attrName)) {
          logError("Mismatch hydrating element <".concat(getProperty(client, 'tagName').toLowerCase(), ">: attribute \"").concat(attrName, "\" has different values, expected \"").concat(getAttribute(client, attrName), "\" but found \"").concat(getAttribute(ssr, attrName), "\""), vnode.owner);
          isCompatibleElements = false;
        }
      });
      return isCompatibleElements;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var hooksAreSet = false;
    function setHooks(hooks) {
      assert.isFalse(hooksAreSet, 'Hooks are already overridden, only one definition is allowed.');
      hooksAreSet = true;
      setSanitizeHtmlContentHook(hooks.sanitizeHtmlContent);
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // See @lwc/engine-core/src/framework/template.ts
    var TEMPLATE_PROPS = ['slots', 'stylesheetToken', 'stylesheets', 'renderMode'];
    // Expandos that may be placed on a stylesheet factory function, and which are meaningful to LWC at runtime
    var STYLESHEET_PROPS = [
    // SEE `KEY__SCOPED_CSS` in @lwc/style-compiler
    '$scoped$'];
    // Via https://www.npmjs.com/package/object-observer
    var ARRAY_MUTATION_METHODS = ['pop', 'push', 'shift', 'unshift', 'reverse', 'sort', 'fill', 'splice', 'copyWithin'];
    var mutationTrackingDisabled = false;
    function getOriginalArrayMethod(prop) {
      switch (prop) {
        case 'pop':
          return ArrayPop;
        case 'push':
          return ArrayPush$1;
        case 'shift':
          return ArrayShift;
        case 'unshift':
          return ArrayUnshift;
        case 'reverse':
          return ArrayReverse;
        case 'sort':
          return ArraySort;
        case 'fill':
          return ArrayFill;
        case 'splice':
          return ArraySplice;
        case 'copyWithin':
          return ArrayCopyWithin;
      }
    }
    function reportViolation(type, eventId, prop) {
      if (process.env.NODE_ENV !== 'production') {
        logWarnOnce("Mutating the \"".concat(prop, "\" property on a ").concat(type, " ") + "is deprecated and will be removed in a future version of LWC. " + "See: https://sfdc.co/template-mutation");
      }
      report(eventId, {
        propertyName: prop
      });
    }
    function reportTemplateViolation(prop) {
      reportViolation('template', "TemplateMutation" /* ReportingEventId.TemplateMutation */, prop);
    }
    function reportStylesheetViolation(prop) {
      reportViolation('stylesheet', "StylesheetMutation" /* ReportingEventId.StylesheetMutation */, prop);
    }
    // Warn if the user tries to mutate a stylesheets array, e.g.:
    // `tmpl.stylesheets.push(someStylesheetFunction)`
    function warnOnArrayMutation(stylesheets) {
      // We can't handle users calling Array.prototype.slice.call(tmpl.stylesheets), but
      // we can at least warn when they use the most common mutation methods.
      var _iterator13 = _createForOfIteratorHelper(ARRAY_MUTATION_METHODS),
        _step13;
      try {
        var _loop4 = function _loop4() {
          var prop = _step13.value;
          var originalArrayMethod = getOriginalArrayMethod(prop);
          stylesheets[prop] = function arrayMutationWarningWrapper() {
            reportTemplateViolation('stylesheets');
            // @ts-ignore
            return originalArrayMethod.apply(this, arguments);
          };
        };
        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
          _loop4();
        }
      } catch (err) {
        _iterator13.e(err);
      } finally {
        _iterator13.f();
      }
    }
    // Warn if the user tries to mutate a stylesheet factory function, e.g.:
    // `stylesheet.$scoped$ = true`
    function warnOnStylesheetFunctionMutation(stylesheet) {
      var _iterator14 = _createForOfIteratorHelper(STYLESHEET_PROPS),
        _step14;
      try {
        var _loop5 = function _loop5() {
          var prop = _step14.value;
          var value = stylesheet[prop];
          defineProperty(stylesheet, prop, {
            enumerable: true,
            configurable: true,
            get: function get() {
              return value;
            },
            set: function set(newValue) {
              reportStylesheetViolation(prop);
              value = newValue;
            }
          });
        };
        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
          _loop5();
        }
      } catch (err) {
        _iterator14.e(err);
      } finally {
        _iterator14.f();
      }
    }
    // Warn on either array or stylesheet (function) mutation, in a deeply-nested array
    function trackStylesheetsMutation(stylesheets) {
      traverseStylesheets(stylesheets, function (subStylesheets) {
        if (isArray$1(subStylesheets)) {
          warnOnArrayMutation(subStylesheets);
        } else {
          warnOnStylesheetFunctionMutation(subStylesheets);
        }
      });
    }
    // Deeply freeze the entire array (of arrays) of stylesheet factory functions
    function deepFreeze(stylesheets) {
      traverseStylesheets(stylesheets, function (subStylesheets) {
        freeze(subStylesheets);
      });
    }
    // Deep-traverse an array (of arrays) of stylesheet factory functions, and call the callback for every array/function
    function traverseStylesheets(stylesheets, callback) {
      callback(stylesheets);
      for (var _i39 = 0; _i39 < stylesheets.length; _i39++) {
        var stylesheet = stylesheets[_i39];
        if (isArray$1(stylesheet)) {
          traverseStylesheets(stylesheet, callback);
        } else {
          callback(stylesheet);
        }
      }
    }
    function trackMutations(tmpl) {
      if (!isUndefined$1(tmpl.stylesheets)) {
        trackStylesheetsMutation(tmpl.stylesheets);
      }
      var _iterator15 = _createForOfIteratorHelper(TEMPLATE_PROPS),
        _step15;
      try {
        var _loop6 = function _loop6() {
          var prop = _step15.value;
          var value = tmpl[prop];
          defineProperty(tmpl, prop, {
            enumerable: true,
            configurable: true,
            get: function get() {
              return value;
            },
            set: function set(newValue) {
              if (!mutationTrackingDisabled) {
                reportTemplateViolation(prop);
              }
              value = newValue;
            }
          });
        };
        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
          _loop6();
        }
      } catch (err) {
        _iterator15.e(err);
      } finally {
        _iterator15.f();
      }
      var originalDescriptor = getOwnPropertyDescriptor$1(tmpl, 'stylesheetTokens');
      defineProperty(tmpl, 'stylesheetTokens', {
        enumerable: true,
        configurable: true,
        get: originalDescriptor.get,
        set: function set(value) {
          reportTemplateViolation('stylesheetTokens');
          // Avoid logging/reporting twice (for both stylesheetToken and stylesheetTokens)
          mutationTrackingDisabled = true;
          originalDescriptor.set.call(this, value);
          mutationTrackingDisabled = false;
        }
      });
    }
    function addLegacyStylesheetTokensShim(tmpl) {
      // When ENABLE_FROZEN_TEMPLATE is false, then we shim stylesheetTokens on top of stylesheetToken for anyone who
      // is accessing the old internal API (backwards compat). Details: https://salesforce.quip.com/v1rmAFu2cKAr
      defineProperty(tmpl, 'stylesheetTokens', {
        enumerable: true,
        configurable: true,
        get: function get() {
          var stylesheetToken = this.stylesheetToken;
          if (isUndefined$1(stylesheetToken)) {
            return stylesheetToken;
          }
          // Shim for the old `stylesheetTokens` property
          // See https://github.com/salesforce/lwc/pull/2332/files#diff-7901555acef29969adaa6583185b3e9bce475cdc6f23e799a54e0018cb18abaa
          return {
            hostAttribute: "".concat(stylesheetToken, "-host"),
            shadowAttribute: stylesheetToken
          };
        },
        set: function set(value) {
          // If the value is null or some other exotic object, you would be broken anyway in the past
          // because the engine would try to access hostAttribute/shadowAttribute, which would throw an error.
          // However it may be undefined in newer versions of LWC, so we need to guard against that case.
          this.stylesheetToken = isUndefined$1(value) ? undefined : value.shadowAttribute;
        }
      });
    }
    function freezeTemplate(tmpl) {
      // TODO [#2782]: remove this flag and delete the legacy behavior
      if (lwcRuntimeFlags.ENABLE_FROZEN_TEMPLATE) {
        // Deep freeze the template
        freeze(tmpl);
        if (!isUndefined$1(tmpl.stylesheets)) {
          deepFreeze(tmpl.stylesheets);
        }
      } else {
        // template is not frozen - shim, report, and warn
        // this shim should be applied in both dev and prod
        addLegacyStylesheetTokensShim(tmpl);
        // When ENABLE_FROZEN_TEMPLATE is false, we want to warn in dev mode whenever someone is mutating the template
        if (process.env.NODE_ENV !== 'production') {
          trackMutations(tmpl);
        } else {
          // In prod mode, we only track mutations if reporting is enabled
          onReportingEnabled(function () {
            trackMutations(tmpl);
          });
        }
      }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * EXPERIMENTAL: This function provides access to the component constructor, given an HTMLElement.
     * This API is subject to change or being removed.
     */
    function getComponentConstructor(elm) {
      var ctor = null;
      // intentionally checking for undefined due to some funky libraries patching weakmap.get
      // to throw when undefined.
      if (!isUndefined$1(elm)) {
        var vm = getAssociatedVMIfPresent(elm);
        if (!isUndefined$1(vm)) {
          ctor = vm.def.ctor;
        }
      }
      return ctor;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * EXPERIMENTAL: This function allows you to create a reactive readonly
     * membrane around any object value. This API is subject to change or
     * being removed.
     */
    function readonly(obj) {
      if (process.env.NODE_ENV !== 'production') {
        // TODO [#1292]: Remove the readonly decorator
        if (arguments.length !== 1) {
          logError('@readonly cannot be used as a decorator just yet, use it as a function with one argument to produce a readonly version of the provided value.');
        }
      }
      return getReadOnlyProxy(obj);
    }
    /* version: 2.45.1 */

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * Displays the header for a custom element.
     *
     * @param ce the custom element
     * @param componentInstance component instance associated with the custom element.
     */
    function getHeaderForCustomElement(ce, componentInstance) {
      // [element]
      // LWC component instance: [vm.component]
      return ['div', {}, ['object', {
        object: ce,
        config: {
          skip: true
        }
      }], ['div', {}, ['span', {
        style: 'margin: 0 5px; color: red'
      }, 'LWC:'], ['object', {
        object: componentInstance
      }]]];
    }
    function getHeaderForComponentInstance(componentInstance, debugInfo) {
      if (keys(debugInfo).length === 0) {
        // there is no debug information, no need to customize this component instance
        return null;
      }
      // [component]
      // Debug information: [vm.debugInfo]
      return ['div', {}, ['object', {
        object: componentInstance,
        config: {
          skip: true
        }
      }], ['div', {}, ['span', {
        style: 'margin: 0 5px; color: red'
      }, 'Debug:'], ['object', {
        object: debugInfo
      }]]];
    }
    var LightningElementFormatter = {
      name: 'LightningElementFormatter',
      header: function header(obj, config) {
        var vm = getAssociatedVMIfPresent(obj);
        if (!isUndefined$1(vm) && (isUndefined$1(config) || !config.skip)) {
          if (obj instanceof HTMLElement) {
            return getHeaderForCustomElement(obj, vm.component);
          } else {
            return getHeaderForComponentInstance(obj, vm.debugInfo);
          }
        }
        return null;
      },
      hasBody: function hasBody() {
        return false;
      }
    };

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function init() {
      var devtoolsFormatters = _globalThis.devtoolsFormatters || [];
      ArrayPush$1.call(devtoolsFormatters, LightningElementFormatter);
      _globalThis.devtoolsFormatters = devtoolsFormatters;
    }
    if (process.env.NODE_ENV !== 'production') {
      init();
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    //
    // Feature detection
    //
    // This check for constructable style sheets is similar to Fast's:
    // https://github.com/microsoft/fast/blob/d49d1ec/packages/web-components/fast-element/src/dom.ts#L51-L53
    // See also: https://github.com/whatwg/webidl/issues/1027#issuecomment-934510070
    var supportsConstructableStylesheets = isFunction$1(CSSStyleSheet.prototype.replaceSync) && isArray$1(document.adoptedStyleSheets);
    // The original adoptedStylesheet proposal used a frozen array. A follow-up proposal made the array mutable.
    // Chromium 99+ and Firefox 101+ support mutable arrays. We check if the array is mutable, to ensure backward compat.
    // (If the length is writable, then the array is mutable.) See: https://chromestatus.com/feature/5638996492288000
    // TODO [#2828]: Re-evaluate this in the future once we drop support for older browser versions.
    var supportsMutableAdoptedStyleSheets = supportsConstructableStylesheets && getOwnPropertyDescriptor$1(document.adoptedStyleSheets, 'length').writable;
    // Detect IE, via https://stackoverflow.com/a/9851769
    var isIE11 = !isUndefined$1(document.documentMode);
    var stylesheetCache = new Map();
    //
    // Test utilities
    //
    // Only used in LWC's Karma tests
    if (process.env.NODE_ENV === 'test-karma-lwc') {
      // @ts-ignore
      window.__lwcResetGlobalStylesheets = function () {
        stylesheetCache.clear();
      };
    }
    function createFreshStyleElement(content) {
      var elm = document.createElement('style');
      elm.type = 'text/css';
      elm.textContent = content;
      return elm;
    }
    function createStyleElement(content, cacheData) {
      var element = cacheData.element,
        usedElement = cacheData.usedElement;
      // If the <style> was already used, then we should clone it. We cannot insert
      // the same <style> in two places in the DOM.
      if (usedElement) {
        // For a mysterious reason, IE11 doesn't like the way we clone <style> nodes
        // and will render the incorrect styles if we do things that way. It's just
        // a perf optimization, so we can skip it for IE11.
        if (isIE11) {
          return createFreshStyleElement(content);
        }
        // This `<style>` may be repeated multiple times in the DOM, so cache it. It's a bit
        // faster to call `cloneNode()` on an existing node than to recreate it every time.
        return element.cloneNode(true);
      }
      // We don't clone every time, because that would be a perf tax on the first time
      cacheData.usedElement = true;
      return element;
    }
    function createConstructableStylesheet(content) {
      var stylesheet = new CSSStyleSheet();
      stylesheet.replaceSync(content);
      return stylesheet;
    }
    function insertConstructableStylesheet(content, target, cacheData) {
      var adoptedStyleSheets = target.adoptedStyleSheets;
      var stylesheet = cacheData.stylesheet;
      // Mutable adopted stylesheets are only supported in certain browsers.
      // The reason we use it is for perf: https://github.com/salesforce/lwc/pull/2683
      if (supportsMutableAdoptedStyleSheets) {
        adoptedStyleSheets.push(stylesheet);
      } else {
        target.adoptedStyleSheets = [].concat(_toConsumableArray(adoptedStyleSheets), [stylesheet]);
      }
    }
    function insertStyleElement(content, target, cacheData) {
      var elm = createStyleElement(content, cacheData);
      target.appendChild(elm);
    }
    function getCacheData(content, useConstructableStylesheet) {
      var cacheData = stylesheetCache.get(content);
      if (isUndefined$1(cacheData)) {
        cacheData = {
          stylesheet: undefined,
          element: undefined,
          roots: undefined,
          global: false,
          usedElement: false
        };
        stylesheetCache.set(content, cacheData);
      }
      // Create <style> elements or CSSStyleSheets on-demand, as needed
      if (useConstructableStylesheet && isUndefined$1(cacheData.stylesheet)) {
        cacheData.stylesheet = createConstructableStylesheet(content);
      } else if (!useConstructableStylesheet && isUndefined$1(cacheData.element)) {
        cacheData.element = createFreshStyleElement(content);
      }
      return cacheData;
    }
    function insertGlobalStylesheet(content) {
      // Force a <style> element for global stylesheets. See comment below.
      var cacheData = getCacheData(content, false);
      if (cacheData.global) {
        // already inserted
        return;
      }
      cacheData.global = true; // mark inserted
      // TODO [#2922]: use document.adoptedStyleSheets in supported browsers. Currently we can't, due to backwards compat.
      insertStyleElement(content, document.head, cacheData);
    }
    function insertLocalStylesheet(content, target) {
      var cacheData = getCacheData(content, supportsConstructableStylesheets);
      var roots = cacheData.roots;
      if (isUndefined$1(roots)) {
        roots = cacheData.roots = new WeakSet(); // lazily initialize (not needed for global styles)
      } else if (roots.has(target)) {
        // already inserted
        return;
      }
      roots.add(target); // mark inserted
      // Constructable stylesheets are only supported in certain browsers:
      // https://caniuse.com/mdn-api_document_adoptedstylesheets
      // The reason we use it is for perf: https://github.com/salesforce/lwc/pull/2460
      if (supportsConstructableStylesheets) {
        insertConstructableStylesheet(content, target, cacheData);
      } else {
        // Fall back to <style> element
        insertStyleElement(content, target, cacheData);
      }
    }
    function insertStylesheet(content, target) {
      if (isUndefined$1(target)) {
        // global
        insertGlobalStylesheet(content);
      } else {
        // local
        insertLocalStylesheet(content, target);
      }
    }

    /*
     * Copyright (c) 2020, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function isCustomElementRegistryAvailable() {
      if (typeof customElements === 'undefined') {
        return false;
      }
      try {
        // dereference HTMLElement global because babel wraps globals in compat mode with a
        // _wrapNativeSuper()
        // This is a problem because LWCUpgradableElement extends renderer.HTMLElement which does not
        // get wrapped by babel.
        var HTMLElementAlias = HTMLElement;
        // In case we use compat mode with a modern browser, the compat mode transformation
        // invokes the DOM api with an .apply() or .call() to initialize any DOM api sub-classing,
        // which are not equipped to be initialized that way.
        var clazz = /*#__PURE__*/function (_HTMLElementAlias) {
          _inherits(clazz, _HTMLElementAlias);
          var _super4 = _createSuper(clazz);
          function clazz() {
            _classCallCheck(this, clazz);
            return _super4.apply(this, arguments);
          }
          return _createClass(clazz);
        }(HTMLElementAlias);
        customElements.define('lwc-test-' + Math.floor(Math.random() * 1000000), clazz);
        new clazz();
        return true;
      } catch (_a) {
        return false;
      }
    }
    var hasCustomElements = isCustomElementRegistryAvailable();

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // Creates a custom element for compat (legacy) browser environments
    var createCustomElementCompat = function createCustomElementCompat(tagName, upgradeCallback) {
      var elm = document.createElement(tagName);
      upgradeCallback(elm); // nothing to do with the result for now
      return elm;
    };

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var cachedConstructors = new Map();
    var elementsUpgradedOutsideLWC = new WeakSet();
    var elementBeingUpgradedByLWC = false;
    // Creates a constructor that is intended to be used directly as a custom element, except that the upgradeCallback is
    // passed in to the constructor so LWC can reuse the same custom element constructor for multiple components.
    // Another benefit is that only LWC can create components that actually do anything – if you do
    // `customElements.define('x-foo')`, then you don't have access to the upgradeCallback, so it's a dummy custom element.
    // This class should be created once per tag name.
    var createUpgradableConstructor = function createUpgradableConstructor(connectedCallback, disconnectedCallback) {
      var hasConnectedCallback = !isUndefined$1(connectedCallback);
      var hasDisconnectedCallback = !isUndefined$1(disconnectedCallback);
      // TODO [#2972]: this class should expose observedAttributes as necessary
      var UpgradableConstructor = /*#__PURE__*/function (_HTMLElement) {
        _inherits(UpgradableConstructor, _HTMLElement);
        var _super5 = _createSuper(UpgradableConstructor);
        function UpgradableConstructor(upgradeCallback) {
          var _this2;
          _classCallCheck(this, UpgradableConstructor);
          _this2 = _super5.call(this);
          // If the element is not created using lwc.createElement(), e.g. `document.createElement('x-foo')`,
          // then elementBeingUpgraded will be false
          if (elementBeingUpgradedByLWC) {
            upgradeCallback(_assertThisInitialized(_this2));
          } else if (hasConnectedCallback || hasDisconnectedCallback) {
            // If this element has connected or disconnected callbacks, then we need to keep track of
            // instances that were created outside LWC (i.e. not created by `lwc.createElement()`).
            // If the element has no connected or disconnected callbacks, then we don't need to track this.
            elementsUpgradedOutsideLWC.add(_assertThisInitialized(_this2));
            // TODO [#2970]: LWC elements cannot be upgraded via new Ctor()
            // Do we want to support this? Throw an error? Currently for backwards compat it's a no-op.
          }
          return _this2;
        }
        return _createClass(UpgradableConstructor);
      }( /*#__PURE__*/_wrapNativeSuper(HTMLElement)); // Do not unnecessarily add a connectedCallback/disconnectedCallback, as it introduces perf overhead
      // See: https://github.com/salesforce/lwc/pull/3162#issuecomment-1311851174
      if (hasConnectedCallback) {
        UpgradableConstructor.prototype.connectedCallback = function () {
          if (!elementsUpgradedOutsideLWC.has(this)) {
            connectedCallback(this);
          }
        };
      }
      if (hasDisconnectedCallback) {
        UpgradableConstructor.prototype.disconnectedCallback = function () {
          if (!elementsUpgradedOutsideLWC.has(this)) {
            disconnectedCallback(this);
          }
        };
      }
      return UpgradableConstructor;
    };
    var createCustomElementUsingUpgradableConstructor = function createCustomElementUsingUpgradableConstructor(tagName, upgradeCallback, connectedCallback, disconnectedCallback) {
      // use global custom elements registry
      var UpgradableConstructor = cachedConstructors.get(tagName);
      if (isUndefined$1(UpgradableConstructor)) {
        if (!isUndefined$1(customElements.get(tagName))) {
          throw new Error("Unexpected tag name \"".concat(tagName, "\". This name is a registered custom element, preventing LWC to upgrade the element."));
        }
        UpgradableConstructor = createUpgradableConstructor(connectedCallback, disconnectedCallback);
        customElements.define(tagName, UpgradableConstructor);
        cachedConstructors.set(tagName, UpgradableConstructor);
      }
      elementBeingUpgradedByLWC = true;
      try {
        return new UpgradableConstructor(upgradeCallback);
      } finally {
        elementBeingUpgradedByLWC = false;
      }
    };

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * We have two modes for creating custom elements:
     *
     * 1. Compat (legacy) browser support (e.g. IE11). Totally custom, doesn't rely on native browser APIs.
     * 2. "Upgradable constructor" custom element. This allows us to have two LWC components with the same tag name,
     *    via a trick: every custom element constructor we define in the registry is basically the same. It's essentially
     *    a dummy `class extends HTMLElement` that accepts an `upgradeCallback` in its constructor ("upgradable
     *    constructor"), which allows us to have completely customized functionality for different components.
     */
    var createCustomElement;
    if (hasCustomElements) {
      // use the global registry, with an upgradable constructor for the defined custom element
      createCustomElement = createCustomElementUsingUpgradableConstructor;
    } else {
      // no registry available here
      createCustomElement = createCustomElementCompat;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * A factory function that produces a renderer.
     * Renderer encapsulates operations that are required to render an LWC component into the underlying
     * runtime environment. In the case of @lwc/enigne-dom, it is meant to be used in a DOM environment.
     * Example usage:
     * import { renderer, rendererFactory } from 'lwc';
     * const customRenderer = rendererFactory(renderer);
     *
     * @param baseRenderer Either null or the base renderer imported from 'lwc'.
     */
    function rendererFactory(baseRenderer) {
      var renderer = function (exports) {
        /**
         * Copyright (C) 2018 salesforce.com, inc.
         */
        /*
         * Copyright (c) 2018, salesforce.com, inc.
         * All rights reserved.
         * SPDX-License-Identifier: MIT
         * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
         */
        function invariant(value, msg) {
          if (!value) {
            throw new Error("Invariant Violation: ".concat(msg));
          }
        }
        function isTrue$1(value, msg) {
          if (!value) {
            throw new Error("Assert Violation: ".concat(msg));
          }
        }
        function isFalse$1(value, msg) {
          if (value) {
            throw new Error("Assert Violation: ".concat(msg));
          }
        }
        function fail(msg) {
          throw new Error(msg);
        }
        var assert = /*#__PURE__*/Object.freeze({
          __proto__: null,
          fail: fail,
          invariant: invariant,
          isFalse: isFalse$1,
          isTrue: isTrue$1
        });
        function isUndefined(obj) {
          return obj === undefined;
        }
        function isNull(obj) {
          return obj === null;
        }
        /** version: 2.45.1 */

        /*
         * Copyright (c) 2023, salesforce.com, inc.
         * All rights reserved.
         * SPDX-License-Identifier: MIT
         * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
         */
        var WireContextSubscriptionEvent = /*#__PURE__*/function (_CustomEvent) {
          _inherits(WireContextSubscriptionEvent, _CustomEvent);
          var _super6 = _createSuper(WireContextSubscriptionEvent);
          function WireContextSubscriptionEvent(adapterToken, _ref5) {
            var _this3;
            var setNewContext = _ref5.setNewContext,
              setDisconnectedCallback = _ref5.setDisconnectedCallback;
            _classCallCheck(this, WireContextSubscriptionEvent);
            _this3 = _super6.call(this, adapterToken, {
              bubbles: true,
              composed: true
            });
            _this3.setNewContext = setNewContext;
            _this3.setDisconnectedCallback = setDisconnectedCallback;
            return _this3;
          }
          return _createClass(WireContextSubscriptionEvent);
        }( /*#__PURE__*/_wrapNativeSuper(CustomEvent));
        function registerContextConsumer(elm, adapterContextToken, subscriptionPayload) {
          dispatchEvent(elm, new WireContextSubscriptionEvent(adapterContextToken, subscriptionPayload));
        }
        function registerContextProvider(elm, adapterContextToken, onContextSubscription) {
          addEventListener(elm, adapterContextToken, function (evt) {
            evt.stopImmediatePropagation();
            var setNewContext = evt.setNewContext,
              setDisconnectedCallback = evt.setDisconnectedCallback;
            onContextSubscription({
              setNewContext: setNewContext,
              setDisconnectedCallback: setDisconnectedCallback
            });
          });
        }

        /*
         * Copyright (c) 2018, salesforce.com, inc.
         * All rights reserved.
         * SPDX-License-Identifier: MIT
         * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
         */
        function cloneNode(node, deep) {
          return node.cloneNode(deep);
        }
        function createElement(tagName, namespace) {
          return isUndefined(namespace) ? document.createElement(tagName) : document.createElementNS(namespace, tagName);
        }
        function createText(content) {
          return document.createTextNode(content);
        }
        function createComment(content) {
          return document.createComment(content);
        }
        exports.createFragment = void 0;
        // IE11 lacks support for this feature
        var SUPPORTS_TEMPLATE = typeof HTMLTemplateElement === 'function';
        if (SUPPORTS_TEMPLATE) {
          // Parse the fragment HTML string into DOM
          exports.createFragment = function (html) {
            var template = document.createElement('template');
            template.innerHTML = html;
            return template.content.firstChild;
          };
        } else {
          // In browsers that don't support <template> (e.g. IE11), we need to be careful to wrap elements like
          // <td> in the proper container elements (e.g. <tbody>), because otherwise they will be parsed as null.
          // Via https://github.com/webcomponents/polyfills/blob/ee1db33/packages/template/template.js#L273-L280
          // With other elements added from:
          // https://github.com/sindresorhus/html-tags/blob/95dcdd5/index.js
          // Using the test:
          // document.createRange().createContextualFragment(`<${tag}></${tag}>`).firstChild === null
          // And omitting <html>, <head>, and <body> as these are not practical in an LWC component.
          var topLevelWrappingMap = {
            caption: ['table'],
            col: ['colgroup', 'table'],
            colgroup: ['table'],
            option: ['select'],
            tbody: ['table'],
            td: ['tr', 'tbody', 'table'],
            th: ['tr', 'tbody', 'table'],
            thead: ['table'],
            tfoot: ['table'],
            tr: ['tbody', 'table']
          };
          // Via https://github.com/webcomponents/polyfills/blob/ee1db33/packages/template/template.js#L282-L288
          var getTagName = function getTagName(text) {
            return (/<([a-z][^/\0>\x20\t\r\n\f]+)/i.exec(text) || ['', ''])[1].toLowerCase();
          };
          // Via https://github.com/webcomponents/polyfills/blob/ee1db33/packages/template/template.js#L295-L320
          exports.createFragment = function (html) {
            var wrapperTags = topLevelWrappingMap[getTagName(html)];
            if (!isUndefined(wrapperTags)) {
              var _iterator16 = _createForOfIteratorHelper(wrapperTags),
                _step16;
              try {
                for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
                  var wrapperTag = _step16.value;
                  html = "<".concat(wrapperTag, ">").concat(html, "</").concat(wrapperTag, ">");
                }
              } catch (err) {
                _iterator16.e(err);
              } finally {
                _iterator16.f();
              }
            }
            // For IE11, the document title must not be undefined, but it can be an empty string
            // https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createHTMLDocument#browser_compatibility
            var doc = document.implementation.createHTMLDocument('');
            doc.body.innerHTML = html;
            var content = doc.body;
            if (!isUndefined(wrapperTags)) {
              for (var _i40 = 0; _i40 < wrapperTags.length; _i40++) {
                content = content.firstChild;
              }
            }
            return content.firstChild;
          };
        }
        function insert(node, parent, anchor) {
          parent.insertBefore(node, anchor);
        }
        function remove(node, parent) {
          parent.removeChild(node);
        }
        function nextSibling(node) {
          return node.nextSibling;
        }
        function attachShadow(element, options) {
          // `shadowRoot` will be non-null in two cases:
          //   1. upon initial load with an SSR-generated DOM, while in Shadow render mode
          //   2. when a webapp author places <c-app> in their static HTML and mounts their
          //      root component with customElement.define('c-app', Ctor)
          if (!isNull(element.shadowRoot)) {
            return element.shadowRoot;
          }
          return element.attachShadow(options);
        }
        function setText(node, content) {
          node.nodeValue = content;
        }
        function getProperty(node, key) {
          return node[key];
        }
        function setProperty(node, key, value) {
          node[key] = value;
        }
        function getAttribute(element, name, namespace) {
          return isUndefined(namespace) ? element.getAttribute(name) : element.getAttributeNS(namespace, name);
        }
        function setAttribute(element, name, value, namespace) {
          return isUndefined(namespace) ? element.setAttribute(name, value) : element.setAttributeNS(namespace, name, value);
        }
        function removeAttribute(element, name, namespace) {
          if (isUndefined(namespace)) {
            element.removeAttribute(name);
          } else {
            element.removeAttributeNS(namespace, name);
          }
        }
        function addEventListener(target, type, callback, options) {
          target.addEventListener(type, callback, options);
        }
        function removeEventListener(target, type, callback, options) {
          target.removeEventListener(type, callback, options);
        }
        function dispatchEvent(target, event) {
          return target.dispatchEvent(event);
        }
        function getClassList(element) {
          return element.classList;
        }
        function setCSSStyleProperty(element, name, value, important) {
          // TODO [#0]: How to avoid this type casting? Shall we use a different type interface to
          // represent elements in the engine?
          element.style.setProperty(name, value, important ? 'important' : '');
        }
        function getBoundingClientRect(element) {
          return element.getBoundingClientRect();
        }
        function querySelector(element, selectors) {
          return element.querySelector(selectors);
        }
        function querySelectorAll(element, selectors) {
          return element.querySelectorAll(selectors);
        }
        function getElementsByTagName(element, tagNameOrWildCard) {
          return element.getElementsByTagName(tagNameOrWildCard);
        }
        function getElementsByClassName(element, names) {
          return element.getElementsByClassName(names);
        }
        function getChildren(element) {
          return element.children;
        }
        function getChildNodes(element) {
          return element.childNodes;
        }
        function getFirstChild(element) {
          return element.firstChild;
        }
        function getFirstElementChild(element) {
          return element.firstElementChild;
        }
        function getLastChild(element) {
          return element.lastChild;
        }
        function getLastElementChild(element) {
          return element.lastElementChild;
        }
        function isConnected(node) {
          return node.isConnected;
        }
        function assertInstanceOfHTMLElement(elm, msg) {
          assert.invariant(elm instanceof HTMLElement, msg);
        }
        function ownerDocument(element) {
          return element.ownerDocument;
        }
        exports.addEventListener = addEventListener;
        exports.assertInstanceOfHTMLElement = assertInstanceOfHTMLElement;
        exports.attachShadow = attachShadow;
        exports.cloneNode = cloneNode;
        exports.createComment = createComment;
        exports.createElement = createElement;
        exports.createText = createText;
        exports.dispatchEvent = dispatchEvent;
        exports.getAttribute = getAttribute;
        exports.getBoundingClientRect = getBoundingClientRect;
        exports.getChildNodes = getChildNodes;
        exports.getChildren = getChildren;
        exports.getClassList = getClassList;
        exports.getElementsByClassName = getElementsByClassName;
        exports.getElementsByTagName = getElementsByTagName;
        exports.getFirstChild = getFirstChild;
        exports.getFirstElementChild = getFirstElementChild;
        exports.getLastChild = getLastChild;
        exports.getLastElementChild = getLastElementChild;
        exports.getProperty = getProperty;
        exports.insert = insert;
        exports.isConnected = isConnected;
        exports.nextSibling = nextSibling;
        exports.ownerDocument = ownerDocument;
        exports.querySelector = querySelector;
        exports.querySelectorAll = querySelectorAll;
        exports.registerContextConsumer = registerContextConsumer;
        exports.registerContextProvider = registerContextProvider;
        exports.remove = remove;
        exports.removeAttribute = removeAttribute;
        exports.removeEventListener = removeEventListener;
        exports.setAttribute = setAttribute;
        exports.setCSSStyleProperty = setCSSStyleProperty;
        exports.setProperty = setProperty;
        exports.setText = setText;
        return exports;
      }({});
      // Meant to inherit any properties passed via the base renderer as the argument to the factory.
      Object.setPrototypeOf(renderer, baseRenderer);
      return renderer;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * The base renderer that will be used by engine-core.
     * This will be used for DOM operations when lwc is running in a browser environment.
     */
    var renderer = assign(
    // The base renderer will invoke the factory with null and assign additional properties that are
    // shared across renderers
    rendererFactory(null),
    // Properties that are either not required to be sandboxed or rely on a globally shared information
    {
      // insertStyleSheet implementation shares a global cache of stylesheet data
      insertStylesheet: insertStylesheet,
      // relies on a shared global cache
      createCustomElement: createCustomElement,
      isNativeShadowDefined: _globalThis[KEY__IS_NATIVE_SHADOW_ROOT_DEFINED],
      isSyntheticShadowDefined: hasOwnProperty$1.call(Element.prototype, KEY__SHADOW_TOKEN)
    });

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function resetShadowRootAndLightDom(element, Ctor) {
      if (element.shadowRoot) {
        var shadowRoot = element.shadowRoot;
        while (!isNull(shadowRoot.firstChild)) {
          shadowRoot.removeChild(shadowRoot.firstChild);
        }
      }
      if (Ctor.renderMode === 'light') {
        while (!isNull(element.firstChild)) {
          element.removeChild(element.firstChild);
        }
      }
    }
    function createVMWithProps(element, Ctor, props) {
      var vm = createVM(element, Ctor, renderer, {
        mode: 'open',
        owner: null,
        tagName: element.tagName.toLowerCase(),
        hydrated: true
      });
      for (var _i41 = 0, _Object$entries2 = Object.entries(props); _i41 < _Object$entries2.length; _i41++) {
        var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i41], 2),
          key = _Object$entries2$_i[0],
          value = _Object$entries2$_i[1];
        element[key] = value;
      }
      return vm;
    }
    function hydrateComponent(element, Ctor) {
      var props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      if (!(element instanceof Element)) {
        throw new TypeError("\"hydrateComponent\" expects a valid DOM element as the first parameter but instead received ".concat(element, "."));
      }
      if (!isFunction$1(Ctor)) {
        throw new TypeError("\"hydrateComponent\" expects a valid component constructor as the second parameter but instead received ".concat(Ctor, "."));
      }
      if (!isObject(props) || isNull(props)) {
        throw new TypeError("\"hydrateComponent\" expects an object as the third parameter but instead received ".concat(props, "."));
      }
      if (getAssociatedVMIfPresent(element)) {
        /* eslint-disable-next-line no-console */
        console.warn("\"hydrateComponent\" expects an element that is not hydrated.", element);
        return;
      }
      try {
        var vm = createVMWithProps(element, Ctor, props);
        hydrateRoot(vm);
      } catch (e) {
        // Fallback: In case there's an error while hydrating, let's log the error, and replace the element content
        //           with the client generated DOM.
        /* eslint-disable-next-line no-console */
        console.error('Recovering from error while hydrating: ', e);
        // We want to preserve the element, so we need to reset the shadowRoot and light dom.
        resetShadowRootAndLightDom(element, Ctor);
        // we need to recreate the vm with the hydration flag on, so it re-uses the existing shadowRoot.
        createVMWithProps(element, Ctor, props);
        connectRootElement(element);
      }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * This function builds a Web Component class from a LWC constructor so it can be
     * registered as a new element via customElements.define() at any given time.
     *
     * @deprecated since version 1.3.11
     *
     * @example
     * ```
     * import { buildCustomElementConstructor } from 'lwc';
     * import Foo from 'ns/foo';
     * const WC = buildCustomElementConstructor(Foo);
     * customElements.define('x-foo', WC);
     * const elm = document.createElement('x-foo');
     * ```
     */
    function deprecatedBuildCustomElementConstructor(Ctor) {
      if (process.env.NODE_ENV !== 'production') {
        /* eslint-disable-next-line no-console */
        console.warn('Deprecated function called: "buildCustomElementConstructor" function is deprecated and it will be removed.' + "Use \"".concat(Ctor.name, ".CustomElementConstructor\" static property of the component constructor to access the corresponding custom element constructor instead."));
      }
      return Ctor.CustomElementConstructor;
    }
    // Note: WeakSet is not supported in IE11, and the polyfill is not performant enough.
    //       This WeakSet usage is valid because this functionality is not meant to run in IE11.
    var hydratedCustomElements = new WeakSet();
    function buildCustomElementConstructor(Ctor) {
      var _a;
      var HtmlPrototype = getComponentHtmlPrototype(Ctor);
      var observedAttributes = HtmlPrototype.observedAttributes;
      var _attributeChangedCallback = HtmlPrototype.prototype.attributeChangedCallback;
      return _a = /*#__PURE__*/function (_HTMLElement2) {
        _inherits(_a, _HTMLElement2);
        var _super7 = _createSuper(_a);
        function _a() {
          var _this4;
          _classCallCheck(this, _a);
          _this4 = _super7.call(this);
          if (_this4.isConnected) {
            // this if block is hit when there's already an un-upgraded element in the DOM with the same tag name.
            hydrateComponent(_assertThisInitialized(_this4), Ctor, {});
            hydratedCustomElements.add(_assertThisInitialized(_this4));
          } else {
            createVM(_assertThisInitialized(_this4), Ctor, renderer, {
              mode: 'open',
              owner: null,
              tagName: _this4.tagName
            });
          }
          return _this4;
        }
        _createClass(_a, [{
          key: "connectedCallback",
          value: function connectedCallback() {
            if (hydratedCustomElements.has(this)) {
              // This is an un-upgraded element that was hydrated in the constructor.
              hydratedCustomElements.delete(this);
            } else {
              connectRootElement(this);
            }
          }
        }, {
          key: "disconnectedCallback",
          value: function disconnectedCallback() {
            disconnectRootElement(this);
          }
        }, {
          key: "attributeChangedCallback",
          value: function attributeChangedCallback(name, oldValue, newValue) {
            _attributeChangedCallback.call(this, name, oldValue, newValue);
          }
        }]);
        return _a;
      }( /*#__PURE__*/_wrapNativeSuper(HTMLElement)), _a.observedAttributes = observedAttributes, _a;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // TODO [#2472]: Remove this workaround when appropriate.
    // eslint-disable-next-line @lwc/lwc-internal/no-global-node
    var _Node$1 = Node;
    var ConnectingSlot = new WeakMap();
    var DisconnectingSlot = new WeakMap();
    function callNodeSlot(node, slot) {
      if (process.env.NODE_ENV !== 'production') {
        assert.isTrue(node, "callNodeSlot() should not be called for a non-object");
      }
      var fn = slot.get(node);
      if (!isUndefined$1(fn)) {
        fn(node);
      }
      return node; // for convenience
    }

    if (!lwcRuntimeFlags.ENABLE_NATIVE_CUSTOM_ELEMENT_LIFECYCLE) {
      // Monkey patching Node methods to be able to detect the insertions and removal of root elements
      // created via createElement.
      var _Node$1$prototype = _Node$1.prototype,
        _appendChild = _Node$1$prototype.appendChild,
        _insertBefore = _Node$1$prototype.insertBefore,
        _removeChild = _Node$1$prototype.removeChild,
        _replaceChild = _Node$1$prototype.replaceChild;
      assign(_Node$1.prototype, {
        appendChild: function appendChild(newChild) {
          var appendedNode = _appendChild.call(this, newChild);
          return callNodeSlot(appendedNode, ConnectingSlot);
        },
        insertBefore: function insertBefore(newChild, referenceNode) {
          var insertedNode = _insertBefore.call(this, newChild, referenceNode);
          return callNodeSlot(insertedNode, ConnectingSlot);
        },
        removeChild: function removeChild(oldChild) {
          var removedNode = _removeChild.call(this, oldChild);
          return callNodeSlot(removedNode, DisconnectingSlot);
        },
        replaceChild: function replaceChild(newChild, oldChild) {
          var replacedNode = _replaceChild.call(this, newChild, oldChild);
          callNodeSlot(replacedNode, DisconnectingSlot);
          callNodeSlot(newChild, ConnectingSlot);
          return replacedNode;
        }
      });
    }
    /**
     * EXPERIMENTAL: This function is almost identical to document.createElement with the slightly
     * difference that in the options, you can pass the `is` property set to a Constructor instead of
     * just a string value. The intent is to allow the creation of an element controlled by LWC without
     * having to register the element as a custom element.
     *
     * @example
     * ```
     * const el = createElement('x-foo', { is: FooCtor });
     * ```
     */
    function createElement(sel, options) {
      if (!isObject(options) || isNull(options)) {
        throw new TypeError("\"createElement\" function expects an object as second parameter but received \"".concat(toString$1(options), "\"."));
      }
      var Ctor = options.is;
      if (!isFunction$1(Ctor)) {
        throw new TypeError("\"createElement\" function expects an \"is\" option with a valid component constructor.");
      }
      var createCustomElement = renderer.createCustomElement;
      // tagName must be all lowercase, unfortunately, we have legacy code that is
      // passing `sel` as a camel-case, which makes them invalid custom elements name
      // the following line guarantees that this does not leaks beyond this point.
      var tagName = StringToLowerCase.call(sel);
      // the custom element from the registry is expecting an upgrade callback
      /**
       * Note: if the upgradable constructor does not expect, or throw when we new it
       * with a callback as the first argument, we could implement a more advanced
       * mechanism that only passes that argument if the constructor is known to be
       * an upgradable custom element.
       */
      var upgradeCallback = function upgradeCallback(elm) {
        createVM(elm, Ctor, renderer, {
          tagName: tagName,
          mode: options.mode !== 'closed' ? 'open' : 'closed',
          owner: null
        });
        if (!lwcRuntimeFlags.ENABLE_NATIVE_CUSTOM_ELEMENT_LIFECYCLE) {
          ConnectingSlot.set(elm, connectRootElement);
          DisconnectingSlot.set(elm, disconnectRootElement);
        }
      };
      var connectedCallback;
      var disconnectedCallback;
      if (lwcRuntimeFlags.ENABLE_NATIVE_CUSTOM_ELEMENT_LIFECYCLE) {
        connectedCallback = function connectedCallback(elm) {
          connectRootElement(elm);
        };
        disconnectedCallback = function disconnectedCallback(elm) {
          disconnectRootElement(elm);
        };
      }
      var element = createCustomElement(tagName, upgradeCallback, connectedCallback, disconnectedCallback);
      return element;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // TODO [#2472]: Remove this workaround when appropriate.
    // eslint-disable-next-line @lwc/lwc-internal/no-global-node
    var _Node = Node;
    /**
     * EXPERIMENTAL: The purpose of this function is to detect shadowed nodes. THIS API WILL BE REMOVED
     * ONCE LOCKER V1 IS NO LONGER SUPPORTED.
     */
    function isNodeShadowed(node) {
      if (isFalse(node instanceof _Node)) {
        return false;
      }
      // It's debatable whether shadow root instances should be considered as shadowed, but we keep
      // this unchanged for legacy reasons (#1250).
      if (node instanceof ShadowRoot) {
        return false;
      }
      var rootNode = node.getRootNode();
      // Handle the native case. We can return early here because an invariant of LWC is that
      // synthetic roots cannot be descendants of native roots.
      if (rootNode instanceof ShadowRoot && isFalse(hasOwnProperty$1.call(getPrototypeOf$1(rootNode), 'synthetic'))) {
        return true;
      }
      // TODO [#1252]: Old behavior that is still used by some pieces of the platform. Manually
      // inserted nodes without the `lwc:dom=manual` directive will be considered as global elements.
      return renderer.isSyntheticShadowDefined && !isUndefined$1(node[KEY__SHADOW_RESOLVER]);
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var ComponentConstructorToCustomElementConstructorMap = new Map();
    function getCustomElementConstructor(Ctor) {
      if (Ctor === LightningElement) {
        throw new TypeError("Invalid Constructor. LightningElement base class can't be claimed as a custom element.");
      }
      var ce = ComponentConstructorToCustomElementConstructorMap.get(Ctor);
      if (isUndefined$1(ce)) {
        ce = buildCustomElementConstructor(Ctor);
        ComponentConstructorToCustomElementConstructorMap.set(Ctor, ce);
      }
      return ce;
    }
    /**
     * This static getter builds a Web Component class from a LWC constructor so it can be registered
     * as a new element via customElements.define() at any given time. E.g.:
     *
     *      import Foo from 'ns/foo';
     *      customElements.define('x-foo', Foo.CustomElementConstructor);
     *      const elm = document.createElement('x-foo');
     *
     */
    defineProperty(LightningElement, 'CustomElementConstructor', {
      get: function get() {
        return getCustomElementConstructor(this);
      }
    });
    freeze(LightningElement);
    seal(LightningElement.prototype);

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function addEventListener(target, type, callback, options) {
      target.addEventListener(type, callback, options);
    }

    /*
     * Copyright (c) 2023, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function createContextProvider(adapter) {
      return createContextProviderWithRegister(adapter, registerContextProvider);
    }
    function registerContextProvider(elm, adapterContextToken, onContextSubscription) {
      addEventListener(elm, adapterContextToken, function (evt) {
        evt.stopImmediatePropagation();
        var setNewContext = evt.setNewContext,
          setDisconnectedCallback = evt.setDisconnectedCallback;
        onContextSubscription({
          setNewContext: setNewContext,
          setDisconnectedCallback: setDisconnectedCallback
        });
      });
    }
    /* version: 2.45.1 */

    exports.LightningElement = LightningElement;
    exports.__unstable__ProfilerControl = profilerControl;
    exports.__unstable__ReportingControl = reportingControl;
    exports.api = api$1;
    exports.buildCustomElementConstructor = deprecatedBuildCustomElementConstructor;
    exports.createContextProvider = createContextProvider;
    exports.createElement = createElement;
    exports.freezeTemplate = freezeTemplate;
    exports.getComponentConstructor = getComponentConstructor;
    exports.getComponentDef = getComponentDef;
    exports.hydrateComponent = hydrateComponent;
    exports.isComponentConstructor = isComponentConstructor;
    exports.isNodeFromTemplate = isNodeShadowed;
    exports.parseFragment = parseFragment;
    exports.parseSVGFragment = parseSVGFragment;
    exports.readonly = readonly;
    exports.register = register;
    exports.registerComponent = registerComponent;
    exports.registerDecorators = registerDecorators;
    exports.registerTemplate = registerTemplate;
    exports.renderer = renderer;
    exports.rendererFactory = rendererFactory;
    exports.sanitizeAttribute = sanitizeAttribute;
    exports.setFeatureFlag = setFeatureFlag;
    exports.setFeatureFlagForTest = setFeatureFlagForTest;
    exports.setHooks = setHooks;
    exports.swapComponent = swapComponent;
    exports.swapStyle = swapStyle;
    exports.swapTemplate = swapTemplate;
    exports.track = track;
    exports.unwrap = unwrap;
    exports.wire = wire;

    return exports;

})({});
//# sourceMappingURL=engine-dom.js.map
